<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>七、Docker网络</title>
    <link href="/2022/07/05/docker-network/"/>
    <url>/2022/07/05/docker-network/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><h2 id="1-1-Docker-网络发展史"><a href="#1-1-Docker-网络发展史" class="headerlink" title="1.1 Docker 网络发展史"></a>1.1 Docker 网络发展史</h2><p>Docker 从 2013 年诞生，到后来逐渐成为了容器的代名词，然而 Docker 的野心也不止于此，它还想在更多的领域独占鳌头，比如制定容器的网络和存储标准。于是 Docker 从 1.7 版本开始，便把网络和存储从 Docker 中正式以插件的形式剥离开来，并且分别为其定义了标准，Docker 定义的网络模型标准称之为 ：<strong>CNM (Container Network Model)</strong> 。</p><p>Docker 推出 CNM 的同时，CoreOS 推出了 CNI（Container Network Model）。起初，以 Kubernetes 为代表的容器编排阵营考虑过使用 CNM 作为容器的网络标准，但是后来由于很多技术和非技术原因（如果你对详细原因感兴趣，可以参考<a href="https://kubernetes.io/blog/2016/01/why-kubernetes-doesnt-use-libnetwork/">这篇博客</a>），Kubernetes 决定支持 CoreOS 推出的容器网络标准 CNI。</p><h2 id="1-2-CNM"><a href="#1-2-CNM" class="headerlink" title="1.2 CNM"></a>1.2 CNM</h2><p>**CNM (Container Network Model) **是 Docker 发布的容器网络标准，意在规范和指定容器网络发展标准，CNM 抽象了容器的网络接口 ，使得只要满足 CNM 接口的网络方案都可以接入到 Docker 容器网络，更好地满足了用户网络模型多样化的需求。</p><p>CNM 只是定义了网络标准，对于底层的具体实现并不太关心，这样便解耦了容器和网络，使得容器的<br>网络模型更加灵活。<br>CNM 定义的网络标准包含三个重要元素。</p><ul><li><strong>沙箱（Sandbox）：</strong>沙箱代表了一系列网络堆栈的配置，其中包含路由信息、网络接口等网络资源的管理，沙箱的实现通常是 Linux 的 Net Namespace，但也可以通过其他技术来实现，比如：FreeBSD jail 等。</li><li><strong>接入点（Endpoint）：</strong>接入点将沙箱连接到网络中，代表容器的网络接口，接入点的实现通常是 Linux 的 veth 设备对。</li><li><strong>网络（Network）：</strong>网络是一组可以互相通信的接入点，它将多接入点组成一个子网，并且多个接入点之间可以相互通信。</li></ul><div class="note note-success">            <p>CNM 的三个要素基本抽象了所有网络模型，使得网络模型的开发更加规范。<br>为了更好地构建容器网络标准，Docker 团队把网络功能从 Docker 中剥离出来，成为独立的项目<code>libnetwork</code>，它通过插件的形式为 Docker 提供网络功能。Libnetwork 是开源的，使用 Golang 编写，它完全遵循 CNM 网络规范，是 CNM 的官方实现。</p>          </div><h1 id="2-Libnetwork-常见网络模式"><a href="#2-Libnetwork-常见网络模式" class="headerlink" title="2. Libnetwork 常见网络模式"></a>2. Libnetwork 常见网络模式</h1><p>Libnetwork 比较典型的网络模式主要有四种，这四种网络模式基本满足了我们单机容器的所有场景。</p><ol><li><strong>null 空网络模式</strong>：可以帮助我们构建一个没有网络接入的容器环境，以保障数据安全。</li><li><strong>bridge 桥接模式：</strong>可以打通容器与容器间网络通信的需求。</li><li><strong>host 主机网络模式：</strong>可以让容器内的进程共享主机网络，从而监听或修改主机网络。</li><li><strong>container 网络模式：</strong>可以将两个容器放在同一个网络命名空间内，让两个业务通过 localhost 即可实现访问。</li></ol><p>下面我们对 libnetwork 的四种网络模式逐一讲解：</p><h2 id="2-1-null-空网络模式"><a href="#2-1-null-空网络模式" class="headerlink" title="2.1 null 空网络模式"></a>2.1 null 空网络模式</h2><p>有时候，我们需要处理一些保密数据，出于安全考虑，我们需要一个隔离的网络环境执行一些纯计算任务。这时候 null 网络模式就派上用场了，这时候我们的容器就像一个没有联网的电脑，处于一个相对较安全的环境，确保我们的数据不被他人从网络窃取。</p><p><strong>使用 Docker 创建 null 空网络模式的容器时，容器拥有自己独立的</strong><code>**Net Namespace**</code><strong>，但是此时的容器并没有任何网络配置</strong>。在这种模式下，Docker 除了为容器创建了<code>Net Namespace</code>外，没有创建任何：<code>网卡接口</code>、<code>IP 地址</code>、<code>路由</code>等网络配置。<br>例如：我们使用 docker run 命令启动时，添加 –net&#x3D;none 参数启动一个空网络模式的容器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --net=none -it busybox</span><br>/ #  ifconfig<br>lo        Link encap:Local Loopback<br>          inet addr:127.0.0.1  Mask:255.0.0.0<br>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)<br></code></pre></td></tr></table></figure><p>可以看到容器内除了 Net Namespace 自带的 lo 网卡并没有创建任何虚拟网卡，然后使用<code>route -n</code>命令查看一下容器内的路由信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br></code></pre></td></tr></table></figure><p>可以看到，容器内也并没有配置任何路由信息。</p><h2 id="2-2）bridge-桥接模式"><a href="#2-2）bridge-桥接模式" class="headerlink" title="2.2）bridge 桥接模式"></a>2.2）bridge 桥接模式</h2><p><strong>Docker 的 bridge 网络是启动容器时默认的网络模式</strong>，<strong>使用 bridge 网络可以实现容器与容器的互通，可以从一个容器直接通过容器 IP 访问到另外一个容器</strong>。同时使用 bridge 网络可以实现主机与容器的互通，我们在容器内启动的业务，可以从主机直接请求。</p><p>在介绍 Docker 的 bridge 桥接模式前，我们需要先了解一下 Linux 的<code>veth</code>和<code>bridge</code>相关的技术，因为 Docker 的 bridge 模式正是由这两种技术实现的。<br><strong>Linux veth</strong><br>veth 是 Linux 中的虚拟设备接口，veth 都是成对出现的，它在容器中，通常充当一个桥梁。veth 可以用来连接虚拟网络设备，例如 veth 可以用来连通两个 Net Namespace，从而使得两个 NetNamespace 之间可以互相访问。</p><p><strong>Linux bridge</strong><br>Linux bridge 是一个虚拟设备，是用来连接网络的设备，相当于物理网络环境中的交换机。Linux bridge 可以用来转发两个 Net Namespace 内的流量。</p><ul><li><strong>veth 与 bridge 的关系</strong></li></ul><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FoqklU2oZzHSxq7HuRgfx-sGu4jE.png"><br>bridge 就像一台交换机，而 veth 就像一根网线，通过交换机和网线可以把两个不同 Net Namespace 的容器连通，使得它们可以互相通信。</p><div class="note note-success">            <p>Docker 的 bridge 模式也是这种原理。Docker 启动时，libnetwork 会在主机上创建<code>docker0</code>网桥，docker0 网桥就相当于上图中的交换机，而 Docker 创建出的 brige 模式的容器则都会连接 docker0 上，从而实现网络互通。</p>          </div><p><strong>bridge 桥接模式是 Docker 的默认网络模式，当我们创建容器时不指定任何网络模式，Docker 启动容器默认的网络模式为 bridge。</strong></p><h2 id="2-3-host-主机网络模式"><a href="#2-3-host-主机网络模式" class="headerlink" title="2.3 host 主机网络模式"></a>2.3 host 主机网络模式</h2><p>容器内的网络并不是希望永远跟主机是隔离的，有些基础业务需要创建或更新主机的网络配置，我们的程序必须以主机网络模式运行才能够修改主机网络，这时候就需要用到 Docker 的 host 主机网络模式。</p><p>使用 host 主机网络模式时：</p><ul><li><strong>libnetwork 不会为容器创建新的网络配置和 Net Namespace。</strong></li><li>Docker 容器中的进程直接共享主机的网络配置，可以直接使用主机的网络信息，此时，在容器内监听的端口，也将直接占用到主机的端口。</li><li>除了网络共享主机的网络外，其他的包括进程、文件系统、主机名等都是与主机隔离的。</li></ul><p><strong>host 主机网络模式通常适用于想要使用主机网络，但又不想把运行环境直接安装到主机上的场景中</strong>。例如我想在主机上运行一个 busybox 服务，但又不想直接把 busybox 安装到主机上污染主机环境，此时我可以使用以下命令启动一个主机网络模式的 busybox 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --net=host busybox</span><br><br>/ # ifconfig<br>docker0   Link encap:Ethernet  HWaddr 02:42:6A:DD:E9:7B<br>          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0<br>          inet6 addr: fe80::42:6aff:fedd:e97b/64 Scope:Link<br>          UP BROADCAST MULTICAST  MTU:1500  Metric:1<br>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:7 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:0<br>          RX bytes:0 (0.0 B)  TX bytes:746 (746.0 B)<br><br>ens192    Link encap:Ethernet  HWaddr 00:0C:29:A6:AF:A0<br>          inet addr:172.16.2.77  Bcast:172.16.2.255  Mask:255.255.255.0<br>          inet6 addr: fe80::2a6f:4800:8e71:ce88/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:125857 errors:0 dropped:7131 overruns:0 frame:0<br>          TX packets:13372 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:101567720 (96.8 MiB)  TX bytes:1082859 (1.0 MiB)<br><br>lo        Link encap:Local Loopback<br>          inet addr:127.0.0.1  Mask:255.0.0.0<br>          inet6 addr: ::1/128 Scope:Host<br>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br>          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:5904 (5.7 KiB)  TX bytes:5904 (5.7 KiB)<br></code></pre></td></tr></table></figure><p>可以看到容器内的网络环境与主机完全一致。</p><h2 id="2-4-container-网络模式"><a href="#2-4-container-网络模式" class="headerlink" title="2.4 container 网络模式"></a>2.4 container 网络模式</h2><p><strong>container 网络模式允许一个容器共享另一个容器的网络命名空间</strong>。当两个容器需要共享网络，但其他资源仍然需要隔离时就可以使用 container 网络模式。例如我们开发了一个 http 服务，但又想使用 nginx 的一些特性，让 nginx 代理外部的请求然后转发给自己的业务，这时我们使用 container 网络模式将自己开发的服务和 nginx 服务部署到同一个网络命名空间中。</p><p>下面我举例说明。首先我们使用以下命令启动一个 busybox1 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name=busybox1 busybox <span class="hljs-built_in">sleep</span> 3600</span><br></code></pre></td></tr></table></figure><p>然后我们使用 docker exec 命令进入到 centos 容器中查看一下网络配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it busybox1 sh</span><br>/ # ifconfig<br>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:02<br>          inet addr:172.17.0.2  Bcast:172.17.255.255  Mask:255.255.0.0<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:9 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:0<br>          RX bytes:806 (806.0 B)  TX bytes:0 (0.0 B)<br><br>lo        Link encap:Local Loopback<br>          inet addr:127.0.0.1  Mask:255.0.0.0<br>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)<br></code></pre></td></tr></table></figure><p>可以看到 busybox1 的 IP 地址为<code>172.17.0.2</code>。<br>然后我们新打开一个命令行窗口，再启动一个 busybox2 容器，通过 container 网络模式连接到 busybox1 的网络，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --net=container:busybox1 --name=busybox2 busybox sh</span><br></code></pre></td></tr></table></figure><p>在 busybox2 容器内同样使用 ifconfig 命令查看一下容器内的网络配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue<br>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以看到 busybox2 容器的网络 IP 也为 172.17.0.2，与 busybox1 的网络一致。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>Libnetwork 网络模式</th><th>用途</th><th>场景</th></tr></thead><tbody><tr><td>null</td><td>不提供任何网络</td><td>处于安全考量，需要一个独立的网络环境只用于纯计算任务</td></tr><tr><td>bridge</td><td>容器与容器间互通</td><td>容器需要实现网络通信</td></tr><tr><td>host</td><td>容器与主机网络共享</td><td>容器需要使用主机网络或使用主机网络提供服务</td></tr><tr><td>container</td><td>将两个容器放到同一网络空间，容器间通风 localhost 访问</td><td>两个容器间通过 localhost 通信</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、 Docker StorageDriver</title>
    <link href="/2022/07/04/docker-storage-driver/"/>
    <url>/2022/07/04/docker-storage-driver/</url>
    
    <content type="html"><![CDATA[<h1 id="1-联合文件系统"><a href="#1-联合文件系统" class="headerlink" title="1.联合文件系统"></a>1.联合文件系统</h1><p>联合文件系统（Union File System，Unionfs）是一种分层的轻量级文件系统，<strong>它可以把多个目录内容联合挂载到同一目录下，从而形成一个单一的文件系统，这种特性可以让使用者像是使用一个目录一样使用联合文件系统</strong>。<br>例如：现在有两个目录 A 和 B，它们分别有两个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree .</span><br>├── A<br>│ ├── a<br>│ └── x<br>└── B<br>  ├── b<br>  └── x<br></code></pre></td></tr></table></figure><p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> C</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t aufs -o <span class="hljs-built_in">dirs</span>=./A:./B none ./C</span><br></code></pre></td></tr></table></figure><p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起，此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree ./C</span><br>./C<br>├── a<br>├── b<br>└── x<br></code></pre></td></tr></table></figure><p>那联合文件系统对于 Docker 是一个怎样的存在呢？它可以说是 Docker 镜像和容器的基础，因为它可以<strong>使 Docker 可以把镜像做成分层的结构，从而使得镜像的每一层可以被共享</strong>。例如两个业务镜像都是基于 CentOS 7 镜像构建的，那么这两个业务镜像在物理机上只需要存储一次 CentOS 7 这个基础镜像即可，从而节省大量存储空间。</p><p>联合文件系统只是一个概念，真正实现联合文件系统才是关键，那如何实现呢？其实实现方案有很多，Docker 中最常用的联合文件系统有三种：AUFS、Devicemapper 和 OverlayFS。</p><p>在开始介绍三种文件系统之前需要明白两个原理，分别是：<code>写时复制（CoW）</code>和<code>用时分配（allocate-on-demand）</code></p><h2 id="1-1-写时复制（CoW）"><a href="#1-1-写时复制（CoW）" class="headerlink" title="1.1 写时复制（CoW）"></a>1.1 写时复制（CoW）</h2><p>所有驱动都用到的技术——写时复制（CoW）。<code>CoW就是copy-on-write</code>，表示：<strong>只在需要写时才去复制，这个是针对已有文件的修改场景</strong>。</p><p>比如：基于一个 image 启动多个 Container，如果为每个 Container 都去分配一个 image 一样的文件系统，那么将会占用大量的磁盘空间。而 CoW 技术可以让所有的容器共享 image 的文件系统，所有数据都从 image 中读取，只有当要对文件进行写操作时，才从 image 里把要写的文件复制到自己的文件系统进行修改。</p><p>所以无论有多少个容器共享同一个 image，所做的写操作都是对从 image 中复制到自己的文件系统中的复本上进行，并不会修改 image 的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。<strong>使用 CoW 可以有效的提高磁盘的利用率</strong>。</p><h2 id="1-2-用时分配（allocate-on-demand）"><a href="#1-2-用时分配（allocate-on-demand）" class="headerlink" title="1.2 用时分配（allocate-on-demand）"></a>1.2 用时分配（allocate-on-demand）</h2><p>而用时分配是用在：<strong>原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率</strong>。比如启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p><h1 id="2-AUFS"><a href="#2-AUFS" class="headerlink" title="2.AUFS"></a>2.AUFS</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>AUFS（AnotherUnionFS）是一种 Union FS，是文件级的存储驱动。<strong>AUFS 能透明覆盖一或多个现有文件系统的层状文件系统，把多层合并成文件系统的单层表示</strong>，<strong>简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统</strong>。</p><p>这种文件系统可以一层一层地叠加修改文件。<strong>无论底下有多少层都是只读的，只有最上层的文件系统是可写的</strong>。当需要修改一个文件时，AUFS 创建该文件的一个副本，使用 CoW 将文件从只读层复制到可写层进行修改，结果也保存在可写层。在 Docker 中，底下的只读层就是 image，可写层就是 Container。结构如下图所示：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FoIUkTpTy6jdEDUzOT3mPzZg00i2.png"></p><h2 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h2><p>AUFS 目前并未被合并到 Linux 内核主线，因此只有 Ubuntu 和 Debian 等少数操作系统支持 AUFS。你可以使用以下命令查看你的系统是否支持 AUFS：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行以上命令后，如果输出结果包含 aufs ，则代表当前操作系统支持 AUFS</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">grep aufs /proc/filesystems</span><br>nodev aufs<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>AUFS 推荐在 Ubuntu 或 Debian 操作系统下使用，如果你想要在 CentOS 等操作系统下使用 AUFS，需要单独安装 AUFS 模块（生产环境不推荐在 CentOS 下使用 AUFS，如果你想在 CentOS 下安装 AUFS 用于研究和测试，可以参考这个<a href="https://github.com/bnied/kernel-ml-aufs">链接</a>）</p>          </div><p><strong>1）centos 下安装 aufs</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入repo目录</span><br>cd /etc/yum.repos.d<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载文件</span><br>wget https://yum.spaceduck.org/kernel-ml-aufs/kernel-ml-aufs.repo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>yum install kernel-ml-aufs<br><br>vi /etc/default/grub<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改参数, 表示启动时选择第一个内核</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################################</span></span><br>GRUB_DEFAULT=0<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################################</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新生成grub.cfg</span><br>grub2-mkconfig -o /boot/grub2/grub.cfg<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启计算机</span><br>reboot<br></code></pre></td></tr></table></figure><p><strong>2）示例：</strong><br>本次演示示例将通过创建三个文件（如下）通过 aufs 挂载到&#x2F;mnt 目录下，并修改相应文件内容观察对应挂载目录&#x2F;mnt 的变化情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree /tmp/aufs/</span><br>/tmp/aufs/<br>├── container1         ## 容器层<br>│   └── container.txt<br>├── image1 ## 镜像层<br>│   └── image1.txt<br>├── image2 ## 镜像层<br>│   └── image2.txt<br>└── mnt ## 联合目录<br></code></pre></td></tr></table></figure><p>操作示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /tmp/aufs/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> container1 image1 image2 mnt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> Hello, Container layer! &gt; container1/container1.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> Hello, Image layer1! &gt; image1/image1.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> Hello, Image layer2! &gt; image2/image2.txt</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令为通过aufs创建一个联合文件系统，container1在最上边</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t aufs -o <span class="hljs-built_in">dirs</span>=./container1:./image2:./image1 none ./mnt</span><br></code></pre></td></tr></table></figure><p>执行完上述命令后，mnt 变成了 AUFS 的联合挂载目录，我们可以使用 mount 命令查看一下已经创建的 AUFS 文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t aufs</span><br>none on /tmp/mnt type aufs (rw,relatime,si=4108481ec17420a7)<br></code></pre></td></tr></table></figure><p>我们每创建一个 AUFS 文件系统，AUFS 都会为我们生成一个 ID，这个 ID 在 &#x2F;sys&#x2F;fs&#x2F;aufs&#x2F; 会创建对应的目录，在这个 ID 的目录下可以查看文件挂载的权限（需要逐一查看每个文件值）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/aufs/si_4108481ec17420a7</span><br>/tmp/aufs/container1=rw<br>/tmp/aufs/image2=ro<br>/tmp/aufs/image1=ro<br></code></pre></td></tr></table></figure><p>可以看到<code>container1</code>目录的权限为<code>rw（代表可读写)``image1</code>和<code>image2</code>的权限为<code>ro（代表只读）</code>。<br>为了验证 mnt 目录下可以看到 container1、image1 和 image2 目录下的所有内容，我们使用 ls 命令查看一下 mnt 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> mnt/</span><br>container1.txt  image1.txt  image2.txt<br></code></pre></td></tr></table></figure><p><strong>3）验证 AUFS 的写时复制</strong><br><strong>AUFS 的写时复制是指在容器中，只有需要修改某个文件时，才会把文件从镜像层复制到容器层</strong>，下面我们通过修改联合挂载目录 mnt 下的内容来验证下这个过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意：是修改容器目录下的image1.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> Hello, Image layer1 changed! &gt; mnt/image1.txt</span><br></code></pre></td></tr></table></figure><p>然后我们查看下 image1&#x2F;image1.txt 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> image1/image1.txt</span><br>Hello, Image layer1!<br></code></pre></td></tr></table></figure><p>发现 “镜像层” 的 image1.txt 文件并未被修改。然后我们查看一下 “容器层” 对应的 image1.txt 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> container1/</span><br>container1.txt  image1.txt<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> container1/image1.txt</span><br>Hello, Image layer1 changed!<br></code></pre></td></tr></table></figure><p><strong>发现 AUFS 在 “容器层” 自动创建了 image1.txt 文件，并且内容为我们刚才写入的内容。</strong></p><h2 id="2-3-原理"><a href="#2-3-原理" class="headerlink" title="2.3 原理"></a>2.3 原理</h2><p>AUFS 是联合文件系统，意味着它在主机上使用多层目录存储，每一个目录在 AUFS 中都叫作分支，而在 Docker 中则称之为层（layer），但最终呈现给用户的则是一个普通单层的文件系统，我们把多层以单一层的方式呈现出来的过程叫作联合挂载。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/Fqi04pwC0nLgmUHuGu4pfHyvm8jN.png"><br>如图 1 所示，每一个镜像层和容器层都是<code>/var/lib/docker</code>下的一个子目录，镜像层和容器层都<code>aufs/diff</code>目录下，每一层的目录名称是镜像或容器的 ID 值，联合挂载点在<code>aufs/mnt</code>目录下，mnt 目录是真正的容器工作目录。</p><p><strong>aufs 读写原理</strong><br>AUFS 的工作过程中对文件的操作分为读取文件和修改文件。下面我们分别来看下 AUFS 对于不同的文件操作是如何工作的。<br><strong>1.）读取文件</strong><br>当我们在容器中读取文件时，可能会有以下场景：</p><ul><li>文件在容器层中存在时：直接从容器层读取。</li><li>当文件在容器层中不存在时：从镜像层查找该文件，然后读取文件内容。</li><li>文件既存在于镜像层，又存在于容器层：将会从容器层读取该文件。</li></ul><p><strong>2）修改文件或目录</strong><br>AUFS 对文件的修改采用的是<code>写时复制</code>的工作机制，这种工作机制可以最大程度节省存储空间。具体的文件操作机制如下：</p><ul><li>第一次修改文件：当我们第一次在容器中修改某个文件时，AUFS 会触发写时复制操作，AUFS 首先从镜像层复制文件到容器层，然后再执行对应的修改操作。</li></ul><div class="note note-warning">            <p>AUFS 写时复制的操作将会复制整个文件，如果文件过大，将会大大降低文件系统的性能，因此当我们有大量文件需要被修改时，AUFS 可能会出现明显的延迟。好在，写时复制操作只在第一次修改文件时触发，对日常使用没有太大影响。</p>          </div><ul><li>删除文件或目录：当文件或目录被删除时，AUFS 并不会真正从镜像中删除它，因为镜像层是只读的，AUFS 会创建一个特殊的文件或文件夹，这种特殊的文件或文件夹会阻止容器的访问（通过一种叫 whiteout “白障”的机制）。</li></ul><div class="note note-success">            <p>为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。<br>比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了。<br>这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。我喜欢把 whiteout 形象地翻译为：“白障”。</p>          </div><h1 id="3-Devicemapper"><a href="#3-Devicemapper" class="headerlink" title="3.Devicemapper"></a>3.Devicemapper</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Device mapper 是 Linux 内核 2.6.9 后支持的，<strong>提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略</strong>。前面讲的 AUFS 和 OverlayFS 都是<code>文件级存储</code>，而 Device mapper 是<code>块级存储</code>，所有的操作都是直接对块进行操作，而不是文件。</p><p>Device mapper 驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。</p><p><strong>当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个叫用时分配。当要修改已有文件时，再使用 CoW 为容器快照分配块空间，将要修改的数据复制到在容器快照中新的块里再进行修改。</strong>Device mapper 驱动默认会创建一个 100G 的文件包含镜像和容器。每一个容器被限制在 10G 大小的卷内，可以自己配置调整。结构如下图所示：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FpL9UhZigZgcSUVbrn9ue4dCDFlf.png"></p><div class="note note-success">            <p>Devicemapper 提供了一种将物理块设备映射到虚拟块设备的机制，目前 Linux 下比较流行的 LVM（Logical Volume Manager 是 Linux 下对磁盘分区进行管理的一种机制）和软件磁盘阵列（将多个较小的磁盘整合成为一个较大的磁盘设备用于扩大磁盘存储和提供数据可用性）都是基于 Devicemapper 机制实现的。</p>          </div><h2 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h2><p>Docker 的 Devicemapper 模式有两种：第一种是 loop-lvm 模式，该模式主要用来开发和测试使用；第二种是 direct-lvm 模式，该模式推荐在生产环境中使用。<br><strong>1）配置 loop-lvm 模式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> sudo systemctl stop docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vi  /etc/docker/daemon.json</span><br>&#123;<br>   &quot;storage-driver&quot;:&quot;devicemapper&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info</span><br>...<br>Storage Driver: devicemapper<br>...<br></code></pre></td></tr></table></figure><p>2）配置 direct-lvm 模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vi  /etc/docker/daemon.json</span><br>&#123;<br>   &quot;storage-driver&quot;:&quot;devicemapper&quot;,<br>   &quot;storage-opts&quot;:[<br>      &quot;dm.directlvm_device=/dev/xdf&quot;,<br>      &quot;dm.thinp_percent=95&quot;,<br>      &quot;dm.thinp_metapercent=1&quot;,<br>      &quot;dm.thinp_autoextend_threshold=80&quot;,<br>      &quot;dm.thinp_autoextend_percent=20&quot;,<br>      &quot;dm.directlvm_device_force=false&quot;<br>   ]<br>&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info</span><br>......<br>Storage Driver: devicemapper<br>Pool Name: docker-thinpool<br>......<br></code></pre></td></tr></table></figure><p>其中 directlvm_device 指定需要用作 Docker 存储的磁盘路径，Docker 会动态为我们创建对应的存储池。例如这里我想把 &#x2F;dev&#x2F;xdf 设备作为我的 Docker 存储盘，directlvm_device 则配置为 &#x2F;dev&#x2F;xdf。</p><h2 id="3-3-原理"><a href="#3-3-原理" class="headerlink" title="3.3 原理"></a>3.3 原理</h2><p><strong>1）Devicemapper 关键技术</strong><br>Devicemapper 将主要的工作部分分为用户空间和内核空间：</p><ul><li><strong>用户空间</strong>：负责配置具体的设备映射策略与相关的内核空间控制逻辑，例如逻辑设备 dm-a 如何与物</li></ul><p>理设备 sda 相关联，怎么建立逻辑设备和物理设备的映射关系等。</p><ul><li><strong>内核空间</strong>：则负责用户空间配置的关联关系实现，例如当 IO 请求到达虚拟设备 dm-a 时，内核空间</li></ul><p>负责接管 IO 请求，然后处理和过滤这些 IO 请求并转发到具体的物理设备 sda 上。</p><p><strong>2）Devicemapper 三个核心概念</strong><br>Devicemapper 的工作机制主要围绕三个核心概念：</p><ul><li><strong>映射设备（mapped device）</strong>：即对外提供的逻辑设备，它是由 Devicemapper 模拟的一个虚拟、设备，并不是真正存在于宿主机上的物理设备。</li><li><strong>目标设备（target device）</strong>：目标设备是映射设备对应的物理设备或者物理设备的某一个逻辑分段，是真正存在于物理机上的设备。</li><li><strong>映射表（map table）</strong>：映射表记录了映射设备到目标设备的映射关系，它记录了映射设备在目标设备的起始地址、范围和目标设备的类型等变量。</li></ul><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FmiYXLqsKbW3-qTWDfsv8nm3u3fm.png"><br>Devicemapper 三个核心概念之间的关系如图，映射设备通过映射表关联到具体的物理目标设备。事实上，映射设备不仅可以通过映射表关联到物理目标设备，也可以关联到虚拟目标设备，然后虚拟目标设备再通过映射表关联到物理目标设备。</p><p>Devicemapper 在内核中通过很多模块化的映射驱动（target driver）插件实现了对真正 IO 请求的拦截、过滤和转发工作，比如 Raid、软件加密、瘦供给（Thin Provisioning）等。</p><p><strong>3）Devicemapper 数据存储机制</strong><br>当 Docker 使用 Devicemapper 作为文件存储驱动时，Docker 将镜像和容器的文件存储在瘦供给池（thinpool）中，并将这些内容挂载在<code>/var/lib/docker/devicemapper/</code>目录下。<br>这些目录储存 Docker 的容器和镜像相关数据，目录的数据内容和功能说明如下：</p><ul><li><strong>devicemapper 目录（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;devicemapper&#x2F;）</strong>：存储镜像和容器实际内容，该目录由一个或多个块设备构成。</li><li><strong>metadata 目录（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;metadata&#x2F;）</strong>： 包含 Devicemapper 本身配置的元数据信息, 以 json 的形式配置，这些元数据记录了镜像层和容器层之间的关联信息。</li><li><strong>mnt 目录（ &#x2F;var&#x2F;lib&#x2F;docker&#x2F;devicemapper&#x2F;mnt&#x2F;）</strong>：是容器的联合挂载点目录，未生成容器时，该目录为空，而容器存在时，该目录下的内容跟容器中一致。</li></ul><p><strong>4）Devicemapper 镜像分层与共享机制</strong><br>Devicemapper 使用专用的块设备实现镜像的存储，并且像 AUFS 一样使用了写时复制的技术来保障最大程度节省存储空间，所以<strong>Devicemapper 的镜像分层也是依赖快照来是实现的</strong>。<br><strong>Devicemapper 的每一镜像层都是其下一层的快照，最底层的镜像层是我们的瘦供给池</strong>，通过这种方式<br>实现镜像分层有以下优点。</p><ul><li>相同的镜像层，仅在磁盘上存储一次。例如，我有 10 个运行中的 busybox 容器，底层都使用了 busybox 镜像，那么 busybox 镜像只需要在磁盘上存储一次即可。</li><li>快照是写时复制策略的实现，也就是说，当我们需要对文件进行修改时，文件才会被复制到读写层。</li><li>相比对文件系统加锁的机制，Devicemapper 工作在块级别，因此可以实现同时修改和读写层中的多个块设备，比文件系统效率更高。</li></ul><p>当我们需要读取数据时，如果数据存在底层快照中，则向底层快照查询数据并读取。当我们需要写数据时，则向瘦供给池动态申请存储空间生成读写层，然后把数据复制到读写层进行修改。Devicemapper 默认每次申请的大小是 64K 或者 64K 的倍数，因此每次新生成的读写层的大小都是 64K 或者 64K 的倍数。<br>以下是一个运行中的 Ubuntu 容器示意图：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FuRUQ_bCBFXhU-bsmkGeqlzo5jNs.png"><br>这个 Ubuntu 镜像一共有四层，每一层镜像都是下一层的快照，镜像的最底层是基础设备的快照。当容器运行时，容器是基于镜像的快照。综上，Devicemapper 实现镜像分层的根本原理就是快照。</p><h1 id="4-OverlayFS"><a href="#4-OverlayFS" class="headerlink" title="4.OverlayFS"></a>4.OverlayFS</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>Overlay 是 Linux 内核 3.18 后支持的，也是一种 Union FS，和 AUFS 的多层不同的是 Overlay 只有两层：<strong>一个 upper 文件系统和一个 lower 文件系统，分别代表 Docker 的镜像层和容器层</strong>。<strong>当需要修改一个文件时，使用 CoW 将文件从只读的 lower 复制到可写的 upper 进行修改，结果也保存在 upper 层</strong>。在 Docker 中，底下的只读层就是 image，可写层就是 Container。结构如下图所示：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/Fr1UF5wAhnRk3gRgR1-qQAtX_pSq.png"></p><div class="note note-success">            <p>OverlayFS 的发展分为两个阶段。2014 年，OverlayFS 第一个版本被合并到 Linux 内核 3.18 版本中，此时的 OverlayFS 在 Docker 中被称为 overlay 文件驱动。由于第一版的 overlay 文件系统存在很多弊端（例如运行一段时间后 Docker 会报 “too many links problem” 的错误）， Linux 内核在 4.0 版本对 overlay 做了很多必要的改进，此时的 OverlayFS 被称之为 overlay2 。</p><p>因此，在 Docker 中 OverlayFS 文件驱动被分为了两种，一种是早期的 overlay ，不推荐在生产环境中使用，另一种是更新和更稳定的 overlay2 ，推荐在生产环境中使用。下面的内容我们主要围绕 overlay2 展开。</p>          </div><h2 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h2><p><strong>1）使用 overlay2 的先决条件</strong></p><ul><li>要想使用 overlay2 ，Docker 版本必须高于 17.06.02。</li><li>如果你的操作系统是 RHEL 或 CentOS，Linux 内核版本必须使用 3.10.0-514 或者更高版本，其他 Linux 发行版的内核版本必须高于 4.0（例如 Ubuntu 或 Debian），你可以使用 uname -a 查看当前系统的内核版本。</li><li>overlay2 最好搭配 xfs 文件系统使用，并且使用 xfs 作为底层文件系统时，d_type 必须开启。</li></ul><p>可以使用以下命令验证 d_type 是否开启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">xfs_info /var/lib/docker | grep ftype</span><br>naming   =version 2              bsize=4096   ascii-ci=0 ftype=1<br></code></pre></td></tr></table></figure><p>当输出结果中有 ftype&#x3D;1 时，表示 d_type 已经开启。如果你的输出结果为 ftype&#x3D;0，则需要重新格式化磁盘目录，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mkfs.xfs -f -n ftype=1 /path/to/disk</span><br></code></pre></td></tr></table></figure><p><strong>2）初始化 &#x2F;var&#x2F;lib&#x2F;docker</strong><br>在生产环境中，推荐挂载<code>/var/lib/docker</code>目录到单独的磁盘或者磁盘分区，这样可以避免该目录写满影响主机的文件写入，并且把挂载信息写入到<code>/etc/fstab</code>，防止机器重启后挂载信息丢失。<br><strong>2.1）使用 lsblk（Linux 查看磁盘和块设备信息命令）命令查看本机磁盘信息：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">lsblk</span><br>NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT<br>vda 253:0 0 500G 0 disk<br>  -vda1 253:1 0 500G 0 part<br>vdb 253:16 0 500G 0 disk<br>  -vdb1 253:17 0 8G 0 part<br></code></pre></td></tr></table></figure><p>可以看到，我的机器有两块磁盘，一块是 vda，一块是 vdb。其中 vda 已经被用来挂载系统根目录，这里我想把<code>/var/lib/docker</code>挂载到<code>vdb1</code>分区上。<br><strong>2.2）使用 mkfs 命令格式化磁盘 vdb1：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mkfs.xfs -f -n ftype=1 /dev/vdb1</span><br></code></pre></td></tr></table></figure><p><strong>2.3） 将挂载信息写入到 &#x2F;etc&#x2F;fstab，保证机器重启挂载目录不丢失：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/dev/vdb1 /var/lib/docker xfs defaults,pquota 0 0&quot;</span> &gt;&gt; /etc/fstab</span><br></code></pre></td></tr></table></figure><p><strong>2.4）使用 mount 命令使得挂载目录生效。</strong><br><strong>2.5）检查 ftype 是否配置生效</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">xfs_info /var/lib/docker | grep ftype</span><br></code></pre></td></tr></table></figure><p><strong>3）如何在 Docker 中配置 overlay2？</strong><br>当你的系统满足上面的条件后，就可以配置你的 Docker 存储驱动为 overlay2 了，具体配置步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl stop docker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">备份 /var/lib/docker 目录：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">cp</span> -au /var/lib/docker /var/lib/docker.back</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 /etc/docker 目录下创建 daemon.json 文件，如果该文件已经存在，则修改配置为以下内容：</span><br>&#123;<br>   &quot;storage-driver&quot;:&quot;overlay2&quot;,<br>   &quot;storage-opts&quot;:[<br>      &quot;overlay2.size=20G&quot;,<br>      &quot;overlay2.override_kernel_check=true&quot;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-原理"><a href="#4-3-原理" class="headerlink" title="4.3 原理"></a>4.3 原理</h2><p>overlay2 和 AUFS 类似，它将所有目录称之为层（layer），overlay2 的目录是镜像和容器分层的基础，而把这些层统一展现到同一的目录下的过程称为联合挂载（union mount）。<br>overlay2 把目录的下一层叫作 lowerdir ，上一层叫作 upperdir ，联合挂载后的结果叫作 merged 。</p><div class="note note-success">            <p>overlay2 文件系统最多支持 128 个层数叠加，也就是说你的 Dockerfile 最多只能写 128 行，不过这在日常使用中足够了。</p>          </div><p><strong>1）镜像在 overlay2 的存储情况</strong><br>下面我们通过拉取一个 Ubuntu 操作系统的镜像来看下 overlay2 是如何存放镜像文件的。<br>首先，我们通过以下命令拉取 Ubuntu 镜像（为了方便演示先清除本地所有容器和镜像）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">  docker pull ubuntu:16.04</span><br>16.04: Pulling from library/ubuntu<br>58690f9b18fc: Pull complete<br>b51569e7c507: Pull complete<br>da8ef40b9eca: Pull complete<br>fb15d46c38dc: Pull complete<br>Digest: sha256:20858ebbc96215d6c3c574f781133ebffdc7c18d98af4f294cc4c04871a6fe61<br>Status: Downloaded newer image<br></code></pre></td></tr></table></figure><p>可以看到镜像一共被分为四层拉取，拉取完镜像后我们查看一下 overlay2 的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/</span><br>总用量 0<br>drwx--x---. 4 root root     55 7月   4 03:28 267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3<br>drwx--x---. 4 root root     72 7月   4 03:28 3391745c4b8ac939496ace17637ad1d47113008112f84b7de7d948e68ac2108d<br>drwx--x---. 3 root root     47 7月   4 03:28 64a8a15dbe008f34c273d56428a8232aa7bafe118d03797da16cbe16a40e8cbf<br>drwx--x---. 4 root root     72 7月   4 03:28 ad6f39a4f7e70a683426b637bd6b2efda900d7aae2a3e0789a3f6e662ac5cc12<br>brw-------. 1 root root 253, 0 7月   3 21:53 backingFsBlockDev<br>drwx------. 2 root root    142 7月   4 03:28 l<br></code></pre></td></tr></table></figure><p>可以看到 overlay2 目录下出现了四个镜像层目录和一个<code>l</code>目录，我们首先来查看一下<code>l</code>目录的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/l</span><br>总用量 0<br>lrwxrwxrwx. 1 root root 72 7月   4 03:28 H7EQNFLUIFWHF4VPUIJGOIQ4SP -&gt; ../267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3/diff<br>lrwxrwxrwx. 1 root root 72 7月   4 03:28 UZ6YH5OJZCSLTRHQS4E6WMX7LE -&gt; ../64a8a15dbe008f34c273d56428a8232aa7bafe118d03797da16cbe16a40e8cbf/diff<br>lrwxrwxrwx. 1 root root 72 7月   4 03:28 VBWWM5IIS26QD76P7Z5UJOZOS7 -&gt; ../ad6f39a4f7e70a683426b637bd6b2efda900d7aae2a3e0789a3f6e662ac5cc12/diff<br>lrwxrwxrwx. 1 root root 72 7月   4 03:28 WE3LOBHPMA7CXZDCMGYRWBVZJE -&gt; ../3391745c4b8ac939496ace17637ad1d47113008112f84b7de7d948e68ac2108d/diff<br></code></pre></td></tr></table></figure><p>可以看到<code>l</code>目录是一堆软连接，把一些较短的随机串软连到镜像层的<code>diff</code>文件夹下，这样做是为了避免达到<code>mount</code>命令参数的长度限制。<br>下面我们查看任意一个镜像层下的文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3</span><br>总用量 8<br>drwxr-xr-x. 3 root root 17 7月   4 03:28 diff<br>-rw-r--r--. 1 root root 26 7月   4 03:28 link<br>-rw-r--r--. 1 root root 86 7月   4 03:28 lower<br>drwx------. 2 root root  6 7月   4 03:28 work<br></code></pre></td></tr></table></figure><p><strong>镜像层的 link 文件内容为该镜像层的短 ID，diff 文件夹为该镜像层的改动内容，lower 文件为该层的所有父层镜像的短 ID。</strong></p><p>我们可以通过<code>docker image inspect</code>命令来查看某个镜像的层级关系，例如我想查看刚刚下载的 Ubuntu 像之间的层级关系，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker image inspect ubuntu:16.04</span><br>   &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/ad6f39a4f7e70a683426b637bd6b2efda900d7aae2a3e0789a3f6e662ac5cc12/diff:/var/lib/docker/overlay2/3391745c4b8ac939496ace17637ad1d47113008112f84b7de7d948e68ac2108d/diff:/var/lib/docker/overlay2/64a8a15dbe008f34c273d56428a8232aa7bafe118d03797da16cbe16a40e8cbf/diff&quot;,<br>                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3/merged&quot;,<br>                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3/diff&quot;,<br>                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3/work&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;overlay2&quot;<br>        &#125;,<br>        &quot;RootFS&quot;: &#123;<br>            &quot;Type&quot;: &quot;layers&quot;,<br>            &quot;Layers&quot;: [<br>                &quot;sha256:be96a3f634de79f523f07c7e4e0216c28af45eb5776e7a6238a2392f71e01069&quot;,<br>                &quot;sha256:df54c846128da3c71cc11b2150a3df39ec86fb170e299765daf6bb016a0705c2&quot;,<br>                &quot;sha256:47ef83afae74745639f6738a05fe5320fcfca9e6c7765fba4f25e270bc0df9dc&quot;,<br>                &quot;sha256:1251204ef8fc20da275e09f6e3ab9205421d4ff34732f2d50a1d3e86d2995edd&quot;<br>            ]<br>        &#125;,<br>        &quot;Metadata&quot;: &#123;<br>            &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>其中 MergedDir 代表当前镜像层在 overlay2 存储下的目录，LowerDir 代表当前镜像的父层关系，使用冒号分隔，冒号最后代表该镜像的最底层。</strong></p><p><strong>2）容器在 overlay2 的存储情况</strong><br>下面我们将镜像运行起来成为容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name=ubuntu -d ubuntu:16.04 <span class="hljs-built_in">sleep</span> 3600</span><br></code></pre></td></tr></table></figure><p>我们使用<code>docker inspect</code>命令来查看一下容器的工作目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect ubuntu</span><br>     &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/522e7efc68bd1e44ef18ce48cd042c3a6ba843e32d1bba29aed50f692f7dae49-init/diff:/var/lib/docker/overlay2/267a58f784244bbd37d04a4d5538dfc7830bd127c68fa6d08a67ac632b4586b3/diff:/var/lib/docker/overlay2/ad6f39a4f7e70a683426b637bd6b2efda900d7aae2a3e0789a3f6e662ac5cc12/diff:/var/lib/docker/overlay2/3391745c4b8ac939496ace17637ad1d47113008112f84b7de7d948e68ac2108d/diff:/var/lib/docker/overlay2/64a8a15dbe008f34c273d56428a8232aa7bafe118d03797da16cbe16a40e8cbf/diff&quot;,<br>                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/522e7efc68bd1e44ef18ce48cd042c3a6ba843e32d1bba29aed50f692f7dae49/merged&quot;,<br>                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/522e7efc68bd1e44ef18ce48cd042c3a6ba843e32d1bba29aed50f692f7dae49/diff&quot;,<br>                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/522e7efc68bd1e44ef18ce48cd042c3a6ba843e32d1bba29aed50f692f7dae49/work&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;overlay2&quot;<br>        &#125;,<br></code></pre></td></tr></table></figure><p><code>MergedDir</code>后面的内容即为容器层的工作目录，<code>LowerDir</code>为容器所依赖的镜像层目录。<br>然后我们查看下 overlay2 目录下的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/</span><br>drwx--x---. 4 root root     72 7月   4 03:39 522e7efc68bd1e44ef18ce48cd042c3a6ba843e32d1bba29aed50f692f7dae49-init<br>......<br></code></pre></td></tr></table></figure><p>可以看到 overlay2 目录下增加了容器层相关的目录，我们再来查看一下容器层下的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /var/lib/docker/overlay2/522e7efc68bd1e44ef18ce48cd042c3a6ba843e32d1bba29aed50f692f7dae49-init</span><br>-rw-------. 1 root root   0 7月   4 03:39 committed<br>drwxr-xr-x. 4 root root  46 7月   4 03:39 diff<br>-rw-r--r--. 1 root root  26 7月   4 03:39 link<br>-rw-r--r--. 1 root root 115 7月   4 03:39 lower<br>drwx------. 3 root root  18 7月   4 03:39 work<br></code></pre></td></tr></table></figure><p><code>link</code>和<code>lower</code>文件与镜像层的功能一致，link 文件内容为该容器层的短 ID，lower 文件为该层的所有父层镜像的短 ID 。<strong>diff 目录为容器的读写层，容器内修改的文件都会在 diff 中出现，merged 目录为分层文件联合挂载后的结果，也是容器内的工作目录</strong>。</p><p>总体来说，overlay2 是这样储存文件的：** overlay2 将镜像层和容器层都放在单独的目录，并且有唯一 ID，每一层仅存储发生变化的文件，最终使用联合挂载技术将容器层和镜像层的所有文件统一挂载到容器中，使得容器中看到完整的系统文件**。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><div class="note note-success">            <p>通常情况下， overlay2 会比 AUFS 和 Devicemapper 性能更好，而且更加稳定，因为 overlay2<br>在 inode 优化上更加高效。因此在生产环境中推荐使用 overlay2 作为 Docker 的文件驱动。</p><p>overlay2 目前已经是 Docker 官方推荐的文件系统了，也是目前安装 Docker 时默认的文件系统，因为<br>overlay2 在生产环境中不仅有着较高的性能，它的稳定性也极其突出。但是 overlay2 的使用还是有一<br>些限制条件的，例如要求 Docker 版本必须高于 17.06.02，内核版本必须高于 4.0 等。因此，在生产环<br>境中，如果你的环境满足使用 overlay2 的条件，请尽量使用 overlay2 作为 Docker 的联合文件系统。</p>          </div><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://dockone.io/article/1513">http://dockone.io/article/1513</a><br><a href="https://time.geekbang.org/column/article/17921?cid=100015201">https://time.geekbang.org/column/article/17921?cid=100015201</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、Docker Volume使用与原理</title>
    <link href="/2022/07/03/docker-volume/"/>
    <url>/2022/07/03/docker-volume/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>容器按照业务类型，总体可以分为两类：</p><ul><li>无状态的（数据不需要被持久化）</li><li>有状态的（数据需要被持久化）</li></ul><p>在实际业务总是有各种需要数据持久化的场景，比如 MySQL、Kafka 等有状态的业务。因此为了解决有状态业务的需求，Docker 提出了卷（Volume）的概念。</p><p>什么是卷？<strong>卷的本质是文件或者目录，它可以绕过默认的联合文件系统，直接以文件或目录的形式存在于宿主机上。</strong></p><p>卷的概念不仅解决了数据持久化的问题，还解决了容器间共享数据的问题。<strong>使用卷可以将容器内的目录或文件持久化，当容器重启后保证数据不丢失</strong>。例如我们可以使用卷将 MySQL 的目录持久化，实现容器重启数据库数据不丢失。</p><p>Docker 提供了卷（Volume）的功能，使用 docker volume 命令可以实现对卷的创建、查看和删除等操作。下面我们来详细了解一下这些命令。</p><h1 id="2-Docker-Volume-操作"><a href="#2-Docker-Volume-操作" class="headerlink" title="2. Docker Volume 操作"></a>2. Docker Volume 操作</h1><h2 id="2-1-Volume-创建和使用"><a href="#2-1-Volume-创建和使用" class="headerlink" title="2.1 Volume 创建和使用"></a>2.1 Volume 创建和使用</h2><p><strong>创建容器卷：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create [OPTIONS] [VOLUME]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--driver , -d:设置卷driver名称 (默认值：local，该卷只能本机的容器访问，若要实现远程访问需要使用网络存储)<br>--label:卷标签<br>--name:卷名称<br>--opt , -o :用于设置driver的详细参数<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建卷</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create hello</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建带参数的卷，使用网络driver</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create --driver <span class="hljs-built_in">local</span> \</span><br><span class="language-bash">    --opt <span class="hljs-built_in">type</span>=nfs \</span><br><span class="language-bash">    --opt o=addr=192.168.1.1,rw \</span><br><span class="language-bash">    --opt device=:/path/to/dir \</span><br><span class="language-bash">    foo</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卷使用有几种方式可以通过docker run -v进行挂载，也可以通过--mount进行挂载</span><br></code></pre></td></tr></table></figure><h2 id="2-2-Volume-使用"><a href="#2-2-Volume-使用" class="headerlink" title="2.2 Volume 使用"></a>2.2 Volume 使用</h2><p>Volume 的与容器挂载的方式有如下几种：<br><strong>1、docker -v 挂载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v, --volume=[host-src:]container-dest[:&lt;options&gt;]: 将宿主机src目录挂载到容器的dest.<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">情况一：在宿主机上创建一个临时目录/var/lib/docker/volumes/[VOLUME_ID]/_data，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后把它挂载到容器的/test目录上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /test</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">情况二：Docker 就直接把宿主机的/home目录挂载到容器的/test目录上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /home:/test</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>第一种情况：由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录<code>/var/lib/docker/volumes/[VOLUME_ID]/_data</code>，然后把它挂载到容器的 &#x2F;test 目录上。</p><p>第二种情况：Docker 就直接把宿主机的 &#x2F;home 目录挂载到容器的 &#x2F;test 目录上。</p>          </div><p><strong>2、自动创建挂载</strong><br>当使用<code>docker -v</code>的方式指定容器持久化路径<code>src</code>参数为空时，Docker 会自动为我们创建卷，并且绑定到容器中，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name=nginx-volume -v /usr/share/nginx/html nginx</span><br></code></pre></td></tr></table></figure><p>使用以上命令，我们启动了一个 nginx 容器， -v 参数使得 Docker 自动生成一个卷并且绑定到容器的<br>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 目录中。我们可以使用<code>docker volume ls</code>命令来查看下主机上的卷。</p><p><strong>3、使用创建好的 volume 挂载</strong><br>使用<code>docker volume create</code>命令创建一个数据卷，在使用<code>docker -v</code> 进行挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create hello</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将容器卷hello挂载到nginx容器的/usr/share/nginx/html目录下</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name=nginx -v hello:/usr/share/nginx/html nginx</span><br></code></pre></td></tr></table></figure><p><strong>4、使用 mount 进行挂载</strong><br>使用 docker volume 创建的卷在容器启动时，添加 –mount 参数指定卷的名称即可使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name=nginx --mount <span class="hljs-built_in">source</span>=myvolume,target=/usr/share/nginx/html nginx</span><br></code></pre></td></tr></table></figure><p><strong>volume 共享使用示例：</strong><br>为了演示 Volume 的共享示例，我们可以创建两个容器，然后挂载到一个 volume 上，通过修改一个 volume 数据查看另外一个数据卷数据变更情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建volume</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create datas</span><br>datas<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建两个用于测试的volume，挂载自同一个容器卷：datas</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name=nginx1 -v datas:/usr/share/nginx/html nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name=nginx2 -v datas:/usr/share/nginx/html nginx</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建成功进入容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES<br>fc840491c92c   nginx     &quot;/docker-entrypoint.…&quot;   3 seconds ago    Up 2 seconds    80/tcp    nginx2<br>5dfe59611f13   nginx     &quot;/docker-entrypoint.…&quot;   9 seconds ago    Up 8 seconds    80/tcp    nginx1<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it fc840491c92c /bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入刚刚进行挂载的目标目录，复制一个同样的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /usr/share/nginx/html</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>50x.html  index.html<br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">cp</span> -r index.html index.html.bak</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入另外一个容器查看文件变更情况</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 5dfe59611f13 /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到文件变更信息已经同步</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /usr/share/nginx/html</span><br>50x.html  index.html  index.html.bak<br></code></pre></td></tr></table></figure><h2 id="2-2-Volume-查看"><a href="#2-2-Volume-查看" class="headerlink" title="2.2 Volume 查看"></a>2.2 Volume 查看</h2><p>Docker Volume 提供了<code>docker volume ls</code>和<code>docker volume inspect </code>两种查看 volume 的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看容器卷列表</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">ls</span> [OPTIONS]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看某个容器详情</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume inspect [OPTIONS] VOLUME [VOLUME...]</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">ls</span></span><br>DRIVER    VOLUME NAME<br>local     datas<br>local     hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume inspect datas</span><br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2022-07-02T10:52:53-04:00&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: &#123;&#125;,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/datas/_data&quot;,<br>        &quot;Name&quot;: &quot;datas&quot;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="2-3-Volume-删除"><a href="#2-3-Volume-删除" class="headerlink" title="2.3 Volume 删除"></a>2.3 Volume 删除</h2><p>Docker Volume 提供了<code>docker volume rm</code> 和 <code>docker volume prune</code>指令用于删除容器卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">用于删除未使用的卷</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume prune [OPTIONS]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">用于删除一个或多个指定卷</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">rm</span> [OPTIONS] VOLUME [VOLUME...]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除名为hello的容器卷</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume <span class="hljs-built_in">rm</span> hello</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有未使用的卷</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create <span class="hljs-built_in">test</span></span><br>test<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume prune</span><br>WARNING! This will remove all local volumes not used by at least one container.<br>Are you sure you want to continue? [y/N] y<br>Deleted Volumes:<br>test<br><br>Total reclaimed space: 0B<br></code></pre></td></tr></table></figure><h1 id="3-容器间数据共享"><a href="#3-容器间数据共享" class="headerlink" title="3. 容器间数据共享"></a>3. 容器间数据共享</h1><p>实现容器间数据共享可以通过：生产者–消费者 模式完成，例如：新建一个存储卷，将两个新启动的容器挂载到同一个容器卷上边，然后通过生产者向容器卷写入数据，观察消费者数据变化情况。<br><strong>步骤一：创建容器卷</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker volume create log-vol</span><br></code></pre></td></tr></table></figure><p><strong>步骤二：挂载生产者-消费者容器卷</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --mount <span class="hljs-built_in">source</span>=log-vol,target=/tmp/log --name=log-producer -it busybox</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --mount <span class="hljs-built_in">source</span>=log-vol,target=/tmp/log --name=log-consumer -it busybox</span><br></code></pre></td></tr></table></figure><p><strong>步骤三：往生产者挂载目录写入数据观察消费者情况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">往log-producer容器写入数据</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, My log.&quot;</span> &gt;&gt;/tmp/log/mylog.log</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在log-consumer查看上面写入的数据</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /tmp/log/mylog.log</span><br>Hello, My log.<br></code></pre></td></tr></table></figure><h1 id="4-主机与容器间数据共享"><a href="#4-主机与容器间数据共享" class="headerlink" title="4. 主机与容器间数据共享"></a>4. 主机与容器间数据共享</h1><p>Docker 卷的目录默认在 &#x2F;var&#x2F;lib&#x2F;docker 下，当我们想把主机的其他目录映射到容器内时，就需要用到主机与容器之间数据共享的方式了，例如我想把 MySQL 容器中的 &#x2F;var&#x2F;lib&#x2F;mysql 目录映射到主机的&#x2F;var&#x2F;lib&#x2F;mysql 目录中，我们就可以使用主机与容器之间数据共享的方式来实现。</p><p>要实现容器与宿主机间文件共享非常简单，只需要将<code>docker -v</code>的<code>src参数</code>设置为宿主机的目录即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-v, --volume=[host-src:]container-dest[:&lt;options&gt;]: 将宿主机src目录挂载到容器的dest.<br></code></pre></td></tr></table></figure><p>例如：将主机的<code>/data</code>目录挂载到容器中的<code>/usr/local/data</code>中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -v /data:/usr/local/data -it busybox</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器中写入数据到<span class="hljs-built_in">log</span>文件,并退出容器查看宿主机的数据写入情况</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, My log.&quot;</span> &gt;&gt;mylog.log</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在宿主机查看日志变化情况</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/mylog.log</span><br>Hello, My log.<br></code></pre></td></tr></table></figure><h1 id="5-Docker-卷实现原理"><a href="#5-Docker-卷实现原理" class="headerlink" title="5. Docker 卷实现原理"></a>5. Docker 卷实现原理</h1><p>在了解 Docker 卷的原理之前，我们先来回顾一下镜像和容器的文件系统原理。</p><div class="note note-success">            <p>镜像和容器的文件系统原理： 镜像是由多层文件系统组成的，当我们想要启动一个容器时，Docker 会在镜像上层创建一个可读写层，容器中的文件都工作在这个读写层中，当容器删除时，与容器相关的工作文件将全部丢失。</p>          </div><p>Docker 容器的文件系统不是一个真正的文件系统，而是通过联合文件系统实现的一个伪文件系统，而<strong>Docker 卷则是直接利用主机的某个文件或者目录，它可以绕过联合文件系统，直接挂载主机上的文件或目录到容器中</strong>，这就是它的工作原理。</p><p>在我们创建 Docker 卷时，Docker 会把卷的数据全部放在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes 目录下，并且在每个对应的卷的目录下创建一个 _data 目录，然后把 _data 目录绑定到容器中。因此我们在容器中挂载卷的目录下操作文件，实际上是在操作主机上的 _data 目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开该目录可以看到刚刚创建的volume文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/docker/volumes</span><br><br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">https://docs.docker.com/engine/reference/commandline/volume_create&#x2F;</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DockerVolume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、Docker核心技术原理</title>
    <link href="/2022/07/01/docker-principle/"/>
    <url>/2022/07/01/docker-principle/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/Fqc3RrxqUPLpGam-_evp2WRmlaQe.png"><br>Docker 容器是通过 Linux 内核的 Namespace 技术实现了文件系统、进程、设备以及网络的隔离，然后再通过 Cgroups 对 CPU、 内存等资源进行限制，最终实现了容器之间相互不受影响。那么接下来就对这几种核心技术进行介绍。</p><h1 id="2-Namespace"><a href="#2-Namespace" class="headerlink" title="2. Namespace"></a>2. Namespace</h1><p><strong>什么是 Namespace？</strong><br>Namespace 是 Linux 内核的一个特性，该特性可以实现在同一主机系统中，对<code>进程 ID</code>、<code>主机名</code>、<code>用户ID</code>、<code>文件名</code>、<code>网络</code>和<code>进程间通信</code>等资源的隔离。Docker 利用 Linux 内核的 Namespace 特性，实现了每个容器的资源相互隔离，从而保证容器内部只能访问到自己 Namespace 的资源。</p><p>最新的 Linux 5.6 内核中提供了 8 种类型的 Namespace：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/Fk0YbpFnQvLYohkXAQSplx5BNpZw.png"></p><div class="note note-warning">            <p>虽然 Linux 内核提供了 8 种 Namespace，但是最新版本的 Docker 只使用了其中的前 6 种，分别为：<strong>Mount Namespace</strong>、<strong>PID Namespace</strong>、<strong>Net Namespace</strong>、<strong>IPC Namespace</strong>、<strong>UTS Namespace</strong>、<br><strong>User Namespace</strong>。</p>          </div><h2 id="2-1-Mount-Namespace"><a href="#2-1-Mount-Namespace" class="headerlink" title="2.1 Mount Namespace"></a>2.1 <strong>Mount Namespace</strong></h2><p><strong>Mount Namespace</strong> 是 Linux 内核实现的第一个 Namespace，从内核的 2.4.19 版本开始加入。<strong>它可以用来隔离不同的进程或进程组看到的挂载点</strong>。通俗地说，就是可以实现在不同的进程中看到不同的挂载目录。使用 Mount Namespace 可以实现容器内只能看到自己的挂载信息，在容器内的挂载操作不会影响主机的挂载目录。</p><p><strong>示例：</strong><br>接下来我们以<strong>unshare</strong>（unshare 是 util-linux 工具包中的一个工具，CentOS 7 系统默认已经集成了该工具）实现创建并访问不同的 Mount Namespace。<br><strong>步骤一：使用 unshare 创建一个 bash 进程并新建一个 Mount Namespace</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">unshare --mount --fork /bin/bash</span><br></code></pre></td></tr></table></figure><p>这时我们已经在主机上创建了一个新的 Mount Namespace，<strong>并且当前命令行窗口加入了新创建的 Mount Namespace</strong>。</p><p><strong>步骤二：验证在独立的 Mount Namespace 内创建挂载目录是不影响主机的挂载目录的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先在 /tmp 目录下创建一个目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /tmp/tmpfs</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建好目录后使用 mount 命令挂载一个 tmpfs 类型的目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t tmpfs -o size=20m tmpfs /tmp/tmpfs</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后使用 <span class="hljs-built_in">df</span> 命令查看一下已经挂载的目录信息：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">df</span> -h</span><br>文件系统                 容量  已用  可用 已用% 挂载点<br>/dev/mapper/centos-root   50G  2.2G   48G    5% /<br>devtmpfs                  16G     0   16G    0% /dev<br>tmpfs                     16G     0   16G    0% /dev/shm<br>tmpfs                     16G     0   16G    0% /sys/fs/cgroup<br>tmpfs                     16G  8.8M   16G    1% /run<br>tmpfs                    3.2G     0  3.2G    0% /run/user/0<br>/dev/sda1               1014M  216M  799M   22% /boot<br>/dev/mapper/centos-home   39G   35M   39G    1% /home<br>tmpfs                     20M     0   20M    0% /tmp/tmpfs<br><br></code></pre></td></tr></table></figure><p>可以看到在新建的 Mount Namespace 下 <code>/tmp/tmpfs</code>目录已经被正确挂载。</p><p><strong>步骤三：在非 Mount 环境下新开一个命令行窗口，同样执行 df 命令查看主机的挂载信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">df</span> -h</span><br>文件系统                 容量  已用  可用 已用% 挂载点<br>devtmpfs                  16G     0   16G    0% /dev<br>tmpfs                     16G     0   16G    0% /dev/shm<br>tmpfs                     16G  8.8M   16G    1% /run<br>tmpfs                     16G     0   16G    0% /sys/fs/cgroup<br>/dev/mapper/centos-root   50G  2.2G   48G    5% /<br>/dev/sda1               1014M  216M  799M   22% /boot<br>/dev/mapper/centos-home   39G   35M   39G    1% /home<br>tmpfs                    3.2G     0  3.2G    0% /run/user/0<br></code></pre></td></tr></table></figure><p>通过上面输出可以看到主机上并没有挂载 &#x2F;tmp&#x2F;tmpfs，可见我们独立的 Mount Namespace 中执 mount 操作并不会影响主机。<br><strong>综上所述，通过新建 Mount Namespace，并且在新建的 Mount Namespace 内和外部是完全隔离的。</strong></p><h2 id="2-2-PID-Namespace"><a href="#2-2-PID-Namespace" class="headerlink" title="2.2 PID Namespace"></a>2.2 PID Namespace</h2><p>Linux 在创建容器的时候，就会建出一个 PID Namespace，PID 其实就是进程的编号。这个 PID Namespace，就是指每建立出一个 Namespace，就会单独对进程进行 PID 编号，每个 Namespace 的 PID 编号都从 1 开始。</p><p>同时在这个 PID Namespace 中也只能看到 Namespace 中的进程，而且看不到其他 Namespace 里的进程。</p><p>这也就是说，如果有另外一个容器，那么它也有自己的一个 PID Namespace，而这两个 PID Namespace 之间是不能看到对方的进程的，这里就体现出了 Namespace 的作用：相互隔离。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FjAvMesvedTSRWQhSweKR8LCAzrd.png"><br><strong>示例：</strong><br>使用 unshare 命令创建一个 bash 进程，并且新建一个 PID Namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">unshare --pid --fork --mount-proc /bin/bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ps -ef</span><br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 03:05 pts/4    00:00:00 /bin/bash<br>root        10     1  0 03:05 pts/4    00:00:00 ps -ef<br></code></pre></td></tr></table></figure><p>此时，通过命令创建了一个新的 PID Namespace，并且当前命令行窗口加入了新创建的 PIDNamespace。<br>接来下通过两个命令行窗口查看 PID 环境下与非 PID 环境下的进程区别：<br><strong>PIDNamespace 环境下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 03:05 pts/4    00:00:00 /bin/bash<br>root        10     1  0 03:05 pts/4    00:00:00 ps -ef<br></code></pre></td></tr></table></figure><p><strong>非 PIDNamespace 环境下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ps -ef</span><br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 6月30 ?       00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 22<br>root         2     0  0 6月30 ?       00:00:00 [kthreadd]<br>root         3     2  0 6月30 ?       00:00:00 [rcu_gp]<br>root         4     2  0 6月30 ?       00:00:00 [rcu_par_gp]<br>root         5     2  0 6月30 ?       00:00:00 [netns]<br>......<br></code></pre></td></tr></table></figure><p>通过上述命令输出结果可以看到当前 Namespace 下 bash 为 1 号进程，而且我们也看不到主机上的其他进程信息。</p><h2 id="2-3-UTS-Namespace"><a href="#2-3-UTS-Namespace" class="headerlink" title="2.3 UTS Namespace"></a>2.3 UTS Namespace</h2><p><strong>UTS Namespace 主要是用来隔离主机名</strong>，它允许每个 UTS Namespace 拥有一个独立的主机名。<br><strong>示例：</strong><br>我们的主机名称为：linux-centos，使用 UTS Namespace 可以实现在容器内的主机名称为：host-docker 或者其他任意自定义主机名。</p><p>同样我们通过一个实例来验证下 UTS Namespace 的作用，首先我们使用 unshare 命令来创建一个 UTS Namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">unshare --uts --fork /bin/bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hostname -b host-docker</span><br></code></pre></td></tr></table></figure><p>创建好 UTSNamespace 后，通过设置对应的主机名，然后观察 UTS 环境和非 UTS 环境：<br><strong>UTSNamespace 环境：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hostname</span><br>host-docker<br></code></pre></td></tr></table></figure><p><strong>非 UTSNamespace 环境：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> hostname</span><br>linux-centos<br></code></pre></td></tr></table></figure><p>由此，可以验证 UTS Namespace 可以用来隔离主机名。</p><h2 id="2-4-IPC-Namespace"><a href="#2-4-IPC-Namespace" class="headerlink" title="2.4 IPC Namespace"></a>2.4 IPC Namespace</h2><p><strong>IPC Namespace 主要是用来隔离进程间通信的</strong>。例如 PID Namespace 和 IPC Namespace 一起使用可以实现同一 IPC Namespace 内的进程彼此可以通信，不同 IPC Namespace 的进程却不能通信。</p><p><strong>示例：</strong><br>同样我们通过 unshare 创建一个实例来验证下 IPC Namespace 的作用，另外还需要借助两个命令来实现对 IPC Namespace 的验证：</p><ul><li><strong>ipcs -q 命令：</strong>用来查看系统间通信队列列表。</li><li><strong>ipcmk -Q 命令：</strong>用来创建系统间通信队列。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">们使用 unshare 命令来创建一个 IPCNamespace：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">unshare --ipc --fork /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">首先使用 ipcs -q 命令查看一下当前 IPC Namespace 下的系统通信队列列表：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ipcs -q</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以看到当前无任何系统通信队列，然后我们使用 ipcmk -Q 命令创建一个系统通信队列：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ipcmk -Q</span><br></code></pre></td></tr></table></figure><p>通过上述命令创建了一个 IPC 的 Namespace，接下来可以查看 IPC 环境和非 IPC 环境的进程情况：<br><strong>IPC Namespace :</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ipcs -q</span><br><br>--------- 消息队列 -----------<br>键        msqid      拥有者  权限     已用字节数 消息<br>0x59ef4716 0          root       644        0            0<br></code></pre></td></tr></table></figure><p><strong>非 IPC Namespace :</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ipcs -q</span><br><br>--------- 消息队列 -----------<br>键        msqid      拥有者  权限     已用字节数 消息<br></code></pre></td></tr></table></figure><p>综上可以看到，在单独的 IPC Namespace 内创建的系统通信队列在主机上无法看到。即 IPC Namespace 实现了系统通信队列的隔离。</p><h2 id="2-5-User-Namespace"><a href="#2-5-User-Namespace" class="headerlink" title="2.5 User Namespace"></a>2.5 User Namespace</h2><p><strong>User Namespace 主要是用来隔离用户和用户组的</strong>。一个比较典型的应用场景就是在主机上以非 root 用户运行的进程可以在一个单独的 User Namespace 中映射成 root 用户。<strong>使用 User Namespace 可以实现进程在容器内拥有 root 权限，而在主机上却只是普通用户</strong>。</p><h2 id="2-6-Net-Namespace"><a href="#2-6-Net-Namespace" class="headerlink" title="2.6 Net Namespace"></a>2.6 Net Namespace</h2><p><strong>Net Namespace 是用来隔离网络设备、IP 地址和端口等信息的</strong>。Net Namespace 可以让每个进程拥有自己独立的 IP 地址，端口和网卡信息。例如主机 IP 地址为 172.16.4.1 ，容器内可以设置独立的 IP 地址为 192.168.1.1 等。<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用unshare命令创建Net Namespace</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">unshare --net --fork /bin/bash</span><br></code></pre></td></tr></table></figure><p>NetNamespace 创建完成后，可以查看 Net 环境和非 Net 环境隔离性：<br><strong>NetNamespace 环境：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip a</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br></code></pre></td></tr></table></figure><p><strong>非 NetNamespace 环境：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> ip a</span><br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host<br>       valid_lft forever preferred_lft forever<br>2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 00:0c:29:a6:af:a0 brd ff:ff:ff:ff:ff:ff<br>    inet 172.16.2.77/24 brd 172.16.2.255 scope global noprefixroute ens192<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::2a6f:4800:8e71:ce88/64 scope link noprefixroute<br>       valid_lft forever preferred_lft forever<br>3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default<br>    link/ether 02:42:54:d2:b3:ab brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以看到，宿主机上有 lo、eth0、docker0 等网络设备，而我们新建的 Net Namespace 内则与主机上的网络设备不同。</p><h1 id="3-cgroups"><a href="#3-cgroups" class="headerlink" title="3. cgroups"></a>3. cgroups</h1><p><strong>cgroups（全称：control groups）是 Linux 内核的一个功能，它可以实现限制进程或者进程组的资源（如 CPU、内存、磁盘 IO 等）。</strong></p><div class="note note-success">            <p>在 2006 年，Google 的工程师（ Rohit Seth 和 Paul Menage 为主要发起人） 发起了这个项目，起初项目名称并不是 cgroups，而被称为进程容器（process containers）。在 2007 年 cgroups 代码计划合入 Linux 内核，但是当时在 Linux 内核中，容器（container）这个词被广泛使用，并且拥有不同的含义。为了避免命名混乱和歧义，进程容器被重名为 cgroups，并在 2008 年成功合入 Linux 2.6.24 版本中。cgroups 目前已经成为 systemd、Docker、LinuxContainers（LXC） 等技术的基础。</p>          </div><h2 id="3-1-cgroups-核心概念"><a href="#3-1-cgroups-核心概念" class="headerlink" title="3.1 cgroups 核心概念"></a>3.1 cgroups 核心概念</h2><p>cgroups 主要提供了如下功能：</p><ul><li><strong>资源限制：</strong> 限制资源的使用量，例如我们可以通过限制某个业务的内存上限，从而保护主机其他业务的安全运行。</li><li><strong>优先级控制：</strong>不同的组可以有不同的资源（ CPU 、磁盘 IO 等）使用优先级。</li><li><strong>审计：</strong>计算控制组的资源使用情况。</li><li><strong>控制：</strong>控制进程的挂起或恢复。</li></ul><p>了解了 cgroups 可以为我们提供什么功能，下面我来看下 cgroups 是如何实现这些功能的。cgroups 功能的实现依赖于三个核心概念：<strong>子系统</strong>、<strong>控制组</strong>、<strong>层级树</strong>：</p><ul><li><strong>子系统（subsystem）</strong>：是一个内核的组件，一个子系统代表一类资源调度控制器。例如内存子系统可以限制内存的使用量，CPU 子系统可以限制 CPU 的使用时间。</li><li><strong>控制组（cgroup）</strong>：表示一组进程和一组带有参数的子系统的关联关系。例如，一个进程使用了 CPU 子系统来限制 CPU 的使用时间，则这个进程和 CPU 子系统的关联关系称为控制组。</li><li><strong>层级树（hierarchy）</strong>：是由一系列的控制组按照树状结构排列组成的。这种排列方式可以使得控制组拥有父子关系，子控制组默认拥有父控制组的属性，也就是子控制组会继承于父控制组。比如，系统中定义了一个控制组 c1，限制了 CPU 可以使用 1 核，然后另外一个控制组 c2 想实现既限制 CPU 使用 1 核，同时限制内存使用 2G，那么 c2 就可以直接继承 c1，无须重复定义 CPU 限制。</li></ul><p><strong>cgroups 子系统：</strong><br>cgroups 的三个核心概念中，子系统是最核心的概念，因为子系统是真正实现某类资源的限制的基础。以下是几种常见的子系统：</p><ul><li><strong>CPU 子系统</strong>：用来限制一个控制组（一组进程，你可以理解为一个容器里所有的进程）可使用的最大 CPU。</li><li><strong>memory 子系统</strong>：用来限制一个控制组最大的内存使用量。</li><li><strong>pids 子系统</strong>：用来限制一个控制组里最多可以运行多少个进程。</li><li><strong>cpuset 子系统</strong>：这个子系统来限制一个控制组里的进程可以在哪几个物理 CPU 上运行。\</li></ul><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的<code>/sys/fs/cgroup</code> 路径下。在 Linux，我可以用 mount 指令把它们展示出来，这条命令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mount -t cgroup</span><br>cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)<br>cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)<br>cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)<br>cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpu,cpuacct)<br>.....<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意不同内核版本 cgroups 子系统和使用方式可能略有差异。通过输出，可以看到当前系统已经挂载了我们常用的 cgroups 子系统，例如 cpu、memory、pids 等我们常用的 cgroups 子系统。</p>          </div><p>另外，我们也可以在<code>/sys/fs/cgroup</code>下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /sys/fs/cgroup/cpu</span><br>cgroup.clone_children  cpuacct.usage             cpuacct.usage_percpu_user  cpu.cfs_period_us  cpu.rt_runtime_us  release_agent<br>cgroup.procs           cpuacct.usage_all         cpuacct.usage_sys          cpu.cfs_quota_us   cpu.shares         system.slice<br>cgroup.sane_behavior   cpuacct.usage_percpu      cpuacct.usage_user         cpu.idle           cpu.stat           tasks<br>cpuacct.stat           cpuacct.usage_percpu_sys  cpu.cfs_burst_us           cpu.rt_period_us   notify_on_release  user.slice<br></code></pre></td></tr></table></figure><p>通过在这些对应的文件中填入对应的参数即可达到资源限制的目的。</p><p>综上所述：Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，<strong>cgroups 就是一个子系统目录加上一组资源限制文件的组合</strong>。</p><h2 id="3-2-cpu-子系统"><a href="#3-2-cpu-子系统" class="headerlink" title="3.2 cpu 子系统"></a>3.2 cpu 子系统</h2><p>我首先以 cpu 子系统为例，演示一下 cgroups 如何限制进程的 cpu 使用时间。</p><p><strong>第一步：在 cpu 子系统下创建 cgroup</strong><br>cgroups 的创建很简单，只需要在相应的子系统下创建目录即可。下面我们到 cpu 子系统下创建测试文<br>件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/cpu/mydocker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /sys/fs/cgroup/cpu/mydocker</span><br>cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.cfs_quota_us  cpu.rt_runtime_us  notify_on_release<br>cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_burst_us    cpu.idle          cpu.shares         tasks<br>cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_period_us   cpu.rt_period_us  cpu.stat<br></code></pre></td></tr></table></figure><p>执行完命令后，我们可以看到我们新建的目录下被自动创建了很多文件，这些文件件就是 cgroup 用来进行资源限额的配置文件。</p><p>我们可以打开 CPU 的限制文件查看当前限制大小，<code>cpu.cfs_quota_us</code>文件代表在某一个阶段限制的 CPU 时间总量，单位为微秒。例如，我们想限制某个进程最多使用 1 核 CPU，就在这个文件里写 100000（100000 代表限制 1 个核） ，tasks 文件中写入进程的 ID 即可（如果要限制多个进程 ID，在 tasks 文件中用换行符分隔即可）。</p><p><strong>第二步：创建进程，加入 cgroup</strong><br>这里为了方便演示，我先把当前运行的 shell 进程加入 cgroup，然后在当前 shell 运行 cpu 耗时任务（这里利用到了继承，子进程会继承父进程的 cgroup），使用以下命令将 shell 进程加入 cgroup 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu/mydocker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> $$ &gt; tasks</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">cat</span> tasks</span><br>2567<br>2584<br></code></pre></td></tr></table></figure><p>其中第一个进程 ID 为当前 shell 的主进程，也就是说，当前 shell 主进程为 2567。</p><p><strong>第三步：执行 CPU 耗时任务，验证 cgroup 是否可以限制 cpu 使用时间</strong><br>下面，我们使用以下命令制造一个死循环，来提升 cpu 使用率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span>;<span class="hljs-keyword">done</span>;</span><br></code></pre></td></tr></table></figure><p>然后打开一个终端监听查看进程资源使用情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">top -p 2567</span><br>top - 05:31:04 up  1:44,  4 users,  load average: 0.00, 0.11, 0.10<br>Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie<br><span class="hljs-meta prompt_">%</span><span class="language-bash">Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 <span class="hljs-built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br>KiB Mem : 32884600 total, 31875788 free,   401252 used,   607560 buff/cache<br>KiB Swap: 10485756 total, 10485756 free,        0 used. 32089672 avail Mem<br><br>  PID USER      PR  NI    VIRT    RES    SHR S   %CPU   %MEM     TIME+ COMMAND<br> 2567 root      20   0  115764   3484   3068 S   100.0  0.0   1:00.29 bash<br></code></pre></td></tr></table></figure><p>通过上面输出可以看到 2567 这个进程被限制到了只能使用 100 % 的 cpu，也就是 1 个核。说明我们使用 cgroup 来限制 cpu 使用时间已经生效。</p><p>如果想要限制 CPU 使用核数限制可以使用如下命令修改。例如：修改 cpu 限制时间为 0.5 核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu/mydocker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 50000 &gt; cpu.cfs_quota_us</span><br></code></pre></td></tr></table></figure><h2 id="3-3-memory-子系统"><a href="#3-3-memory-子系统" class="headerlink" title="3.3 memory 子系统"></a>3.3 memory 子系统</h2><p>在测试 memory 子系统示例之前，需要安装一个内存测试工具：memtester，安装步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum install -y gcc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /tmp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget http://pyropus.ca/software/memtester/old-versions/memtester-4.2.2.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar zxvf memtester-4.2.2.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> memtester-4.2.2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make &amp;&amp; make install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> memtester /bin/memtester</span><br></code></pre></td></tr></table></figure><p><strong>第一步：在 memory 子系统下创建 cgroup</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/memory/mydocker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cgroup 子系统会自动在该目录下创建memory相关资源限额文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /sys/fs/cgroup/memory/mydocker</span><br>...<br></code></pre></td></tr></table></figure><p><strong>第二步：修改 memory 限额</strong><br>其中 memory.limit_in_bytes 文件代表内存使用总量，单位为 byte。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory/mydocker</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 内存限额：1G</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 1073741824 &gt; memory.limit_in_bytes</span><br></code></pre></td></tr></table></figure><p><strong>第三步：创建进程，加入 cgroup</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory/mydocker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把当前 shell 进程 ID 写入 tasks 文件内：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> $$ &gt; tasks</span><br></code></pre></td></tr></table></figure><p><strong>第四步：执行内存测试工具，申请内存</strong><br>该命令会申请 1500 M 内存，并且做内存测试。由于上面我们对当前 shell 进程内存限制为 1 G，当 memtester 使用的内存达到 1G 时，cgroup 便将 memtester 杀死。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">memtester 1500M 1</span><br><br>memtester version 4.2.2 (64-bit)<br>Copyright (C) 2010 Charles Cazabon.<br>Licensed under the GNU General Public License version 2 (only).<br><br>pagesize is 4096<br>pagesizemask is 0xfffffffffffff000<br>want 1500MB (1572864000 bytes)<br>got  1500MB (1572864000 bytes), trying mlock ...已杀死<br></code></pre></td></tr></table></figure><p>上面最后一行的输出结果表示 memtester 想要 1500 M 内存，但是由于 cgroup 限制，达到了内存使用上限，被杀死了，与我们的预期一致。<br>我们可以使用以下命令，降低一下内存申请，将内存申请调整为 500M：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">memtester 500M 1</span><br><br>memtester version 4.2.2 (64-bit)<br>Copyright (C) 2010 Charles Cazabon.<br>Licensed under the GNU General Public License version 2 (only).<br><br>pagesize is 4096<br>pagesizemask is 0xfffffffffffff000<br>want 500MB (524288000 bytes)<br>got  500MB (524288000 bytes), trying mlock ...locked.<br>Loop 1/1:<br>  Stuck Address       : ok<br>  Random Value        : ok<br>......<br></code></pre></td></tr></table></figure><p>这里可以看到，此时 memtester 已经成功申请到 500M 内存并且正常完成了内存测试。<br>更多关于 cgroup 知识可以参考<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/index">RedHat 官网</a>。</p><h2 id="3-4-删除-cgroups"><a href="#3-4-删除-cgroups" class="headerlink" title="3.4 删除 cgroups"></a>3.4 删除 cgroups</h2><p>上面创建的 cgroups 如果不想使用了，直接删除创建的文件夹即可。<br>例如我想删除内存下的 mydocker 目录，使用以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rmdir</span> /sys/fs/cgroup/memory/mydocker/</span><br></code></pre></td></tr></table></figure><h2 id="3-5-docker-下使用-cgroups"><a href="#3-5-docker-下使用-cgroups" class="headerlink" title="3.5 docker 下使用 cgroups"></a>3.5 docker 下使用 cgroups</h2><p>首先，我们使用以下命令创建一个 nginx 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run  -d -it -m=1g nginx</span><br>eae5dc5e6d2ed2575aab337955722481be01e9e0856e4a4a826cc00afbc365d2<br></code></pre></td></tr></table></figure><p>上述命令创建并启动了一个 nginx 容器，并且限制内存为 1G。<strong>如果我们想要查看刚刚创建的 docker 对应的 cgroups 资源限额文件则可以通过：</strong><code>**/sys/fs/cgroup/memory/docker/&lt;docker-id&gt;/**</code>** 查看**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /sys/fs/cgroup/memory/docker/eae5dc5e6d2ed2575aab337955722481be01e9e0856e4a4a826cc00afbc365d2</span><br>总用量 0<br>cgroup.clone_children       memory.kmem.max_usage_in_bytes      memory.limit_in_bytes            memory.numa_stat            memory.use_hierarchy<br>cgroup.event_control        memory.kmem.slabinfo                memory.max_usage_in_bytes        memory.oom_control          notify_on_release<br>......<br></code></pre></td></tr></table></figure><p>查看一下该容器的 memory.limit_in_bytes 文件的内容，可以看到内存资源限制为：1G。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> memory.limit_in_bytes</span><br>1073741824<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dockerfile</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、DockerCLI容器指令</title>
    <link href="/2022/06/24/docker-cli-command/"/>
    <url>/2022/06/24/docker-cli-command/</url>
    
    <content type="html"><![CDATA[<p>Docker 镜像是由 <code>Dockerfile</code>和一些必要的依赖项组成的，Docker 容器是运行态的 Docker 镜像。要使用 Docker 命令，首先需要知道在处理镜像还是容器。一旦你知道你所处理的是镜像还是容器之后，你才可以找到正确的命令。</p><p>Docker 镜像是由<code>Dockerfile</code>描述生成的，对于 Docker 镜像的构建、运行、状态查看、停止、销毁则是由<code>Docker CLI</code>相关指令完成的。Docker CLI 指令可以分为如下几类：<code>镜像指令</code>、<code>容器生命周期指令</code>、<code>容器操作指令</code>、<code>容器仓库指令</code>、<code>容器rootfs指令</code>。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FrxvF9Hg4bGQWbEzRydmuhxBNYmV.png"></p><h1 id="1-镜像指令"><a href="#1-镜像指令" class="headerlink" title="1.镜像指令"></a>1.镜像指令</h1><h2 id="images-显示本地镜像"><a href="#images-显示本地镜像" class="headerlink" title="images 显示本地镜像"></a>images 显示本地镜像</h2><p><strong>用途：</strong>用于显示本地镜像列表包括：镜像名称、镜像所属仓库、镜像 tag、镜像大小等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a : 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br>--digests : 显示镜像的摘要信息；<br>-f : 显示满足条件的镜像；<br>--format  : 指定返回值的模板文件；<br>--no-trunc : 显示完整的镜像信息；<br>-q : 只显示镜像 ID。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">展示镜像列表</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                               TAG       IMAGE ID       CREATED         SIZE<br>nginx                                    latest    cd4e03b35a8e   3 days ago      134MB<br>k8s.gcr.io/kube-apiserver                v1.24.0   b62a103951f4   7 weeks ago     126MB<br>k8s.gcr.io/kube-controller-manager       v1.24.0   59fad34d4fe0   7 weeks ago     116MB<br>k8s.gcr.io/kube-proxy                    v1.24.0   66e1443684b0   7 weeks ago     106MB<br>k8s.gcr.io/kube-scheduler                v1.24.0   b81513b3bfb4   7 weeks ago     50MB<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据name或者tag进行筛选展示</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> docker images k8s.gcr.io/etcd</span><br>REPOSITORY        TAG       IMAGE ID       CREATED        SIZE<br>k8s.gcr.io/etcd   3.5.3-0   a9a710bb96df   2 months ago   178MB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">过滤出tag为空的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images --filter <span class="hljs-string">&quot;dangling=true&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除tag为空的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi $(docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span> -q)</span><br></code></pre></td></tr></table></figure><h2 id="rmi-删除本地镜像"><a href="#rmi-删除本地镜像" class="headerlink" title="rmi 删除本地镜像"></a>rmi 删除本地镜像</h2><p><strong>用途：</strong>删除本地一个或者多个镜像。如果镜像带了标签的，那么只会删除 img:tag 镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-f : 强制删除；<br>--no-prune : 不移除该镜像的过程镜像，默认移除；<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi fd484f19954f</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi test1:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi <span class="hljs-built_in">test</span>:latest</span><br></code></pre></td></tr></table></figure><h2 id="tag-镜像打标签"><a href="#tag-镜像打标签" class="headerlink" title="tag 镜像打标签"></a>tag 镜像打标签</h2><p><strong>用途：</strong>为镜像打上标签，让其有归属的仓库或者标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag 0e5574283393 fedora/httpd:version1.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag httpd fedora/httpd:version1.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag httpd:<span class="hljs-built_in">test</span> fedora/httpd:version1.0.test</span><br><br></code></pre></td></tr></table></figure><h2 id="build-构建镜像"><a href="#build-构建镜像" class="headerlink" title="build 构建镜像"></a>build 构建镜像</h2><p><strong>用途：</strong>从<code>Dockerfile</code>和<code>上下文</code>构建 Docker 映像，构建的上下文是位于指定 PATH 或 URL。该 URL 参数可以引用三种资源：<code>Git 存储库</code>、<code>预打包的 tarball 上下文</code>和<code>纯文本文件</code>。<br><strong>用途：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build [OPTIONS] PATH | URL | -</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">--add-host :添加一个自定义的host-ip映射，(host:ip)<br>--build-arg=[] :设置镜像创建时的变量；<br>--cpu-shares :设置 cpu 使用权重；<br>--cpu-period :限制 CPU CFS 周期；<br>--cpu-quota :限制 CPU CFS 配额；<br>--cpuset-cpus :指定使用的 CPU id；<br>--cpuset-mems :指定使用的内存 id；<br>--disable-content-trust :忽略校验，默认开启；<br>--file，-f :指定要使用的 Dockerfile 路径；<br>--force-rm :设置镜像过程中删除中间容器；<br>--isolation :使用容器隔离技术；<br>--label=[] : 置镜像使用的元数据；<br>-m : 设置内存最大值；<br>--memory-swap :设置 Swap 的最大值为内存 + swap，&quot;-1&quot; 表示不限 swap；<br>--no-cache :创建镜像的过程不使用缓存；<br>--pull :尝试去更新镜像的新版本；<br>--quiet, -q :安静模式，成功后只输出镜像 ID；<br>--rm :设置镜像成功后删除中间容器；<br>--shm-size :设置 /dev/shm 的大小，默认值是 64M；<br>--ulimit :Ulimit 配置。<br>--tag, -t :镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>--network :默认 default。在构建期间设置 RUN 指令的网络模式<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用Dockerfile</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从Git仓库构建</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build github.com/creack/docker-firefox</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从远程文件构建</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -f ctx/Dockerfile http://server/ctx.tar.gz</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时设定tag元数据</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t vieux/apache:2.0 .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时设置变量信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234 --build-arg FTP_PROXY=http://40.50.60.5:4567 .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> HTTP_PROXY=http://10.20.30.2:1234</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build --build-arg HTTP_PROXY .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时设置host信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build --add-host=docker:10.180.0.1 .</span><br></code></pre></td></tr></table></figure><h2 id="history-镜像构建历史"><a href="#history-镜像构建历史" class="headerlink" title="history 镜像构建历史"></a>history 镜像构建历史</h2><p><strong>用途：</strong>查看指定镜像的创建历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">history</span> [OPTIONS] IMAGE</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-H : 以可读的格式打印镜像大小和日期，默认为 true<br>--no-trunc : 显示完整的提交记录<br>-q : 仅列出提交记录 ID<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">history</span> busybox</span><br>IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT<br>3c19bafed223   2 weeks ago   /bin/sh -c #(nop)  CMD [&quot;sh&quot;]                   0B<br>&lt;missing&gt;      2 weeks ago   /bin/sh -c #(nop) ADD file:d0bcfa7c7f5145e0b…   1.41MB<br></code></pre></td></tr></table></figure><h2 id="save-镜像归档"><a href="#save-镜像归档" class="headerlink" title="save 镜像归档"></a>save 镜像归档</h2><p><strong>用途：</strong>将指定<code>镜像</code>保存成 tar 归档文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-o : 输出到的文件。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将镜像busybox:latest 归档存放到：~/Downloads/并以busybox-latest.tar命名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">save -o ~/Downloads/busybox-latest.tar busybox:latest</span><br></code></pre></td></tr></table></figure><h2 id="export-镜像归档"><a href="#export-镜像归档" class="headerlink" title="export 镜像归档"></a>export 镜像归档</h2><p><strong>用途：</strong>将<code>container的文件系统</code>进行打包并归档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> [OPTIONS] CONTAINER</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-o : 将输入内容写到目标文件<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE            COMMAND   CREATED          STATUS         PORTS     NAMES<br>0f8ba3648e84   busybox:latest   &quot;sh&quot;      10 seconds ago   Up 9 seconds             zen_shirley<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> -o ~/Downloads/busybox-6-26.tar 0f8ba3648e84</span><br></code></pre></td></tr></table></figure><h2 id="load-加载镜像"><a href="#load-加载镜像" class="headerlink" title="load 加载镜像"></a>load 加载镜像</h2><p><strong>用途：</strong>从 tar 中导入 docker 镜像文件，该文件一般就是使用<code>docker save</code>命令导出的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load [OPTIONS]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--input , -i : 指定导入的文件，代替 STDIN。<br>--quiet , -q : 精简输出信息。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load --input fedora.tar</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; busybox.tar.gz</span><br></code></pre></td></tr></table></figure><h2 id="import-导入镜像"><a href="#import-导入镜像" class="headerlink" title="import 导入镜像"></a>import 导入镜像</h2><p><strong>用途：</strong>从 tar 归档文件中创建镜像，该文件一般就是使用<code>docker export</code>命令导出的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker import busybox-6-26.tar busybox:v6.27</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>busybox      v6.27     22f3c125f894   2 seconds ago   1.41MB<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>save&#x2F;export 、load&#x2F;import 区别：</strong><br>docker save 保存的是镜像（image），docker export 保存的是容器（container）；<br>docker load 用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像；<br>docker load 不能对载入的镜像重命名，而 docker import 可以为镜像指定新名称。</p>          </div><h1 id="2-容器生命周期指令"><a href="#2-容器生命周期指令" class="headerlink" title="2.容器生命周期指令"></a>2.容器生命周期指令</h1><h2 id="run-从镜像运行一个容器"><a href="#run-从镜像运行一个容器" class="headerlink" title="run - 从镜像运行一个容器"></a>run - 从镜像运行一个容器</h2><p>Docker 容器是 Docker 镜像的运行形态，<code>Docker容器是一个资源受限、视图隔离的进程</code>。当运行<code>docker run</code>命令时，Docker 会启动一个进程，并为这个进程分配其独占的文件系统、网络资源和以此进程为根进程的进程组。<br>在容器启动时，镜像可能已经定义了要运行的二进制文件（通过 Dockerfile）、暴露的网络端口等，但是用户可以通过 docker run 命令重新定义。</p><div class="note note-info">            <p>docker run 可以控制一个容器运行时的行为，它可以覆盖 docker build 在构建镜像时的一些默认配置，这也是为什么 run 命令相比于其它命令有如此多的参数的原因。<br>docker run [OPTIONS]可以让用户完全控制容器的生命周期，并允许用户覆盖执行 docker build 时所设定的参数，甚至也可以修改本身由 Docker 所控制的内核级参数。</p>          </div><p><strong>命令格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数汇总：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>-a stdin : 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>-d : 后台运行容器，并返回容器 ID；<br>-i : 以交互模式运行容器，通常与 -t 同时使用；<br>-P : 随机端口映射，容器内部端口随机映射到主机的端口<br>-p : 指定端口映射，格式为：主机 (宿主) 端口：容器端口<br>-t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>--name=&quot;nginx-lb&quot;: 为容器指定一个名称；<br>--dns 8.8.8.8 : 指定容器使用的 DNS 服务器，默认和宿主一致；<br>--dns-search example.com: 指定容器 DNS 搜索域名，默认和宿主一致；<br>-h &quot;mars&quot;  : 指定容器的 hostname；<br>-e username=&quot;ritchie&quot;: 设置环境变量；<br>--env-file=[] : 从指定文件读入环境变量；<br>--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定 CPU 运行；<br>-m  : 设置容器使用内存最大值；<br>--net=&quot;bridge&quot; : 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>--link=[] : 添加链接到另一个容器；<br>--expose=[]  : 开放一个端口或一组端口；<br>--volume  : -v 绑定一个卷<br></code></pre></td></tr></table></figure><p><strong>COMMAND 参数：</strong><br>这个命令中的<code>COMMAND</code>部分是可选的。因为这个 IMAGE 在<code>build</code>时，开发人员可能已经设定了默认执行的命令。作为操作人员，你可以使用上面命令中新的 command 来覆盖旧的 command。<br>如果镜像中设定了<code>ENTRYPOINT</code>，那么命令中的<code>CMD</code>也可以作为参数追加到<code>ENTRYPOINT</code>中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">--entrypoint=&quot;&quot;: Overwrite the default entrypoint set by the image<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 例如：</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -it --entrypoint /bin/bash example/redis</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -it --entrypoint /bin/bash example/redis -c <span class="hljs-built_in">ls</span> -l</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -it --entrypoint /usr/bin/redis-cli example/redis --<span class="hljs-built_in">help</span></span><br></code></pre></td></tr></table></figure><p><code>docker run [OPTIONS]</code> OPTIONS 参数比较多总起来说可以分为两类：</p><ol><li>设置运行方式：<ul><li>决定容器的运行方式，前台执行还是后台执行；</li><li>设置运行唯一标志；</li><li>设置网络参数；</li><li>设置容器的 CPU 和内存资源限额参数；</li><li>设置权限和 LXC 参数；</li></ul></li><li>设置镜像的默认资源，也就是说用户可以使用该命令来覆盖在镜像构建时的一些默认配置。</li></ol><h3 id="设置容器运行方式"><a href="#设置容器运行方式" class="headerlink" title="设置容器运行方式"></a>设置容器运行方式</h3><p><strong>Detached vs foreground：</strong>当我们启动一个容器时，首先需要确定这个容器是运行在前台还是运行在后台。</p><ul><li><strong>Detached (-d)</strong></li></ul><p>如果在<code>docker run</code>后面追加<code>-d=true 或者 -d</code>，那么容器将会运行在后台模式。此时所有 I&#x2F;O 数据只能通过网络资源或者共享卷组来进行交互。因为容器不再监听你执行 docker run 的这个终端命令行窗口。但你可以通过执行 docker attach 来重新附着到该容器的回话中。需要注意的是，容器运行在后台模式下，是不能使用–rm 选项的。</p><ul><li><strong>Foregroud</strong></li></ul><p>在前台模式下（不指定-d 参数即可），Docker 会在容器中启动进程，同时将当前的命令行窗口附着到容器的标准输入、标准输出和标准错误中。也就是说容器中所有的输出都可以在当前窗口中看到。甚至它都可以虚拟出一个 TTY 窗口，来执行信号中断。这一切都是可以配置的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a=[]          　: Attach to `STDIN`, `STDOUT` and/or `STDERR`<br>-t=false         : Allocate a pseudo-tty<br>--sig-proxy=true : Proxify all received signal to the process (non-TTY mode only)<br>-i=false         : Keep STDIN open even if not attached<br></code></pre></td></tr></table></figure><h3 id="设置容器运行标识"><a href="#设置容器运行标识" class="headerlink" title="设置容器运行标识"></a>设置容器运行标识</h3><ul><li><strong>Name（–name）</strong></li></ul><p>可以通过三种方式为容器命名:</p><ol><li>使用 UUID 长命名（”f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”）</li><li>使用 UUID 短命令（”f78375b1c487”）</li><li>使用 Name(“evil_ptolemy”)<br>这个 UUID 标示是由 Docker deamon 生成的。如果你在执行 docker run 时没有指定–name，那么 deamon 会自动生成一个随机字符串 UUID。<strong>但是对于一个容器来说有个 name 会非常方便，当你需要连接其它容器时或者类似需要区分其它容器时，使用容器名称可以简化操作。</strong>无论容器运行在前台或者后台，这个名字都是有用的。</li></ol><ul><li><strong>PID equivalent</strong></li></ul><p>如果在使用 Docker 时有自动化的需求，你可以将 containerID 输出到指定的文件中（PIDfile），类似于某些应用程序将自身 ID 输出到文件中，方便后续脚本操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--cidfile=&quot;&quot;: Write the container ID to the file<br></code></pre></td></tr></table></figure><ul><li><strong>Image[:tag]</strong></li></ul><p>当一个镜像的名称不足以分辨这个镜像所代表的含义时，你可以通过 tag 将版本信息添加到 run 命令中，以执行特定版本的镜像。例如:<code> docker run ubuntu:14.04</code></p><ul><li><strong>IPC Settings</strong></li></ul><p>默认情况下，所有容器都开启了 IPC 命名空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--ipc=&quot;&quot;  : Set the IPC mode for the container,<br>          &#x27;container:&lt;name|id&gt;&#x27;: reuses another container&#x27;s IPC namespace<br>          &#x27;host&#x27;: use the host&#x27;s IPC namespace inside the container<br></code></pre></td></tr></table></figure><p><strong>IPC（POSIX&#x2F;SysV IPC）命名空间提供了相互隔离的命名共享内存、信号灯变量和消息队列。</strong></p><div class="note note-info">            <p>共享内存可以提高进程数据的交互速度。共享内存一般用在数据库和高性能应用（C&#x2F;OpenMPI、C++&#x2F;using boost libraries）上或者金融服务上。如果需要容器中部署上述类型的应用，那么就应该在多个容器直接使用共享内存了。</p>          </div><h3 id="设置容器运行网络"><a href="#设置容器运行网络" class="headerlink" title="设置容器运行网络"></a>设置容器运行网络</h3><p>默认情况下，所有的容器都开启了网络接口，同时可以接受任何外部的数据请求。<br><strong>网络设置参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">--dns=[]           : Set custom dns servers for the container<br>--network=&quot;bridge&quot; : Connect a container to a network<br>&#x27;bridge&#x27;: create a network stack on the default Docker bridge<br>&#x27;none&#x27;: no networking<br>&#x27;container:&lt;name|id&gt;&#x27;: reuse another container&#x27;s network stack<br>&#x27;host&#x27;: use the Docker host network stack<br>&#x27;&lt;network-name&gt;|&lt;network-id&gt;&#x27;: connect to a user-defined network<br>--network-alias=[] : Add network-scoped alias for the container<br>--add-host=&quot;&quot;      : Add a line to /etc/hosts (host:IP)<br>--mac-address=&quot;&quot;   : Sets the container&#x27;s Ethernet device&#x27;s MAC address<br>--ip=&quot;&quot;            : Sets the container&#x27;s Ethernet device&#x27;s IPv4 address<br>--ip6=&quot;&quot;           : Sets the container&#x27;s Ethernet device&#x27;s IPv6 address<br>--link-local-ip=[] : Sets one or more container&#x27;s Ethernet device&#x27;s link local IPv4/IPv6 addresses<br></code></pre></td></tr></table></figure><p>你可以通过<code>docker run --net none</code>来关闭网络接口，此时将关闭所有网络数据的输入输出，你只能通过 STDIN、STDOUT 或者 files 来完成 I&#x2F;O 操作。<br><strong>–dns：</strong>默认情况下，容器使用主机的 DNS 设置，你也可以通过–dns 来覆盖容器内的 DNS 设置。<br><strong>–mac-address：</strong>同时 Docker 为容器默认生成一个 MAC 地址，你可以通过<code>--mac-address 12:34:56:78:9a:bc</code>来设置你自己的 MAC 地址。<br><strong>–add-host：</strong><code>/etc/hosts</code>文件中会包含容器的 hostname 信息，我们也可以使用<code>--add-host</code>这个参数来动态添加<code>/etc/hosts</code>中的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --add-host db-static:86.75.30.9 ubuntu <span class="hljs-built_in">cat</span> /etc/hosts</span><br>127.0.0.1       localhost<br>::1             localhost ip6-localhost ip6-loopback<br>86.75.30.9      db-static<br></code></pre></td></tr></table></figure><p><strong>–mac-address：</strong>设置容器的网卡 mac 地址。<br><strong>–ip：</strong>设置容器网卡的 IPv4 地址。<br><strong>–ip6：</strong>设置容器网卡的 Pv6 地址。</p><p><strong>Docker 支持的网络模式有：</strong></p><table><thead><tr><th><strong>网络模式</strong></th><th><strong>简介</strong></th></tr></thead><tbody><tr><td><strong>none</strong></td><td>关闭容器内的网络连接</td></tr><tr><td><strong>bridge（default）</strong></td><td>通过 veth 接口来连接容器（连接到 docker0 的虚拟网桥）</td></tr><tr><td><strong>host</strong></td><td>使用宿主机的 IP 和端口。注意：这种方式将允许容器访问 host 中类似 D-BUS 之类的系统服务，所以认为是不安全的。</td></tr><tr><td><strong>container</strong></td><td>使用另外一个制定的容器的网络堆栈信息</td></tr></tbody></table><p>将网络模式设置为<code>none</code>时，这个容器将不允许访问任何外部 router。这个容器内部只会有一个 loopback 接口，而且不存在任何可以访问外部网络的 router。<br><strong>Bridge 模式</strong><br>Docke r 默认会将容器设置为 bridge 模式。此时在主机上面将会存在一个<code>docker0</code>的网络接口，同时会针对容器创建一对 veth 接口。其中一个 veth 接口是在主机充当网卡桥接作用，另外一个 veth 接口存在于容器的命名空间中，并且指向容器的 loopback。Docker 会自动给这个容器分配一个 IP，并且将容器内的数据通过桥接转发到外部。<br><strong>Host 模式</strong><br>当网络模式设置为 host 时，这个容器将完全共享 host 的网络堆栈。host 所有的网络接口将完全对容器开放。容器的主机名也会存在于主机的 hostname 中。这时，容器所有对外暴露的端口和对其它容器的连接，将完全失效。<br><strong>Container 模式</strong><br>当网络模式设置为 Container 时，这个容器将完全复用另外一个容器的网络堆栈。同时使用时这个容器的名称必须要符合下面的格式：<code>--net container:&lt;name|id&gt;</code><br>例如：当前有一个绑定了本地地址 localhost 的 Redis 容器。如果另外一个容器需要复用这个网络堆栈，则需要如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -d --name redis example/redis --<span class="hljs-built_in">bind</span> 127.0.0.1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># use the redis container&#x27;s network stack to access localhost</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run --<span class="hljs-built_in">rm</span> -ti --net container:redis example/redis-cli -h 127.0.0.1</span><br></code></pre></td></tr></table></figure><h3 id="设置容器运行资源限额"><a href="#设置容器运行资源限额" class="headerlink" title="设置容器运行资源限额"></a>设置容器运行资源限额</h3><ul><li><strong>内存限制：</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-m,--memory :内存限制，格式是数字加单位，单位可以为 b,k,m,g,最小为 4M<br>--memory-swap :内存+交换分区大小总限制。单位可以为 b,k,m,g,最小为 4M<br>--memory-reservation :内存的软性限制。单位可以为 b,k,m,g,最小为 4M<br>--oom-kill-disable :是否阻止 OOM killer 杀死容器，默认没设置<br>--oom-score-adj :容器被 OOM killer 杀死的优先级，范围是[-1000, 1000]，默认为 0<br>--memory-swappiness :用于设置容器的虚拟内存控制行为。值为 0~100 之间的整数<br>--kernel-memory :内核内存限制<br></code></pre></td></tr></table></figure><p><strong>–memory-reservation：</strong>Memory reservation 用于节制容器内存使用。给<code>--memory-reservation</code>设置一个比<code>-m</code>小的值后，虽然容器最多可以使用<code>-m</code>使用的内存大小，<strong>但在宿主机内存资源紧张时，在系统的下次内存回收时，系统会回收容器的部分内存页，强迫容器的内存占用回到–memory-reservation 设置的值大小</strong>。</p><div class="note note-info">            <p>Memory reservation 是一种软性机制，它不保证任何时刻容器使用的内存不会超过<code>--memory-reservation</code>限定的值，它只是确保容器不会长时间占用超过<code>--memory-reservation</code>限制的内存大小。<br>超过一段时间后，会被宿主机系统杀死（如果没有设置<code>--00m-kill-disable=true</code>的话）。</p>          </div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">若容器使用了&gt;200M and &lt;500M内存时，下次系统的内存回收会尝试将容器的内存锁紧到200M以下。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it -m 500M --memory-reservation 200M ubuntu:16.04 /bin/bash</span><br></code></pre></td></tr></table></figure><p>用户内存限制就是对容器能使用的内存和交换分区的大小作出限制。使用时要遵循两条直观的规则：<code>-m，--memory</code>选项的参数最小为 4 M。<code>--memory-swap</code>不是交换分区，而是内存加交换分区的总大小，所以<code>--memory-swap</code>必须比<code>-m,--memory</code>大。</p><div class="note note-success">            <p><strong>不设置-m,–memory 和–memory-swap</strong><br>此时容器默认可以用完宿舍机的所有内存和 swap 分区。不过注意，如果容器占用宿主机的所有内存和 swap 分区超过一段时间后，会被宿主机系统杀死（如果没有设置<code>--00m-kill-disable=true</code>的话）。</p>          </div><div class="note note-success">            <p><strong>设置-m,–memory，不设置–memory-swap</strong><br>给-m 或–memory 设置一个不小于 4M 的值，假设为 a，不设置–memory-swap。这种情况下，容器能使用的内存大小为 a，能使用的交换分区大小也为 a。<strong>因为 Docker 默认容器交换分区的大小和内存相同</strong>。<br>比如：$ docker run -m 1G ubuntu:16.04，该容器能使用的内存大小为 1G，能使用的 swap 分区大小也为 1G。容器内的进程能申请到的总内存大小为 2G。</p>          </div><ul><li><strong>CPU 限制：</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">--cpuset-cpus=&quot;&quot;  :允许使用的 CPU 核心集，值可以为 0-3,0,1<br>-c,--cpu-shares=0 :CPU 共享权值（相对权重）<br>cpu-period=0     :限制 CPU CFS 的周期，范围从 100ms~1s，即[1000, 1000000]<br>--cpu-quota=0     :限制 CPU CFS 配额，必须不小于1ms，即 &gt;= 1000<br>--cpuset-mems=&quot;&quot;  :允许在上执行的内存节点（MEMs），只对 NUMA 系统有效<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">表示容器中的进程可以在 cpu 1 和 cpu 3 上执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpuset-cpus=<span class="hljs-string">&quot;1,3&quot;</span> ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示容器中的进程只能使用内存节点 1 和 3 上的内存</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpuset-mems=<span class="hljs-string">&quot;1,3&quot;</span> ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示容器中的进程只能使用内存节点 0、1、2 上的内存</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpuset-mems=<span class="hljs-string">&quot;0-2&quot;</span> ubuntu:14.04 /bin/bash</span><br></code></pre></td></tr></table></figure><p><strong>CPU 资源的相对限制</strong><br>默认情况下，所有的容器得到同等比例的 CPU 周期。在有多个容器竞争 CPU 时我们可以设置每个容器能使用的 CPU 时间比例。这个比例叫作共享权值，通过<code>-c</code>或<code>--cpu-shares</code>设置。Docker 默认每个容器的权值为 1024。不设置或将其设置为 0，都将使用这个默认值。系统会根据每个容器的共享权值和所有容器共享权值和比例来给容器分配 CPU 时间。</p><p>例如：有三个正在运行的容器，这三个容器中的任务都是 CPU 密集型的。第一个容器的 cpu 共享权值是 1024，其它两个容器的 cpu 共享权值是 512。第一个容器将得到 50% 的 CPU 时间，而其它两个容器就只能各得到 25% 的 CPU 时间了。如果再添加第四个 cpu 共享值为 1024 的容器，每个容器得到的 CPU 时间将重新计算。第一个容器的 CPU 时间变为 33%，其它容器分得的 CPU 时间分别为 16.5%、16.5%、33%。</p><div class="note note-warning">            <p>必须注意的是，这个比例只有在 CPU 密集型的任务执行时才有用。在四核的系统上，假设有四个单进程的容器，它们都能各自使用一个核的 100% CPU 时间，不管它们的 cpu 共享权值是多少。<br>在多核系统上，CPU 时间权值是在所有 CPU 核上计算的。即使某个容器的 CPU 时间限制少于 100%，它也能使用各个 CPU 核的 100% 时间。</p>          </div><p>例如，假设有一个不止三核的系统。用-c&#x3D;512 的选项启动容器{C0}，并且该容器只有一个进程，用-c&#x3D;1024 的启动选项为启动容器 C2，并且该容器有两个进程。CPU 权值的分布可能是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpu-shares=512 ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpu-shares=1024 ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/cpu/docker/&lt;容器的完整长ID&gt;/cpu.shares</span><br>PID    container    CPU CPU share<br>100    &#123;C0&#125;     0   100% of CPU0<br>101    &#123;C1&#125;     1   100% of CPU1<br>102    &#123;C1&#125;     2   100% of CPU2<br></code></pre></td></tr></table></figure><h3 id="设置容器运行存储介质"><a href="#设置容器运行存储介质" class="headerlink" title="设置容器运行存储介质"></a>设置容器运行存储介质</h3><p>Docker 中的数据可以存储在类似于虚拟机磁盘的介质中，在 Docker 中称为数据卷（Data Volume）。<br>数据卷可以将本地的磁盘数据和 docker 容器链接起来，使用容器的应用加载本地的数据，这样就很方便我们的开发。<br>而且可以保持数据持久化，当将容器删除时，数据不会丢失。<br><strong>文件系统挂载：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">-v, --volume=[host-src:]container-dest[:&lt;options&gt;]: 将宿主机src目录挂载到容器的dest.<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"># 在宿主机上创建一个临时目录/<span class="hljs-keyword">var</span>/lib/docker/volumes/[VOLUME_ID]/_data，<br># 然后把它挂载到容器的/test目录上<br>$ docker run -v /test<br><br># Docker 就直接把宿主机的/home目录挂载到容器的/test目录上<br>$ docker run -v /home:/test<br></code></pre></td></tr></table></figure><h2 id="start-x2F-stop-x2F-restart"><a href="#start-x2F-stop-x2F-restart" class="headerlink" title="start&#x2F;stop&#x2F;restart"></a>start&#x2F;stop&#x2F;restart</h2><p><strong>用途：</strong>启动一个已经停止的容器&#x2F;停止一个正在运行的容器&#x2F;重启一个停止或正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><code>docker start</code>支持容器<code>checkpoint</code>机制，但是该特性目前还是实验阶段，<a href="https://docs.docker.com/engine/reference/commandline/checkpoint/">详细点我可参考</a>。<br><strong>OPTIONS 参数：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"># docker stop 和restart 都支持该命令<br>--time , -t: docker默认会允许容器中的应用程序有Seconds秒的时间用以终止运行<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在 docker stop 命令执行的时候，会先向容器中 PID 为 1 的进程发送系统信号 SIGTERM，然后等待容器中的应用程序终止执行，如果等待时间达到设定的超时时间（默认的 10 秒），会继续发送 SIGKILL 的系统信号强行 kill 掉进程。在容器中的应用程序，可以选择忽略和不处理 SIGTERM 信号，不过一旦达到超时时间，程序就会被系统强行 kill 掉，因为 SIGKILL 信号是直接发往系统内核的，应用程序没有机会去处理它。</p>          </div><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name nginx-test -p 8080:80 -d nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                  NAMES<br>a16aad38955a   nginx     &quot;/docker-entrypoint.…&quot;   33 seconds ago   Up 26 seconds   0.0.0.0:8080-&gt;80/tcp   nginx-test<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -I http://localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.0<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop a16aad38955a</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart a16aad38955a</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart nginx-test</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">容器超时时间为20秒</span><br>docker stop --time=20 nginx-test<br></code></pre></td></tr></table></figure><h2 id="kill-立即停止容器中的主要进程"><a href="#kill-立即停止容器中的主要进程" class="headerlink" title="kill - 立即停止容器中的主要进程"></a>kill - 立即停止容器中的主要进程</h2><p><strong>用途：</strong>杀掉一个或多个正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--signal , -s:向需要被杀死的容器发送一个信号<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> --signal=SIGHUP my_container</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> --signal=HUP my_container</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> --signal=1 my_container</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>　 docker stop，支持“优雅退出”。先发送 SIGTERM 信号，在一段时间之后（10s）再发送 SIGKILL 信号。Docker 内部的应用程序可以接收 SIGTERM 信号，然后做一些“退出前工作”，比如保存状态、处理当前请求等。<br>　 docker kill，发送 SIGKILL 信号，应用程序直接退出，效果类似于 kill -9。</p>          </div><h2 id="rm-删除容器"><a href="#rm-删除容器" class="headerlink" title="rm - 删除容器"></a>rm - 删除容器</h2><p><strong>用途：</strong>删除一个或多个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--force , -f :通过 SIGKILL 信号强制删除一个运行中的容器。<br>--link , -l  :移除容器间的网络连接，而非容器本身。<br>--volumes , -v :删除与容器关联的卷。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">强制删除正在运行的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> --force nginx-test</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">被强制删除的容器重新启动就会报错</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start nginx-test</span><br>Error response from daemon: No such container: nginx-test<br>Error: failed to start containers: nginx-test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有已经停止的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> $(docker ps --filter status=exited -q)</span><br></code></pre></td></tr></table></figure><h2 id="pause-x2F-unpause"><a href="#pause-x2F-unpause" class="headerlink" title="pause&#x2F;unpause"></a>pause&#x2F;unpause</h2><p><strong>用途：</strong>暂停&#x2F;取消暂定 一个或多个容器中的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pause CONTAINER [CONTAINER...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker unpause CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">暂停后对外停止提供服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pause nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                   PORTS                  NAMES<br>284f70efc7fa   nginx     &quot;/docker-entrypoint.…&quot;   17 seconds ago   Up 16 seconds (Paused)   0.0.0.0:8080-&gt;80/tcp   nginx-test<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消暂停后服务正常访问</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker unpause nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -I http://localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.0<br><br></code></pre></td></tr></table></figure><h2 id="create-从镜像中创建一个容器"><a href="#create-从镜像中创建一个容器" class="headerlink" title="create - 从镜像中创建一个容器"></a>create - 从镜像中创建一个容器</h2><p><strong>用途：</strong>创建一个新的容器但不启动它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong><br>语法参数同<code>docker run</code>一致<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create --name nginx-temp -p 8080:80  nginx</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有容器，可以看到刚创建的容器为：Created状态</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a</span><br>CONTAINER ID   IMAGE  COMMAND                  CREATED         STATUS                        PORTS     NAMES<br>b353a6e76755   nginx  &quot;/docker-entrypoint.…&quot;   2 minutes ago   Created                                 nginx-temp<br></code></pre></td></tr></table></figure><h2 id="exec-在容器中执行指令"><a href="#exec-在容器中执行指令" class="headerlink" title="exec 在容器中执行指令"></a>exec 在容器中执行指令</h2><p><strong>用途：</strong>在一个正在运行的容器中执行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">--detach , -d  : 分离模式即在后台运行命令<br>--env , -e : 设置环境变量，传递进去<br>--env-file : 从文件中读取环境变量<br>--interactive  : -i 保持STDIN打开<br>--tty , -t : 分配一个伪终端（pseudo-TTY）<br>--user , -u : 进入容器后使用的用户(format: &lt;name|uid&gt;[:&lt;group|gid&gt;])<br>--workdir , -w : 进入到容器后的工作目录<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器，打开bash伪终端</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --name bash-dmeo bash</span><br>bash-5.1#<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开一个正在运行的容器的伪终端</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name nginx-demo -d nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it nginx-demo bash</span><br>root@0c0d174a92c3:/#<br></code></pre></td></tr></table></figure><h1 id="3-容器操作指令"><a href="#3-容器操作指令" class="headerlink" title="3. 容器操作指令"></a>3. 容器操作指令</h1><h2 id="ps-列出容器"><a href="#ps-列出容器" class="headerlink" title="ps 列出容器"></a>ps 列出容器</h2><p><strong>用途：</strong>列出容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps [OPTIONS]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">--all , -a :列表所以容器（默认只展示正在运行的容器）<br>--filter , -f :根据Filter的过滤条件列出容器，例如：--filter &quot;label=color&quot;<br>--format :使用Go template返回信息<br>--last , -n-1 :展示最近创建的容器 (includes all states)<br>--no-trunc :不断输出<br>--quiet , -q :只显示容器ID<br>--size , -s :显示总的文件大小<br></code></pre></td></tr></table></figure><p><strong>–filter：</strong>filter 支持非常丰富的过滤条件，例如：可根据 name、id、network、status 等条件进行过滤，详情参考<a href="https://docs.docker.com/engine/reference/commandline/ps/#filtering">这里</a>。<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES<br>0c0d174a92c3   nginx     &quot;/docker-entrypoint.…&quot;   8 minutes ago   Up 8 minutes   80/tcp    nginx-demo<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a</span><br>CONTAINER ID   IMAGE                COMMAND                  CREATED          STATUS                           PORTS     NAMES<br>0c0d174a92c3   nginx                &quot;/docker-entrypoint.…&quot;   8 minutes ago    Up 8 minutes                     80/tcp    nginx-demo<br>92508477a258   nginx                &quot;/docker-entrypoint.…&quot;   9 minutes ago    Exited (0) 9 minutes ago                   nginx-test<br>9b33c7ee242e   bash                 &quot;docker-entrypoint.s…&quot;   10 minutes ago   Exited (0) 9 minutes ago                   bash-dmeo<br>032e637b9351   bash                 &quot;docker-entrypoint.s…&quot;   10 minutes ago   Exited (0) 10 minutes ago                  nginx-dmeo<br>cf754da59266   registery/httpd:v1   &quot;/sbin/httpd -D FORE…&quot;   13 days ago      Exited (255) About an hour ago             funny_greider<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -q</span><br>0c0d174a92c3<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -s</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES        SIZE<br>0c0d174a92c3   nginx     &quot;/docker-entrypoint.…&quot;   8 minutes ago   Up 8 minutes   80/tcp    nginx-demo   1.17kB (virtual 142MB)<br></code></pre></td></tr></table></figure><h2 id="inspect-查看容器元数据"><a href="#inspect-查看容器元数据" class="headerlink" title="inspect - 查看容器元数据"></a>inspect - 查看容器元数据</h2><p><strong>用途：</strong>获取 Dock 对象的元数据信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--format , -f:根据Go template返回指定格式信息<br>--size , -s  :返回容器的总文件大小<br>--type:返回JSON格式数据<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">返回镜像信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect nginx</span><br>&#123;<br> ...<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回容器信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect nginx-demo</span><br>&#123;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="top-查看容器进程"><a href="#top-查看容器进程" class="headerlink" title="top 查看容器进程"></a>top 查看容器进程</h2><p><strong>用途：</strong>查看容器中正在运行的进程，支持 ps 命令参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top CONTAINER [ps OPTIONS]<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker top nginx-demo</span><br>UID    PID   PPID  C  STIME  TTY   TIME      CMD<br>root   4367  4342  0  02:37  ?     00:00:00  nginx: master process nginx -g daemon off;<br></code></pre></td></tr></table></figure><h2 id="attach-连接正在运行的容器"><a href="#attach-连接正在运行的容器" class="headerlink" title="attach 连接正在运行的容器"></a>attach 连接正在运行的容器</h2><p><strong>用途：</strong>attach 到正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name topdemo ubuntu /usr/bin/top -b</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker attach topdemo</span><br>top - 03:15:20 up  1:45,  0 users,  load average: 0.00, 0.00, 0.00<br>Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie<br><span class="hljs-meta prompt_">%</span><span class="language-bash">Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 <span class="hljs-built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br>MiB Mem :   7860.3 total,   6693.0 free,    264.3 used,    903.0 buff/cache<br>MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   7007.9 avail Mem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">C$</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Ctrl+C 后容器停止</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>docker exec 和 attach 区别：<br>docker exec 进入当前容器后开启一个新的终端，可以在里面操作(常用)，而且可以通过 exit 退出容器，不影响容器运行。<br>docker attach 进入容器正在执行某个命令的终端，不能在里面操作，而且会在输入 exit 后终止进程。</p>          </div><h2 id="events-获取服务器事件"><a href="#events-获取服务器事件" class="headerlink" title="events 获取服务器事件"></a>events 获取服务器事件</h2><p><strong>用途：</strong>从 server 获取实时事件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events [OPTIONS]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">--filter , -f :按照规则过滤事件<br>--since :从指定的时间戳后显示所有事件(e.g. 2013-01-02T13:23:37Z)<br>--until  :从指定的时间戳前显示所有事件(e.g. 2013-01-02T13:23:37Z)<br>--format :使用 Go template格式化输出<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示 --since=2013-01-02T13:23:37Z 之后的事件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --since=2013-01-02T13:23:37Z</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --since=1357104217</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示 --since=2013-01-02T13:23:37Z 之前的事件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --until=2013-01-02T13:23:37Z</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --until=1357104217</span><br></code></pre></td></tr></table></figure><p><strong>Evnent 事件说明：</strong><br><code>docker event</code> 支持包括：容器、镜像、Volumes、网络等众多事件监听，详细参考<a href="https://docs.docker.com/engine/reference/commandline/events/#description">这里</a>。<br>时间戳转换工具可以参考<a href="https://tool.lu/timestamp/">这里</a>。<br><strong>示例：</strong><br>启动两个终端，一个终端用于监听 server 事件，一个终端用于操作容器。<br>终端一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events</span><br>2022-06-27T11:23:00.611613795+08:00 image pull alpine:latest (name=alpine)<br>2022-06-27T11:23:00.655624589+08:00 container create db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test)<br>2022-06-27T11:23:14.126563376+08:00 network connect 165661d4b916af0ca8ca3726a1b3b093be145b436a37dbd2c88993eca7d9f8ec (container=db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8, name=bridge, type=bridge)<br>2022-06-27T11:23:14.368875149+08:00 container start db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test)<br>2022-06-27T11:23:22.589226178+08:00 container kill db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test, signal=15)<br>2022-06-27T11:23:22.616389983+08:00 container die db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (exitCode=143, image=alpine:latest, name=test)<br>2022-06-27T11:23:22.661571663+08:00 network disconnect 165661d4b916af0ca8ca3726a1b3b093be145b436a37dbd2c88993eca7d9f8ec (container=db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8, name=bridge, type=bridge)<br>2022-06-27T11:23:22.672498349+08:00 container stop db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test)<br><br><br></code></pre></td></tr></table></figure><p>终端二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create --name <span class="hljs-built_in">test</span> alpine:latest top</span><br>Unable to find image &#x27;alpine:latest&#x27; locally<br>latest: Pulling from library/alpine<br>2408cc74d12b: Pull complete<br>Digest: sha256:686d8c9dfa6f3ccfc8230bc3178d23f84eeaf7e457f36f271ab1acc53015037c<br>Status: Downloaded newer image for alpine:latest<br>db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start <span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><h2 id="logs-查看容器日志"><a href="#logs-查看容器日志" class="headerlink" title="logs 查看容器日志"></a>logs 查看容器日志</h2><p><strong>用途：</strong>展示容器日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs [OPTIONS] CONTAINER</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">--follow , -f:实时跟踪展示日志<br>--since :从指定的时间戳后显示所日志(e.g. 2013-01-02T13:23:37Z)<br>--until  :从指定的时间戳前显示所日志(e.g. 2013-01-02T13:23:37Z)<br>--tail , -n :展示最后Num条日志<br>--timestamps , -t :是否展示timestamps<br></code></pre></td></tr></table></figure><p>时间戳转换工具可以参考<a href="https://tool.lu/timestamp/">这里</a>。<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs --<span class="hljs-built_in">tail</span>=10 nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs --<span class="hljs-built_in">tail</span>=10 -t nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx-test --since=1656297419</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx-test --until=1656297419</span><br></code></pre></td></tr></table></figure><h2 id="wait-等待容器退出"><a href="#wait-等待容器退出" class="headerlink" title="wait 等待容器退出"></a>wait 等待容器退出</h2><p><strong>用途：</strong>阻塞运行直到容器停止，然后打印出它的退出代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">wait</span> CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong>需要两个终端，一个用于阻塞等待，一个用于退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">终端一</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">wait</span> nginx-test</span><br>0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">终端二</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop nginx-test</span><br>nginx-test<br></code></pre></td></tr></table></figure><h2 id="port-查看容器的端口映射"><a href="#port-查看容器的端口映射" class="headerlink" title="port 查看容器的端口映射"></a>port 查看容器的端口映射</h2><p><strong>用途：</strong>列出指定的容器的端口映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker port CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name portdemo -p 8080:80 -d nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -I http://localhost:8080</span><br>  HTTP/1.1 200 OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker port portdemo</span><br>80/tcp -&gt; 0.0.0.0:8080<br></code></pre></td></tr></table></figure><h2 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h2><h1 id="4-容器仓库指令"><a href="#4-容器仓库指令" class="headerlink" title="4. 容器仓库指令"></a>4. 容器仓库指令</h1><h2 id="login-登录仓库"><a href="#login-登录仓库" class="headerlink" title="login 登录仓库"></a>login 登录仓库</h2><p><strong>用途：</strong>登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库：<a href="https://www.docker.com/"> Docker Hub</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login [OPTIONS] [SERVER]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--username , -u:登录名<br>--password , -p:登录密码<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">登录本地仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login localhost:8080</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录Docker Hub</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login</span><br></code></pre></td></tr></table></figure><h2 id="logout-退出登录"><a href="#logout-退出登录" class="headerlink" title="logout 退出登录"></a>logout 退出登录</h2><p><strong>用途：</strong>用于仓库退出登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">logout</span> [SERVER]</span><br></code></pre></td></tr></table></figure><h2 id="pull-拉取镜像"><a href="#pull-拉取镜像" class="headerlink" title="pull 拉取镜像"></a>pull 拉取镜像</h2><p><strong>用途：</strong>从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--all-tags , -a:下载所以tagged的镜像<br>--disable-content-trust:跳过镜像包验证（默认值：true）<br>--platform:设置拉取镜像的平台<br>--quiet , -q:简化输出<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull mysql</span><br>Using default tag: latest<br></code></pre></td></tr></table></figure><h2 id="push-推送镜像"><a href="#push-推送镜像" class="headerlink" title="push 推送镜像"></a>push 推送镜像</h2><p><strong>用途：</strong>将本地的镜像上传到镜像仓库（需先登陆到镜像仓库）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push [OPTIONS] NAME[:TAG]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--all-tags , -a:推送所有tagged 镜像<br>--disable-content-trust:跳过镜像签名（默认值：true）<br>--quiet , -q:简化信息输出<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">要推送到对应的仓库上下文路径一定要跟DockerHub的信息对齐，否则将会推送失败</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag nginx:latest kissycn/nginx:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push kissycn/nginx:latest</span><br></code></pre></td></tr></table></figure><h2 id="search-搜索镜像"><a href="#search-搜索镜像" class="headerlink" title="search 搜索镜像"></a>search 搜索镜像</h2><p><strong>用途：</strong>搜索镜像仓库的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search [OPTIONS] TERM</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--filter , -f:按照过滤条件进行过滤<br>--format:按照Go template进行格式化输出<br>--limit25:搜索显示条数（默认值：25）<br>--no-trunc:显示完整的描述信息<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search busybox</span><br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索stars数量为3以上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --filter=stars=3 --no-trunc busybox</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索官网镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --filter is-official=<span class="hljs-literal">true</span> --filter stars=3 busybox</span><br></code></pre></td></tr></table></figure><p><strong>格式化示例：</strong><br>格式化输出支持：<code>.Name</code>、<code>.Description</code>、<code>.StarCount</code>、<code>.IsOfficial</code>、<code>.IsAutomated</code>这些字段，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --format <span class="hljs-string">&quot;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.StarCount&#125;&#125;: &#123;&#123;.IsOfficial&#125;&#125;&quot;</span> nginx</span><br>nginx: 16999: [OK]<br>linuxserver/nginx: 169:<br></code></pre></td></tr></table></figure><h1 id="5-容器-rootfs-指令"><a href="#5-容器-rootfs-指令" class="headerlink" title="5. 容器 rootfs 指令"></a>5. 容器 rootfs 指令</h1><h2 id="commit-新建镜像"><a href="#commit-新建镜像" class="headerlink" title="commit 新建镜像"></a>commit 新建镜像</h2><p><strong>用途：</strong>在一个镜像基础上通过 commits 信息创建一个新镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--author , -a :作者 (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)<br>--change , -c :使用Dockerfile创建镜像<br>--message , -m :Commit message<br>--pause , -p : 在commit过程中暂停镜像(Default:true)<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS         PORTS     NAMES<br>0c0d174a92c3   nginx     &quot;/docker-entrypoint.…&quot;   5 hours ago   Up 2 seconds   80/tcp    nginx-demo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过coommit在nginx-demo基础上新建一个镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker commit nginx-demo -m <span class="hljs-string">&quot;first commit&quot;</span> nginx-demo-commit:v1.0.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY          TAG       IMAGE ID       CREATED         SIZE<br>nginx-demo-commit   v1.0.0    09ca91406eb0   4 seconds ago   142MB<br></code></pre></td></tr></table></figure><h2 id="cp-容器与主机间数据拷贝"><a href="#cp-容器与主机间数据拷贝" class="headerlink" title="cp 容器与主机间数据拷贝"></a>cp 容器与主机间数据拷贝</h2><p><strong>用途：</strong>用于容器与主机之间的数据拷贝</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--archive , -a :允许拷贝将文件的uid/gid等信息<br>--follow-link , -L :Always follow symbol link in SRC_PATH<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从宿主机拷贝文件到容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> ./some_file CONTAINER:/work</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝完成后可以在容器里边查看</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it CONTAINER bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从容器拷贝数据到宿主机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> CONTAINER:/var/logs/ /tmp/app_logs</span><br></code></pre></td></tr></table></figure><h2 id="diff-比较容器版本差异"><a href="#diff-比较容器版本差异" class="headerlink" title="diff 比较容器版本差异"></a>diff 比较容器版本差异</h2><p><strong>用途：</strong>用于比较一个 Docker 容器不同版本提交的文件差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> docker diff CONTAINER</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">AA file or directory was added<br>DA file or directory was deleted<br>CA file or directory was changed<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker diff nginx-demo</span><br>C /etc<br>C /etc/nginx<br>C /etc/nginx/conf.d<br>C /etc/nginx/conf.d/default.conf<br>C /run<br>A /run/nginx.pid<br>C /tmp<br>A /tmp/raft.pdf<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a><br><a href="https://www.infoq.cn/article/s3qkg9lvbxplmaiqjame">https://www.infoq.cn/article/s3qkg9lvbxplmaiqjame</a><br><a href="https://cloud.tencent.com/developer/article/1426760">https://cloud.tencent.com/developer/article/1426760</a><br><a href="https://dockone.io/article/152">https://dockone.io/article/152</a><br><a href="https://mp.weixin.qq.com/s/lkUaWIRznOmHGVrbXVwlaQ">https://mp.weixin.qq.com/s/lkUaWIRznOmHGVrbXVwlaQ</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DockerCLI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、Dockerfile镜像指令</title>
    <link href="/2022/06/21/docker-file/"/>
    <url>/2022/06/21/docker-file/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>Dockerfile 最佳实践：</p><ol><li>使用小基础镜像(例：alpine)</li><li>RUN 指令中最好把所有 shell 命令都放在一起执行，减少 Docker 层</li><li>分阶段构建</li><li>最好声明 Docker 镜像签名</li><li>使用.dockerignore 排除不需要加入 Docker 镜像目录或者文件</li></ol>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"># stage <span class="hljs-number">1</span><br>FROM node:<span class="hljs-number">13.1</span><span class="hljs-number">.0</span>-alpine as builder<br><br>LABEL version=<span class="hljs-string">&quot;node 13.1.0&quot;</span><br><br># 修改alpine源为阿里源，安装tzdata包并修改为北京时间<br>RUN sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories \<br>    &amp;&amp; apk --update add --no-cache tzdata \<br>    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br># 声明环境变量<br>ENV NODE_ENV dev<br><br># 声明使用node用户<br>USER node<br><br># 首次只加入<span class="hljs-keyword">package</span>.json文件，<span class="hljs-keyword">package</span>.json一般不变，这样就可以充分利用Docker Cache，节约安装node包时间<br>COPY --chown=node:node <span class="hljs-keyword">package</span>.json /app &amp;&amp; npm ci<br><br># 声明镜像默认位置<br>WORKDIR /app<br><br># 加入node代码<br>ADD --chown=node:node . /app<br><br># build代码<br>RUN npm run build \<br>    &amp;&amp; mv dist public<br><br># stage <span class="hljs-number">2</span><br># 加入nginx镜像<br>FROM nginx:alpine<br><br># 拷贝上阶段build静态文件<br>COPY --from=builder /app/public /app/public<br><br># 拷贝nginx配置文件<br>COPY nginx.conf /etc/nginx/conf.d/<span class="hljs-keyword">default</span>.conf<br><br># 声明容器端口<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动命令<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure><p>Docker 通过读取<code>Dockerfile</code>来自动构建 Docker 镜像。<code>Dockerfile</code>是一个文本文件用来描述用于组装构建 Docker 镜像的命令，通过<code>docker build . </code>命令完成对 Dockerfile 的构建执行操作从而生成约定产物，形成镜像制品。</p><h1 id="1-Dockerfile-构建"><a href="#1-Dockerfile-构建" class="headerlink" title="1.Dockerfile 构建"></a>1.Dockerfile 构建</h1><h2 id="1-1-构建机制"><a href="#1-1-构建机制" class="headerlink" title="1.1 构建机制"></a>1.1 构建机制</h2><p>docker 构建一个镜像需要：<code>Dockerfile文件</code>、<code>构建所需的上下文</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br></code></pre></td></tr></table></figure><p>这条命令中，docker-cli 会:</p><ol><li>把当前目录及子目录当做上下文传递给 docker 服务</li><li>从当前目录(不包括子目录)中找到 Dockerfile</li><li>检查 Dockerfile 的语法</li><li>依次执行 Dockerfile 中的指令，根据指令生成中间过度镜像(存储在本地，为之后的指令或构建作缓存)</li></ol><div class="note note-warning">            <p>注意：为了加快构建速度，减少传递给 docker 服务的文件数量，最好将 Dockerfile 放在单独的空目录中。如果目录中含有大量文件，可以使用<code>.dockerignore</code>来忽略构建时用不到的文件，例如：</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"># comment<br>*/temp*<br>*<span class="hljs-comment">/*/temp*</span><br><span class="hljs-comment">temp?</span><br></code></pre></td></tr></table></figure><h2 id="1-2-镜像缓存机制"><a href="#1-2-镜像缓存机制" class="headerlink" title="1.2 镜像缓存机制"></a>1.2 镜像缓存机制</h2><p>当在构建或者下载镜像时候，当镜像层已经存在的时候则直接使用缓存， 不需要进行重新构建镜像，如果我们希望在构建镜像时不使用缓存，可以在 docker build 命令中加上<code>–no-cache</code>参数。如果我们改变 Dockerfile 指令的执行顺序，或者修改或添加指令，都会使缓存失效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build --no-cache=true ... # --no-cache：不使用缓存，每条指令都重新生成镜像<br></code></pre></td></tr></table></figure><p>Dockerfile 在执行的时候，当有执行过相同的代码并且顺序也一致的情况下，就会使用缓存镜像层进行构建新的镜像。Dockerfile 中每一个指令都会创建一个镜像层，上层是依赖于下层的。</p><div class="note note-warning">            <p>缓存失效：简单来说就是如果第 n 层有改动，则 n 层以后的缓存都会失效，大多数情况下判断有无改动的方法是判断这层的指令和缓存中的构建指令是否一致，但是对于 COPY 和 ADD 命令会计算镜像内的文件和构建目录文件的校验和然后做比较来判断本层是否有改动。</p>          </div><h2 id="1-3-格式要求"><a href="#1-3-格式要求" class="headerlink" title="1.3 格式要求"></a>1.3 格式要求</h2><ul><li>虽然 Dockerfile 并不区分大小写，但还是约定指令使用大写。</li><li>Dockerfile 的第一条可执行指令必须是 FROM。</li><li>以#开头的是注释，行内的#都被当做参数，并且不支持续行。</li></ul><h1 id="2-Dockerfile-指令"><a href="#2-Dockerfile-指令" class="headerlink" title="2.Dockerfile 指令"></a>2.Dockerfile 指令</h1><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建，常用的指令如下：</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><strong>用途：构建的镜像继承自某个 base image</strong>。FROM 指令必须是 Dockerfile 的第一个指令，可以使用多次来构建多个镜像，以最后一个镜像的 ID 为输出值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]<br>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]<br>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>platform：</strong>用于标识 Docker 镜像平台架构，例如：<code>linux/amd64</code>、<code>linux/arm64</code>或<code>windows/amd64</code></li><li><strong>tag：</strong>镜像标签，默认为<code>latest</code>。如果无法找到该 tag 值，构建器将返回错误。</li><li><strong>digest：</strong>可寻址标识符，镜像的二进制 ID，主要用于验证所下载镜像的<code>完整性</code>和<code>防篡改性</code>。</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p><strong>用途：</strong>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">RUN &lt;command&gt; # shell 格式<br>RUN [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br></code></pre></td></tr></table></figure><p><strong>使用原则：</strong></p><ul><li>尽量减少一个 Dockerfile 中的 RUN 命令的个数。<strong>RUN 命令在构建时会创建一个新层，如非特殊的需要，建议一个 Dockerfile 在需要使用 RUN 命令的时候尽可能的只用一个 RUN 命令，将多条 RUN 命令进行合并可以有效降低构建的镜像的层数</strong>。</li><li>使用&amp;&amp;连接多条命令，例如：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN apt-get update &amp;&amp; apt-get install -y \<br>package-bar\<br>package-baz \<br>package-foo<br></code></pre></td></tr></table></figure><ul><li>避免复杂的逻辑实现</li></ul><p><strong>关于缓存失效：</strong></p><div class="note note-warning">            <p> 在通常情况下，构建镜像后，所有的层都在 Docker 缓存中，假设后来又修改了其中的 apt-get install 命令，在添加一个包时， Docker 发现修改后的 RUN apt-get update 命令和之前的完全一样。<br>这时，不会执行 RUN apt-get update 命令，而是使用之前的缓存镜像。因为 RUN apt-get update 命令没有执行，后面的 apt-get install 命令安装的可能是过期的软件版本或提示没有可用源。<br>使用 RUN apt-get update &amp;&amp; apt-get install -y 命令可以确保 Dockerfiles 配置文件每次安装的都是包的最新版本，而且这个过程不需要进一步编码或额外干预 ，这项技术叫作缓存破坏( Cache Busting ）。</p>          </div><h3 id="MAINTAINER-deprecated"><a href="#MAINTAINER-deprecated" class="headerlink" title="MAINTAINER (deprecated)"></a>MAINTAINER (deprecated)</h3><p>已废弃，使用 LABEL 命令代替。</p><h3 id="ADD-amp-amp-COPY"><a href="#ADD-amp-amp-COPY" class="headerlink" title="ADD &amp;&amp; COPY"></a>ADD &amp;&amp; COPY</h3><p><strong>用途：</strong>ADD 和 COPY 命令都是在构建镜像时， <strong>将 src 路径复制新文件、目录或远程文件 URL，并将它们添加到图像的文件系统中 dest</strong>，但一般优先使用 COPY 命令，因为 ADD 命令比 COPY 命令更加透明。ADD 相较于 COPY 除了支持从本地复制文件到镜像，ADD 指令还支持通过 URL 从远程服务器读取资源并复制到镜像中。</p><div class="note note-success">            <p>事实上当要从远程获取资源的时候推荐使用 RUN 命令：<code>RUN wget</code>或<code>RUN curl</code>，而 ADD 指令更擅长读取本地 tar 文件并解压缩 </p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]<br><br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>chown&#x3D;user:group：</strong>当执行 ADD、COPY 指令时源文件的各种元数据都会保留，比如读、写、执行权限、文件变更时间等，可以通过 <code>--chown=&lt;user&gt;:&lt;group&gt; </code>选项来改变文件的所属用户及所属组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD/COPY --chown=<span class="hljs-number">55</span>:mygroup files* /somedir/<br>ADD/COPY --chown=bin files* /somedir/<br>ADD/COPY --chown=<span class="hljs-number">1</span> files* /somedir/<br>ADD/COPY --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* /somedir/<br></code></pre></td></tr></table></figure><ul><li><strong>src：</strong>拷贝源文件路径，src 可以使用通配符，将使用 Go 的 <a href="https://pkg.go.dev/path/filepath#Match">filepath.Match</a> 规则匹配完成。例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD hom* /mydir/<br>ADD hom?.txt /mydir/<br></code></pre></td></tr></table></figure><ul><li><strong>dest：</strong>拷贝到镜像的目标路径，可以是容器内的绝对路径，也可以是工作目录相对路径（工作目录可以用 WORKDIR 指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li></ul><h3 id="CMD-amp-amp-ENTRYPOINT"><a href="#CMD-amp-amp-ENTRYPOINT" class="headerlink" title="CMD &amp;&amp; ENTRYPOINT"></a>CMD &amp;&amp; ENTRYPOINT</h3><p><strong>用途：</strong>CMD 命令和 ENTRYPOINT 命令部可以用于设置容器启动时要执行的命令， Dockerfile 置文件中 CMD 或 ENTRYPOINT 必须至少有其一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">CMD [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br>CMD command param1 param2  # shell格式<br>CMD [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]  # exec参数，用来为ENTRYPOINT 提供参数<br><br>ENTRYPOINT [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br>ENTRYPOINT command param1 param2 # shell格式<br>## 例如：<br>CMD java -jar demo.jar<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;demo.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>ENTRYPOINT</code>应该被当做 docker 的可执行程序，<code>CMD</code>应该被当做<code>ENTRYPOINT</code>的默认参数。<br><code>docker run &lt;image&gt; &lt;arg1&gt; &lt;arg2&gt; ...</code>会把之后的参数传递给<code>ENTRYPOINT</code>，覆盖 CMD 指定的参数。可以用<code>docker run --entrypoint</code>来重置默认的 ENTRYPOINT，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/iam/bin/iam-apiserver&quot;</span>]</span><br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;/etc/iam/iam-apiserver.yaml&quot;</span>]</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>与 RUN 命令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD、ENTRYPOINT 在容器运行的时候执行，在构建时不进行任何操作。</p>          </div><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p><strong>用途：</strong>镜像打标签</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>如果 base image 中也有标签，则继承，如果是同名标签，则覆盖。</li><li>为了减少图层数量，尽量将标签写在一个 LABEL 指令中去，如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">LABEL multi.label1=<span class="hljs-string">&quot;value1&quot;</span> \<br>      multi.label2=<span class="hljs-string">&quot;value2&quot;</span> \<br>      other=<span class="hljs-string">&quot;value3&quot;</span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><strong>用途：</strong>为构建的镜像设置监听端口，使容器在运行时监听。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>EXPOSE 指令并不会让容器监听 Host 的端口，如果需要，需要在 docker run 时使用-p 参数来发布容器端口到 Host 的某个端口上。</p>          </div><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><strong>用途：</strong>在构建的镜像中设置环境变量，在后续的 Dockerfile 指令中可以直接使用，也可以固化在镜像里，在容器运行时仍然有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ENV &lt;key&gt; &lt;value&gt;<br>ENV &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>ENV key value：把第一个空格之后的所有值都当做<key>的值，无法在一行内设定多个环境变量。</li><li>ENV key&#x3D;value …：可以设置多个环境变量，如果<value>中存在空格，需要转义或用引号”括起来。</li></ul><div class="note note-success">            <p>可以在容器运行时指定环境变量，替换镜像中的已有变量，docker run –env key&#x3D;value<br>推荐使用在一行中写多个环境变量，减少图层</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ENV myName=<span class="hljs-string">&quot;John Doe&quot;</span> \<br>    myDog=Rex\ The\ Dog \<br>    myCat=fluffy<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><strong>用途：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">VOLUME [<span class="hljs-string">&quot;/data&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><strong>用途：</strong>为接下来的 Dockerfile 指令指定当前工作目录，可多次使用，如果使用的是相对路径，则相对的是上一个工作目录，类似 shell 中的 cd 命令。<br>影响的指令有：<code>RUN、CMD、ENTRYPOINT、COPY和ADD。</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">WORKDIR /path/to/workdir<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>建议使用 WORKDIR 命令来代替类似于 RUN cd … &amp;&amp; do -something 等的命令，因为后者难以阅读维护</p>          </div><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><strong>用途： <strong>设置镜像构建时的环境变量，使用效果 ENV 一样。所不同的是，</strong>ARG 所设置环境变量生命周期仅在镜像构建期间</strong>，在将来容器运行时是不会存在这些环境变量的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ARG &lt;name&gt;[=&lt;<span class="hljs-keyword">default</span> value&gt;]<br></code></pre></td></tr></table></figure><p><strong>使用方法：</strong><br>当 Dockerfile 指定 ARG 参数时可通过<code>docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code>传入参数值进行覆盖。<br>docker 内置了一批构建参数，可以不用在 Dockerfile 中声明：<code>HTTP_PROXY、http_proxy、HTTPS_PROXY、https_proxy、FTP_PROXY、ftp_proxy、NO_PROXY、no_proxy</code></p><h3 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h3><p><strong>用途：</strong>创建一个可以从<strong>本地主机</strong>或<strong>其它容器挂载</strong>的挂载点，用来保持数据不被销毁。Volume 可以在容器之间以及容器和主机之间共享和重用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 命令会将&quot;/data&quot;目录挂载到容器 ，开发人员可以在宿主机上直接操作该目录，</span><br><span class="hljs-comment"># 任何在该镜像&quot;/data&quot;目录中的文件都将被复制到 Volume中。</span><br>docker run -it --name container-test -h CONTAINER -v <span class="hljs-regexp">/data nginx /</span>bin/bash<br><span class="hljs-comment"># 可以找到容器与宿主机的挂载关系</span><br>docker inspect -f &#123;&#123;.Volumes&#125;&#125; container-test<br><span class="hljs-comment"># 在宿主机的目录下创建一个文件，然后进入容器的/data目录下会相应看到创建的文件</span><br>sudo touch <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>vfs<span class="hljs-regexp">/dir/</span>cde1671***<span class="hljs-number">37</span>a9/test-file<br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>和 Linux 不同，在 mac 上用 docker 会在 mac 上启动一个虚拟机运行 docker，因此 volume 创建的 directory 并不在你的 machine 上，而是在虚拟机中。</p>          </div><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><strong>用途：</strong>向镜像中添加一个触发器，当以该镜像为 base image 再次构建新的镜像时，会触发执行其中的指令。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ONBUILD</span><span class="hljs-meta"> [INSTRUCTION]</span><br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 在下一次以此镜像为base image的构建中，执行ADD . /app/src，将项目代目添加到新镜像中去</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="language-bash"> . /app/src</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>ONBUILD 只会继承给子节点的镜像，不会再继承给孙子节点。<br>ONBUILD ONBUILD 或者 ONBUILD FROM 或者 ONBUILD MAINTAINER 是不允许的。</p>          </div><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><strong>用途：</strong>增加自定义的心跳检测功能，多次使用只有最后一次有效。格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [OPTION] CMD &lt;<span class="hljs-built_in">command</span>&gt;  <span class="hljs-comment"># 通过在容器内运行command来检查心跳</span></span><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> NONE                    <span class="hljs-comment"># 取消从base image继承来的心跳检测</span></span><br></code></pre></td></tr></table></figure><p><strong>可选的 OPTION：</strong><br><code>--interval=DURATION：</code>检测间隔，默认 30 秒；<br><code>--timeout=DURATION：</code>命令超时时间，默认 30 秒；<br><code>--retries=N：</code>连续 N 次失败后标记为不健康，默认 3 次；<br><command>可以是 shell 脚本，也可以是 exec 格式的 json 数组。<br>docker 以<command>的退出状态码来区分容器是否健康，这一点同 shell 一致：</p><ul><li>0：命令返回成功，容器健康</li><li>1：命令返回失败，容器不健康</li><li>2：保留状态码，不要使用&#96;</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 每5分钟检测本地网页是否可访问，超时设为3秒：</span><br>HEALTHCHECK --interval=<span class="hljs-number">5</span>m --timeout=<span class="hljs-number">3</span>s \<br>    CMD curl -f http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用途：指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。<strong>容器不推荐使用 root 权限。</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">&lt;user</span>&gt;[:<span class="hljs-tag">&lt;group&gt;</span>]<br><span class="hljs-comment"># 声明使用node用户</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">node</span><br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/qianlei90/Blog/issues/35">https://github.com/qianlei90/Blog/issues/35</a><br><a href="https://segmentfault.com/a/1190000018222648">https://segmentfault.com/a/1190000018222648</a><br><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">https://docs.docker.com/engine/reference/builder/#dockerignore-file</a><br><a href="https://mp.weixin.qq.com/s/vjD-JDw_2bYWa2InUfWHow">https://mp.weixin.qq.com/s/vjD-JDw_2bYWa2InUfWHow</a><br><a href="https://mp.weixin.qq.com/s/ojZvxQTssqERueGahFGCbQ">https://mp.weixin.qq.com/s/ojZvxQTssqERueGahFGCbQ</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dockerfile</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、Docker入门基础</title>
    <link href="/2022/06/20/docker-startup/"/>
    <url>/2022/06/20/docker-startup/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一个“容器”，实际上是一个由 <code>Linux Namespace</code>、<code>Linux Cgroups </code>和 <code>rootfs</code>三种技术构建出来的进程的隔离环境。一个正在运行的 Linux 容器，其实可以被“一分为二”地看待：</p><ul><li>一组联合挂载在 <code>/var/lib/docker/aufs/mnt</code> 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</li><li>一个由<code>Namespace+Cgroups</code>构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</li></ul><div class="note note-success">            <p>关于容器背景的几个知识点：</p><ul><li>容器技术的兴起源于 PaaS 技术的普及；</li><li>Docker 公司发布的 Docker 项目具有里程碑式的意义，Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。</li><li>容器本身没有价值，有价值的是“容器编排”。</li></ul>          </div><div class="note note-success">            <p>关于容器标准的背景知识：<br>2015 年 6 月 22 日，由 Docker 公司牵头，CoreOS、Google、RedHat 等公司共同宣布，Docker 公司将 Libcontainer 捐出，并改名为 RunC 项目，交由一个完全中立的基金会管理，然后以 RunC 为依据，大家共同制定一套容器和镜像的标准和规范。这套标准和规范，就是 OCI（ Open Container Initiative ）。</p><p>OCI 的提出，意在将容器运行时和镜像的实现从 Docker 项目中完全剥离出来。这样做，一方面可以改善 Docker 公司在容器技术上一家独大的现状，另一方面也为其他玩家不依赖于 Docker 项目构建各自的平台层能力提供了可能。</p>          </div><h1 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2. Docker 安装"></a>2. Docker 安装</h1><p>Docker 安装非常方便，支持 Ubuntu、RHEL、CentOS、Debian 等 Linux 发行版，同时也可以在 OSX 、Microsoft Windows 等非 Linux 平台下安装使用。<br>各平台安装情况参见官网：<a href="https://docs.docker.com/desktop/mac/install/">Mac</a>、<a href="https://docs.docker.com/desktop/windows/install/">Windows</a>、<a href="https://docs.docker.com/desktop/linux/install/">Linux</a>。本文以 Centos7.x 安装任意版本为例。<br><strong>步骤一、卸载原有平台</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum remove docker\</span><br><span class="language-bash">           docker-client\</span><br><span class="language-bash">           docker-client-latest\</span><br><span class="language-bash">           docker-common\</span><br><span class="language-bash">           docker-latest\</span><br><span class="language-bash">           docker-latest-logrotate\</span><br><span class="language-bash">           docker-logrotate\</span><br><span class="language-bash">           docker-engine</span><br></code></pre></td></tr></table></figure><p><strong>步骤二、安装 Docker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装yum源工具包</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum -y install yum-utils</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加Docker源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum-config-manager\</span><br><span class="language-bash"> --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure><p>大多数情况下，可以直接安装最新版本的 Docker ，因为最新版本的 Docker 有着更好的稳定性和安全性。但是有时候需要与其他生态软件进行兼容或者其他原有需要按照制定版本 Docker 时就需要进行选择性安装了，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">直接安装最新版本</span><br>yum install docker-ce docker-ce-cli containerd.io<br><span class="hljs-meta prompt_"># </span><span class="language-bash">展示各个版本Docker</span><br>yum list docker-ce --showduplicates | sort -r<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装指定版本Docker</span><br>yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io<br></code></pre></td></tr></table></figure><p><strong>步骤三、启动并运行测试容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl start docker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看运行状态</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl status docker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行测试容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br>docker run hello-world<br>Unable to find image &#x27;hello-world:latest&#x27; locally<br>latest: Pulling from library/hello-world<br>2db29710123e: Pull complete<br>Digest: sha256:13e367d31ae85359f42d637adf6da428f76d75dc9afeb3c21faea0d976f5c651<br>Status: Downloaded newer image for hello-world:latest<br><br>Hello from Docker!<br>...<br></code></pre></td></tr></table></figure><h1 id="3-Docker-组件"><a href="#3-Docker-组件" class="headerlink" title="3. Docker 组件"></a>3. Docker 组件</h1><h2 id="3-1-Docker-五大组件"><a href="#3-1-Docker-五大组件" class="headerlink" title="3.1 Docker 五大组件"></a>3.1 Docker 五大组件</h2><p>如下所示，Docker 一共包含了：<code>DockerClient</code>、<code>Deamon</code>、<code>Images</code>、<code>Containers</code>、<code>Registry</code>等五大组件。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FqLhkrp10MdxxXrVSrOcYtdkYmBm.png"></p><h3 id="3-1-1-DockerClient"><a href="#3-1-1-DockerClient" class="headerlink" title="3.1.1 DockerClient"></a>3.1.1 DockerClient</h3><p><code>docker client</code> 是 docker 架构中用户用来和<code>docker daemon</code>建立通信的客户端，用户使用的可执行文件为 docker，通过 docker 命令行工具可以发起众多管理 container 的请求。</p><p>docker client 可以通过一下三种方式和 docker daemon 建立通信：<br><code>tcp://host:port</code>、<code>unix:path_to_socket</code>、<code>fd://socketfd</code> docker client 可以通过设置命令行 flag 参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。</p><p>docker client 发送容器管理请求后，由 docker daemon 接受并处理请求，当 docker client 接收到返回的请求相应并简单处理后，docker client 一次完整的生命周期就结束了，当需要继续发送容器管理请求时，用户必须再次通过 docker 可以执行文件创建 docker client。</p><h3 id="3-1-2-Docker-Server"><a href="#3-1-2-Docker-Server" class="headerlink" title="3.1.2 Docker Server"></a>3.1.2 Docker Server</h3><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/Fr9G30D_YuNcUoMYPV26jSNM6NOW.png"></p><ol><li><strong>Docker Daemon（dockerd），</strong>作为 Docker 架构中的主体部分，常处于后台的系统进程中用于提供 Docker Server 功能，接收并处理 Docker Client 的请求，并将相应的容器操作请求通过 gRPC 转发到<code>containerd</code>。</li><li><strong>containerd：</strong> 是 Docker 服务端的一个核心组件，它是 Docker1.11 版本从<code>dockerd</code>中剥离出来的 ，它的诞生完全遵循 <code>OCI</code>标准，是容器标准化后的产物。<code>containerd</code>通过<code>containerd-shim</code>启动并管理<code>runC</code>，可以说<code>containerd</code>真正管理了容器的生命周期。</li></ol><div class="note note-info">            <p>containerd 不仅负责容器生命周期的管理，同时还负责一些其他的功能：</p><ul><li>镜像的管理，例如容器运行前从镜像仓库拉取镜像到本地；</li><li>接收 dockerd 的请求，通过适当的参数调用 runc 启动容器；</li><li>管理存储相关资源；</li><li>管理网络相关资源；</li></ul>          </div><ol start="3"><li><strong>containerd-shim：</strong>  的意思是垫片，类似于拧螺丝时夹在螺丝和螺母之间的垫片。containerdshim  的主要作用是将  <code>containerd</code>和<code>真正的容器进程</code>解耦，使用  containerd-shim  作为容器进程的父进程，从而实现重启  dockerd  不影响已经启动的容器进程。</li><li><strong>runC</strong>：是 Docker 官方按照 OCI 容器运行时标准的一个实现。通俗地讲，runC 是一个用来运行容器的轻量级工具，是真正用来运行容器的。</li><li><strong>docker-proxy：</strong>主要是用来做端口映射。当我们使用<code>docker run</code>命令启动容器时，如果使用了-p 参数，<code>docker-proxy</code>组件就会把容器内相应的端口映射到主机上来，底层是依赖于<code>iptables</code>实现的。</li></ol><h3 id="3-1-3-Images"><a href="#3-1-3-Images" class="headerlink" title="3.1.3 Images"></a>3.1.3 Images</h3><p>简单地理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。</p><div class="note note-success">            <p>一般而言， Linux 分为两个部分：Linux 内核（Linux Kernel）与用户空间，而真正的 Linux 操作系统，是指 Linux 内核，我们常用的 Ubuntu、CentOS 等操作系统其实是不同厂商在 Linux 内核基础上添加自己的软件与工具集（tools）形成的发布版本（Linux Distribution）。</p><p>因此，我们也可以把镜像看成是上面所说的用户空间，当 Docker 通过镜像创建一个容器时，就是将镜像定义好的用户空间作为独立隔离的进程运行在宿主机的 Linux 内核之上。</p>          </div><p>这里要强调一下镜像的两个特征：</p><ul><li><strong>镜像是分层（Layer）的：</strong>即一个镜像可以多个中间层组成，多个镜像可以共享同一中间层，我们也可以通过在镜像添加多一层来生成一个新的镜像。</li><li><strong>镜像是只读的（read-only）：</strong>镜像在构建完成之后，便不可以再修改，而上面我们所说的添加一层构建新的镜像，这中间实际是通过创建一个临时的容器，在容器上增加或删除文件，从而形成新的镜像，因为容器是可以动态改变的。</li></ul><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FrWYT83vgb0zaKf0LUBZdbpfydPE.png"></p><h3 id="3-1-4-Containers"><a href="#3-1-4-Containers" class="headerlink" title="3.1.4 Containers"></a>3.1.4 Containers</h3><p>容器与镜像的关系，就如同面向编程中对象与类之间的关系。</p><p>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立于宿主机的隔离进程，并且有属于容器自己的网络和命名空间。</p><p>我们前面介绍过，<strong>镜像由多个中间层（layer）组成，生成的镜像是只读的，但容器却是可读可写的，这是因为容器是在镜像上面添一层读写层（writer&#x2F;read layer）来实现的</strong>，如下图所示：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FtBUiM6gDYUaT4dsEf0lWgdCtbSg.png"><br><strong>容器生命周期：</strong><br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FvZTtx10yKfKsNr_UaYQQUauTpGl.png"></p><h3 id="3-1-5-Registry"><a href="#3-1-5-Registry" class="headerlink" title="3.1.5 Registry"></a>3.1.5 Registry</h3><p>仓库（Repository）是集中存储镜像的地方，这里有个概念要区分一下，那就是仓库与仓库服务器(Registry)是两回事，像我们上面说的 Docker Hub，就是 Docker 官方提供的一个仓库服务器，不过其实有时候我们不太需要太过区分这两个概念。</p><ul><li><strong>公共仓库</strong></li></ul><p>公共仓库一般是指<a href="https://hub.docker.com/">Docker Hub</a>，前面我们已经多次介绍如何从 Docker Hub 获取镜像，除了获取镜像外，我们也可以将自己构建的镜像存放到 Docker Hub，这样，别人也可以使用我们构建的镜像。</p><ul><li><strong>私有仓库</strong></li></ul><p>虽然 Docker 官方提供了公共的镜像仓库，但是从安全和效率等方面考虑，部署我们私有环境内的 Registry 也是非常必要的。</p><p><a href="https://github.com/goharbor/harbor">Harbor</a>是由 VMware 公司开源的企业级的 Docker Registry 管理项目，相比 docker 官方拥有更丰富的权限权利和完善的架构设计，适用大规模 docker 集群部署提供仓库服务。<br>它主要提供 Dcoker Registry 管理界面 UI，可基于角色访问控制,镜像复制， AD&#x2F;LDAP 集成，日志审核等功能，完全的支持中文。</p><h3 id="3-1-6-volume"><a href="#3-1-6-volume" class="headerlink" title="3.1.6 volume"></a>3.1.6 volume</h3><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FkAvpjBkuMyj4_cjwT5Jkg9wxio1.png"><br>Data Volumes 可以视为容器中的一种特殊的文件路径，用于保存与容器实例生命周期无关的共享数据，它可以存放在一个或多个容器内特定的目录下，提供独立于容器的持久化存储。<br>Data Volumes 是经过特殊设计的目录，可以绕过 UnionFS ( Union File System，联合文件系统 ），为一个或多个容器提供访问，从而实现容器间的数据共享，它有如下几个特性：</p><ol><li>在容器创建时初始化</li><li>作为文件系统的一部分，但是不受 UnionFS 的管理</li><li>便于持久化存储数据和共享数据。</li><li>Data Volumes 的数据是持久化的，删除容器不影响 Data Volumes 的数据。</li><li>对 Data Volumes 的操作会立刻生效</li></ol><h1 id="4-Docker-实现原理简介"><a href="#4-Docker-实现原理简介" class="headerlink" title="4. Docker 实现原理简介"></a>4. Docker 实现原理简介</h1><h2 id="4-1-chroot（根文件系统）"><a href="#4-1-chroot（根文件系统）" class="headerlink" title="4.1 chroot（根文件系统）"></a>4.1 chroot（根文件系统）</h2><p>提起容器就不得不说<code>chroot</code>，因为<code>chroot</code>是最早的容器雏形。<code>chroot</code>意味着切换根目录，有了<code>chroot</code>就意味着我们可以把任何目录更改为当前进程的根目录，这与容器非常相似。</p><div class="note note-info">            <p><code>chroot</code>是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由<code>chroot</code>设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p>          </div><p>简单来说就是，<strong>chroot 就是可以改变某进程的根目录，使这个程序不能访问目录之外的其他目录。</strong><br>chroot 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">步骤一：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前命令常见一个rootfs目录</span><br>mkdir -p /home/rootfs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为了方便演示，使用现成的 busybox 镜像来创建一个系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令用于创建一个busybox的容器，并将之导出到当前目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样做的目的时为了得到一个可运行的操作系统目录文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> $(docker create busybox) -o busybox.tar</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf busybox.tar</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>bin  busybox.tar  dev  etc  home  proc  root  sys  tmp  usr  var<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">步骤二：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 rootfs 目录下初始化了一些目录，下面让我们通过一条命令来见证 <span class="hljs-built_in">chroot</span> 的神奇之处。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用以下命令，可以启动一个 sh 进程，并且把 /home/centos/rootfs 作为 sh 进程的根目录。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chroot</span> /home/rootfs /bin/sh</span><br>/ #<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时，我们的命令行窗口已经处于上述命令启动的 sh 进程中。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前sh命令行窗口下，我们使用<span class="hljs-built_in">ls</span>命令查看一下当前进程，看是否真的与主机上的其他目录隔离开了</span><br>/ # /bin/ls /<br>bin  busybox.tar  dev  etc  home  proc  root  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p>这里可以看到：当前进程的根目录已经变成了主机上的<code>/home/rootfs</code> 目录。这样就实现了当前进程与主机的隔离。更重要的是，对于被 chroot 的进程来说，它并不会感受到自己的根目录已经被“修改”成 <code>$HOME/rootfs</code>。</p><div class="note note-warning">            <p>注意：rootfs 只是一个操作系统所包含的<strong>文件</strong>、<strong>配置</strong>和<strong>目录</strong>，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p><p>实际上，<strong>同一台机器上的所有容器，都共享宿主机操作系统的内核。</strong><br>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：<strong>这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身</strong>。</p>          </div><p>到此为止，一个目录隔离的容器就完成了。虽然使用了 chroot 完成了对资源目录的隔离，但是还不能完整的称之为时一个容器，因为他的进程网络等信息还未隔离，要实现一个完整的容器还需要依靠 Linux 的其他三项技术： <strong>Namespace</strong>、<strong>Cgroups</strong> 和<strong>UnionFS</strong></p><h2 id="4-2-Namespace"><a href="#4-2-Namespace" class="headerlink" title="4.2 Namespace"></a>4.2 Namespace</h2><p>Namespace 是 Linux 内核的一项功能，该功能对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行，并且只可以访问当前容器命名空间的资源。Namespace 可以隔离进程 ID、主机名、用户 ID、文件名网络访问和进程间通信等相关资源。Docker 主要用到以下五种命名空间：</p><ul><li><strong>pid namespace</strong>：用于隔离进程 ID。</li><li><strong>net namespace</strong>：隔离网络接口，在虚拟的<code>net namespace</code>内用户可以拥有自己独立的<code>IP</code>、<code>路由</code> 、<code>端口</code>等。</li><li><strong>mnt namespace</strong>：文件系统挂载点隔离。</li><li><strong>ipc namespace</strong>：信号量, 消息队列和共享内存的隔离。</li><li><strong>uts namespace</strong>：主机名和域名的隔离。</li></ul><h2 id="4-3-Cgroups"><a href="#4-3-Cgroups" class="headerlink" title="4.3 Cgroups"></a>4.3 Cgroups</h2><p>Cgroups 是一种 Linux 内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘 I&#x2F;O、网络等）。在容器的实现中，Cgroups 通常用来限制容器的 CPU 和内存等资源的使用。</p><h2 id="4-4-联合文件系统"><a href="#4-4-联合文件系统" class="headerlink" title="4.4 联合文件系统"></a>4.4 联合文件系统</h2><p>联合文件系统，又叫 UnionFS，是一种通过创建文件层进程操作的文件系统，因此，联合文件系统非常轻快。Docker 使用联合文件系统为容器提供构建层，使得容器可以实现写时复制以及镜像的分层构建和存储。常用的联合文件系统有：<strong>AUFS</strong>、<strong>Overlay</strong> 和 <strong>Devicemapper</strong> 等。</p><h1 id="5-Docker-与虚拟机的区别"><a href="#5-Docker-与虚拟机的区别" class="headerlink" title="5. Docker 与虚拟机的区别"></a>5. Docker 与虚拟机的区别</h1><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/Fgb7PBydkArUlGLbL4c194bMrCGD.png"><br><strong>虚拟机：</strong>是通过管理系统 (Hypervisor) 模拟出 CPU、内存、网络等硬件，然后在这些模拟的硬件上创建客户内核和操作系统。这样做的好处就是虚拟机有自己的内核和操作系统，并且硬件都是通过虚拟机管理系统模拟出来的，用户程序无法直接使用到主机的操作系统和硬件资源，因此虚拟机也对隔离性和安全性有着更好的保证。</p><p><strong>Docker 容器：</strong>则是通过 Linux 内核的 Namespace 技术实现了文件系统、进程、设备以及网络的隔离，然后再通过 Cgroups 对 CPU、 内存等资源进行限制，最终实现了容器之间相互不受影响，由于容器的隔离性仅仅依靠内核来提供，因此容器的隔离性也远弱于虚拟机。</p><p>但是，容器的性能损耗非常小，并且镜像也非常小，而且在业务快速开发和迭代的今天，容器秒级的启动等特性也非常匹配业务快速迭代的业务场景。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://dockone.io/article/9249">http://dockone.io/article/9249</a><br><a href="https://i4t.com/4248.html">https://i4t.com/4248.html</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Notion+Hexo+Github搭建技术博客</title>
    <link href="/2022/06/19/notion-hexo-github/"/>
    <url>/2022/06/19/notion-hexo-github/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>目前主流的个人博客解决方案大致如下：</p><p>1、WordPress：<a href="https://wordpress.org/">WordPress</a>生态插件丰富非常容易搭建个人博客，上手也比较容易。但是问题在于WordPress需要独立的空间部署，需要使用数据库等，这就意味着我们需要去租赁云空间、系统上线需要经常备份维护等，长年累月下来就懒得打理逐渐荒废了。</p><p>2、Hexo：<a href="https://hexo.io/">Hexo</a>可以快速、简洁且高效的博客框架，功能插件丰富UI界面友好，Hexo编译后会生成静态文件不需要数据库连接等，直接挂到GithubPages即可。但是使用Hexo发布文章需要一个强大的Markdown软件，目前没有一个能和语雀、Notion等丰富度匹配的md编辑器，所以直接使用Hexo相对来说比较麻烦。</p><p>3、语雀：<a href="https://www.yuque.com/kissy">语雀</a> 是蚂蚁金服推出的一款知识库软件，我也用了语雀将近2年时间，语雀的知识库目录和文章目录功能比较强大，非常适合于个人知识库和笔记。但是如果想要搭建博客，则模板比较单一而且不能自定义主题等，而且文档发布过程中不方便与Hexo的<a href="https://hexo.io/zh-cn/docs/front-matter">YAML FrontMatter</a>集成，总的来说语雀在灵活度上有所欠缺对外扩展不方便。另外，如果是语雀重度用户要发布Hexo博客可以参考： <a href="https://github.com/x-cold/yuque-hexo">https://github.com/x-cold/yuque-hexo</a> （他可以通过自动化的方式将语雀的文章发布到hexo等主流的博客系统之上）。</p><p>4、Notion：<a href="https://www.notion.so/">Notion</a> 相对于其他的博客或者在线文档的服务，Notion 是目前自由度最高的，可以任意地调整页面的布局，插入和引用 database、block等，还支持各种组件、模板、在线写作等。但是Notion想要做个人博客在UI和精细程度上还有所欠缺。</p><p>综上所述，有没有一款工具既有Notion的灵活性，又能与Hexo主流博客系统对接？答案是只有自己撸一套，几经折腾打算采用如下解决方案：<code>使用Notion作为基础的知识库管理软件用于编写md文件，Hexo作为博客发布工具，GithubPages作为Hexo的Web应用服务器，GithubActions用于将Notion的Pages同步到GithubPages</code>。</p>          </div><h1 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1.基础环境搭建"></a>1.基础环境搭建</h1><p>在开始搭建之前，需要准备以下几样东西：</p><ul><li>本地安装 node.js</li><li>本地安装 git</li><li>一个 github 账号</li><li>创建一个 github 仓库</li></ul><h2 id="1-1-本地安装node-js"><a href="#1-1-本地安装node-js" class="headerlink" title="1.1 本地安装node.js"></a>1.1 本地安装node.js</h2><p><code>Windows</code>系统可以在<a href="https://nodejs.org/zh-cn/download/">这里</a>下载<code>installer</code> 安装包进行安装。</p><p><code>Mac</code>系统可以在<a href="https://nodejs.org/zh-cn/download/">这里</a>下载<code>pkg</code>安装包，也可以使用<code>homebrew</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装命令</span><br>% brew install node<br><span class="hljs-comment"># 安装验证</span><br>% node -v<br>v16.15.1<br></code></pre></td></tr></table></figure><h2 id="1-2-本地安装git"><a href="#1-2-本地安装git" class="headerlink" title="1.2 本地安装git"></a>1.2 本地安装git</h2><p><code>Windows</code> 系统可以从<a href="https://gitforwindows.org/">这里</a>下载安装包后进行安装。<code>Mac</code>系统可以从<a href="https://sourceforge.net/projects/git-osx-installer/">这里</a>下载安装包进行安装。也可以使用<code>homebrew</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装指令</span><br>brew install git<br><span class="hljs-comment"># 验证安装</span><br>git --version<br><span class="hljs-comment"># 设置自己的用户名和邮箱</span><br>git config --global user.name <span class="hljs-string">&quot;你的用户名&quot;</span> <br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h2 id="1-3-github账号"><a href="#1-3-github账号" class="headerlink" title="1.3 github账号"></a>1.3 github账号</h2><p><strong>1）首先注册账号</strong></p><p><a href="https://github.com/join?source=header-home">点击这里</a>需要注册一个<code>Github</code>账号，创建好账号之后，我们还需要把我们本地的<code>SSH Key</code> 添加到<code>Github</code> 中去，这样我们之后才能有权限将本地代码推送到<code>Github</code> 中，先本地生成一对<code>RSA</code> 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用默认参数，回车键连敲三次</span><br>ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2）将ssh-key添加到github</strong></p><ul><li>Windwos用户在:<code>C://用户//admin//.ssh</code> 目录下，Mac用户在<code>~./ssh</code> 目录下。</li></ul><p>复制<code>id_rsa.pub</code>文件里的信息，然后到<a href="https://github.com/settings/keys">这里</a>添加新的<code>SSHKEY</code>。</p><p><img src="/notion_images/01f62e9bcd47fffbf7f7ce79357433bb.png"></p><h2 id="1-4-启用github-pages"><a href="#1-4-启用github-pages" class="headerlink" title="1.4 启用github-pages"></a>1.4 启用github-pages</h2><p>GithubPages 可以理解为Github提供的免费网页空间，可以用来存放你的静态网页文件，并通过 <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/"><code>https://用户名.github.io</code></a> 或者 <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/"><code>https://用户名.github.io/项目名/</code></a> 的方式来访问。</p><p>开启的方式也非常简单，只需要在<a href="https://github.com/new">这里</a>创建相应的公共仓库并将仓库名称设置为：<code>用户名.github.io</code> 即可。</p><p><img src="/notion_images/4deafefc93b3f3d43c9333b5b7f3b03e.png"></p><p>如果使用了其他分支作为仓库代码，可以在github pages里边修改：</p><p><img src="/notion_images/e5a622e953cea730d0b6a3e03a3984c3.png"></p><p>修改完成之后就可以使用  <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/">https:&#x2F;&#x2F;用户名.github.io</a> 地址进行访问了（创建完成若未正常显示，可以稍等几分钟刷新再试）</p><h1 id="2-部署Hexo"><a href="#2-部署Hexo" class="headerlink" title="2.部署Hexo"></a>2.部署Hexo</h1><p>Hexo是一款静态网站生成工具，可以根据设置的主题样式和配置文件，来生成丰富多彩的网页，通常配置文件设置好之后不需要经常修改，我们只需要负责写好我们的博文，写好之后就能使用命令一键生成网站，而且还可以为所欲为的切换主题。</p><p><strong>1）Hexo安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">% npm install -g hexo-cli<br>% hexo -v<br></code></pre></td></tr></table></figure><p><strong>2）使用Hexo新建本地博客</strong></p><p>选择一个常用的工作空间目录，进入到该目录初始化Hexo项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">% hexo init blog<br>% <span class="hljs-built_in">cd</span> blog<br>% npm install<br></code></pre></td></tr></table></figure><p>新建完成之后，blog目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">% tree -L 1<br>.<br>├── _config.landscape.yml<br>├── _config.yml<br>├── node_modules<br>├── package-lock.json<br>├── package.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><br>└── themes<br></code></pre></td></tr></table></figure><p><code>_config.yml</code> 是配置文件，里面有很多可以配置的数据，这里暂时不多介绍，后面的文章里会进行详细说明。</p><p><code>package.json</code> 是应用程序信息，通常不需要关心。</p><p><code>node_modules</code> 用来存放 <code>node</code> 相关的模块，通常不需要关心。</p><p><code>scaffolds</code> 里面是模版文件，也就是每次新建文章时，都会根据模版文件来创建对应的 <code>md</code> 文件，这一点也会在后续的文章里进行详细介绍。</p><p><code>source</code> 是资源文件夹，用来存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。</p><p><code>theme</code> 是主题文件夹，每个主题的配置都会有些不一样，需要根据具体主题情况来定，后续介绍主题的文章里会有说明。</p><p><strong>3）本地运行Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">% hexo server<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>浏览器访问： <a href="http://localhost:4000/"><code>http://localhost:4000/</code></a></p><p><img src="/notion_images/92c39b1ea2c37f4e0057889891b7be5d.png"></p><h1 id="3-使用github-action自动发布"><a href="#3-使用github-action自动发布" class="headerlink" title="3.使用github-action自动发布"></a>3.使用github-action自动发布</h1><p>Hexo博客部署发布使用的是静态HTML文件，如果想要在互联网发布文章则需要进行deploy操作，为此我们将使用GithubPages作为我们的Web服务。这样一来我们需要维护一个Hexo源码分支用于存放Hexo源文件以及md文件等，使用另外一个分支发布我们的静态资源。每次提交代码并打包发布是一项繁琐的操作，我们可以用使用Actions实现流水线自动发布，Actions可以参考<a href="https://docs.github.com/cn/actions">这里</a>。</p><p>由于Hexo和相应的主题与配置等涉及到一些个性化的参数配置，基于安全因素考虑，我们可以使用两个仓库用于博客代码管理，一个<code>私有仓库</code>存放Blog原生代码和Ation用于触发流水线，另外一个<code>公共仓库</code>用于存放编译后的HTML代码，具体流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">本地Hexo编写md文件 --&gt; git提交至blog仓库（private）--&gt; 触发actions --&gt; 部署至用户名.github.io仓库(public)<br></code></pre></td></tr></table></figure><h2 id="3-1、首先，新建blog仓库"><a href="#3-1、首先，新建blog仓库" class="headerlink" title="3.1、首先，新建blog仓库"></a>3.<strong>1、首先，新建blog仓库</strong></h2><p>在<a href="https://github.com/new">这里</a>新建一个私有仓</p><p><img src="/notion_images/266d4025ed2e3ed474e8be8875620234.png"></p><h2 id="3-2、将本地Hexo代码提交至私有仓库"><a href="#3-2、将本地Hexo代码提交至私有仓库" class="headerlink" title="3.2、将本地Hexo代码提交至私有仓库"></a>3.<strong>2、将本地Hexo代码提交至私有仓库</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">cd</span> blogs<br>% git init<br>% git add .<br>% git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>% git branch -M main<br>% git remote add origin git@github.com:你的私有仓库地址.git<br>% git push -u origin main<br></code></pre></td></tr></table></figure><h2 id="3-3、使用github-action自动提交部署博客"><a href="#3-3、使用github-action自动提交部署博客" class="headerlink" title="3.3、使用github-action自动提交部署博客"></a>3.<strong>3、使用github-action自动提交部署博客</strong></h2><p>1<strong>）生成SSH秘钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">cd</span> ~/.ssh<br>% ssh-keygen -f hexo-deploy-key -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会在<code>~/.ssh</code>路径下生成：秘钥<code>hexo-deploy-key</code> 和公钥<code>hexo-deploy-key.pub</code>，然后分别添加到对应的文件中。</p><p><code>页面文件仓库（public）</code>: 在 Settings &gt; Deploy keys 中添加Deploy Key，内容为hexo-deploy-key.pub 文件内容，同时勾选 Allow write access 选项。</p><p><code>博客源文件库(private)</code>：在Settings &gt; Secrets中添加一个Secret，名称为 DEPLOY_KEY，内容为 hexo-deploy-key 文件内容。后续在 Workflow中通过名称 DEPLOY_KEY 使用这个密钥。</p><p><strong>2）添加Hexo Deploy</strong></p><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。Hexo-Deploy相关知识可以参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">这里</a>。</p><p>为了能够方便使用Hexo Deploy 首先要进行插件安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目路径下执行</span><br>% npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>安装成功后，修改 Hexo 源文件夹下的 _config.yml <code>将repo 地址设置为公共仓库地址</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br>deploy:<br>  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br>  repo: git@github.com:kissycn/你的公共仓库地址.git<br>  branch: [main]<br></code></pre></td></tr></table></figure><p><strong>3）添加action流水线脚本</strong></p><p>为了能够提交代码时执行自动构建，需要在私有仓库页面创建流水线，并在 push 时触发。</p><p>在私有仓库项目页面新建流水线脚本：</p><p><img src="/notion_images/4fe924d83ea60a82c9da258707f9c7e3.png"></p><p>私有仓库<code>/.github/workflows/main.yml</code>文件内容如下（记得修改相应参数：<code>user.email</code>   <code>user.name</code>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-comment"># Controls when the workflow will run</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># Triggers the workflow on push or pull request events but only for the main branch</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">main</span> ]<br><br>  <span class="hljs-comment"># Allows you to run this workflow manually from the Actions tab</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-comment"># This workflow contains a single job called &quot;build&quot;</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-comment"># The type of runner that the job will run on</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-comment"># Steps represent a sequence of tasks that will be executed as part of the job</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br><br>      <span class="hljs-comment"># Runs a set of commands using the runners shell</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Node</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Npm</span> <span class="hljs-string">Install</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install hexo-cli -g</span><br><span class="hljs-string">          npm install</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Key</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">DEPLOY_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.DEPLOY_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh</span><br><span class="hljs-string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.email &quot;你的邮箱&quot;</span><br><span class="hljs-string">          git config --global user.name &quot;你的github用户名&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo generate</span><br><span class="hljs-string">          hexo deploy</span><br></code></pre></td></tr></table></figure><p>点击Commit按钮会触发相应的流水线操作，流水线执行结果可以在：<code>Actions → Workflows → Blog Deploy → build and deploy</code> </p><p><img src="/notion_images/080df2aed454253b3e7536f85e323ae5.png"></p><p>完了可以在：<code>用户名.github.io 仓库（public）</code>下查看自动部署后的文件，并在浏览器访问仓库地址，可以看到Hexo被提交到了仓库。</p><p><strong>3.4）新的变更</strong></p><p>流水线创建成功后，我们向Hexo仓库提交源代码，会自动触发Actions构建操作，这样就能实现博客文章自动发布功能。</p><div class="note note-warning">            <p>如果大家觉着每次提交代码都会触发编译发布比较鸡肋，也可以将发布流水线改成手动。</p>          </div><h1 id="4-同步notion数据到博客"><a href="#4-同步notion数据到博客" class="headerlink" title="4.同步notion数据到博客"></a>4.同步notion数据到博客</h1><p>Notion是一个全能工作空间，Notion 可以帮助你创建几乎你需要的所有东西，包括：</p><ul><li>文档</li><li>数据库</li><li>知识库</li><li>项目管理</li><li>生产力系统</li><li>世界上最美丽的笔记…</li></ul><p>Notion 中文站点：<a href="https://notionchina.co/">https://notionchina.co/</a></p><p>Notion 官放站点：<a href="http://notion.so/">notion.so</a></p><p>Notion 入门视频：<a href="https://www.bilibili.com/video/BV1DB4y1C7Af">https://www.bilibili.com/video/BV1DB4y1C7Af</a></p><p>以上文档和视频非常详细的介绍了Notion注册、使用教程，此不再赘述。</p><h2 id="4-1-使用notion数据库管理博客"><a href="#4-1-使用notion数据库管理博客" class="headerlink" title="4.1 使用notion数据库管理博客"></a>4.1 使用notion数据库管理博客</h2><p>Notion 作为一款非常灵活的博客管理工具，其Database功能具备良好的扩展性，可以通过自定义字段来与Hexo的<a href="https://hexo.io/zh-cn/docs/front-matter">YAML FrontMatter</a>集成，这样就非常方便的通过自动化的方式将Notion的文章发布到我们的Github-Pages上，本次集成参考的技术方案为 <a href="https://lailin.xyz/post/notion-markdown-blog.html">mohuishou的技术博客</a>，具体集成过程如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">用户在Notion编写文章</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">将文档移动到待发布状态</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">手动触发Actions</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">使用NotionAPI同步Pages到Github</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">触发Github自动编译并发布</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">将文章在Notion更新为已发布</span><br></code></pre></td></tr></table></figure><p><strong>1）建立NotionDatabase</strong></p><p><a href="https://www.notion.so/3999b0ae72364a4b99a87f7d9d0a52be">点击这里</a>，复制 mohuishou 同学的NotionTemplate到自己的Notion。</p><p><img src="/notion_images/36229ec5b958d647221390f2c1885135.png"></p><p>上述为Notion的Database，通过看板可以看到Notion的文档分成了几种状态，其流转过程如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">idea</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">放入收集箱</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">编写文章</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">移动到待发布</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">点击执行</span> <span class="hljs-string">github</span> <span class="hljs-string">workflow</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">自动发布</span><br></code></pre></td></tr></table></figure><p><strong>2）Notion Database 为文章添加字段</strong></p><p>通过Notion的Database为每篇文章定义了众多字段，其含义如下：</p><ul><li><strong>status</strong>：为了避免每次都获取所有的文章数据，我们添加一个 status 字段，当 status 为 待发布 的时候我们才去下载对应的文章，文章下载完成之后，我们就把这篇文章的状态修改为 已发布</li><li><strong>tags：</strong>Hexo 博客对应的标签</li><li><strong>categories：</strong>Hexo对应的分类</li><li><strong>urlname：</strong>Hexo文章发布后的url地址</li><li><strong>date：</strong>Hexo文章发布时间</li><li><strong>show-category</strong>：Hexo文章所述分类</li><li><strong>index_img</strong>：Hexo文章的封面图</li><li><strong>excerpt：</strong>Hexo文章节选描述</li></ul><p><img src="/notion_images/5878e2337380c983bcebe2b32617c93c.png"></p><h2 id="4-2-使用Actions同步博客数据到Github"><a href="#4-2-使用Actions同步博客数据到Github" class="headerlink" title="4.2 使用Actions同步博客数据到Github"></a>4.2 使用Actions同步博客数据到Github</h2><p>想要将Notion的Pages同步到Database主要是通过NotionAPI将 <code>Notion Page</code> 转换为<code>Markdown</code>文件，然后就可以直接使用 Hugo、Hexo 等。虽然现在Notion官方开放了API，但是没有API可以直接将Notion 的数据结构之间转换为Markdown，现在虽然有一些第三方库（例如 notion2md ）支持，但是存在着各种各样的问题，要么不支持图片，要么不支持table等格式，总是会欠缺，为此对于Notion Page的同步采用 mohuishou同学的编写的同步代码，<a href="https://github.com/mohuishou/notion-blog-actions">仓库地址点这里</a>。</p><p><strong>1）fork pages的同步代码到自己的仓库</strong></p><p><img src="/notion_images/22d6cce3f2b31bbfd45fc65e93053089.png"></p><p><strong>2）获取Notion 需要用到的参数</strong></p><p>Notion的API调用需要用到几个参数： <code>NOTION_TOKEN、NOTION_TOKEN_V2、space_id、database_id</code></p><p>1、获取<code>NOTION_TOKEN</code></p><p>点击<a href="https://www.notion.so/my-integrations">这里</a>添加一个notion-integration</p><p><img src="/notion_images/a384fd08037e6e73c9552a6e5449948f.png"></p><p>赋予对应的权限</p><p><img src="/notion_images/015f877376eb34a20d23c5bf24013cb5.png"></p><p>点击show就得到了<code>NOTION_TOKEN</code></p><p><img src="/notion_images/110d905f7bded3a8236b6464d7975897.png"></p><p>将Notion Database分享给刚刚创建的integration，在需要使用API的页面中，点击Share并选择Invite ，将机器人邀请进去，让其用于编辑的权限。</p><p>2、获取<code>NOTION_TOKEN_V2</code></p><p>通过网页打开 <a href="https://www.notion.so/">https://www.notion.so/</a> 并登录，打开浏览器的开发者模式：Application&gt;Cookies&gt;token_v2 即可获取</p><p>3、获取<code>space_id</code></p><p>通过网页打开 <a href="https://www.notion.so/">https://www.notion.so/</a> 并登录，打开浏览器的开发者模式：Application&gt;Cookies&gt;notion_user_id 即可获取</p><p>4、获取<code>database_id</code></p><p>获取数据表的 database_id，点击数据表右上方的 … 选择 Copylink ，连接如下方：<a href="https://www.notion.so/9bcf00dce55c42799f3b177dc325aa18">https://www.notion.so/xinhuoip/9bcf00dce55c42799f3b177dc325aa18?v=217bbe82893e4e4aa228a19f3f2dc888</a>   其中：<a href="https://www.notion.so/851d6c61c250495f9337be5527360d68">9bcf00dce55c42799f3b177dc325aa18</a> 即为 <code>database_id</code> </p><p><strong>3）在Github添加secrets</strong></p><p>在上面建立的<code>私有仓库（存放Hexo源码的那个仓库)</code>的仓库里边添加TOKEN的环境变量：</p><p> <code>blog私有仓库—&gt;settings—&gt;secrets—&gt;actions—&gt;New repository secret</code></p><p><img src="/notion_images/cf8c2e380bdae147bbc5aa81087039a5.png"></p><p>4<strong>）编写触发的Actions</strong></p><p>在<code>私有仓库（存放Hexo源码的那个仓库)</code>仓库中添加Actions，blogs&#x2F;.github&#x2F;workflows&#x2F;notion-hexo.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span> [<span class="hljs-string">workflow_dispatch</span>, <span class="hljs-string">watch</span>]<br><br><span class="hljs-attr">name:</span> <span class="hljs-string">notion</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">notion:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;test&quot;</span><br>      <span class="hljs-attr">run :</span> <span class="hljs-string">|</span><br><span class="hljs-string">        echo $&#123;&#123; secrets.NOTION_TOKEN &#125;&#125;</span><br><span class="hljs-string">        echo $&#123;&#123; secrets.NOTION_TOKEN_V2 &#125;&#125;</span><br><span class="hljs-string"></span>        <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">submodules:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">修改为你fork的仓库代码地址/notion-blog-actions/notion@main</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.NOTION_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">token_v2:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.NOTION_TOKEN_V2</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">space_id:</span> <span class="hljs-string">&quot;你的spaceid&quot;</span><br>        <span class="hljs-attr">database_id:</span> <span class="hljs-string">&quot;你的database_id&quot;</span><br>        <span class="hljs-attr">output:</span> <span class="hljs-string">&quot;./tmp/&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;migrate image&quot;</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">修改为你fork的仓库代码地址/notion-blog-actions/migrate@main</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">input:</span> <span class="hljs-string">&quot;./tmp/*.md&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;cp md files&quot;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        cp -f tmp/*.md source/_posts/notion/</span><br><span class="hljs-string">        rm -rf tmp</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git</span> <span class="hljs-string">setting</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        git config --global user.email &quot;你的邮箱&quot;</span><br><span class="hljs-string">        git config --global user.name &quot;你的用户名&quot;</span><br><span class="hljs-string"></span>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">update</span> <span class="hljs-string">blog</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        git add source</span><br><span class="hljs-string">        git commit -m &quot;feat: auto update by notion sync&quot;</span><br><span class="hljs-string">        git push</span><br></code></pre></td></tr></table></figure><p><strong>5）在github-actions页面可完成流水线的手动触发</strong></p><p>如此一来我们就是实现了将Notion的Pages自动发布到GithubPages，大家可以根据自己使用习惯和使用方式做调整。</p><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p><strong><strong>使用 Notion Database 管理静态博客文章：</strong></strong><a href="https://lailin.xyz/post/notion-markdown-blog.html">https://lailin.xyz/post/notion-markdown-blog.html</a></p><p><strong>Notion API 简单上手：</strong><a href="https://ews.ink/tech/dev-notion-api/">https://ews.ink/tech/dev-notion-api/</a></p><p><strong><strong>notion API使用：</strong></strong><a href="https://www.zdl.im/article/notionapi">https://www.zdl.im/article/notionapi</a></p><p><strong>使用Hexo+github pages+travis ci搭建好看的个人博客：</strong> <a href="https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/">https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/</a></p><p><strong>利用 Github Actions 自动化部署 Hexo 博客：</strong><a href="https://dreamhomes.top/posts/202111101556/">https://dreamhomes.top/posts/202111101556/</a></p>]]></content>
    
    
    <categories>
      
      <category>分类1</category>
      
      <category>分类2</category>
      
      <category>分类3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-New-Post</title>
    <link href="/2022/06/15/undefined/"/>
    <url>/2022/06/15/undefined/</url>
    
    <content type="html"><![CDATA[<p>sdf</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h5 id="五级"><a href="#五级" class="headerlink" title="五级"></a>五级</h5>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
