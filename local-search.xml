<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1.基础数据类型与容器</title>
    <link href="/2022/06/21/undefined/"/>
    <url>/2022/06/21/undefined/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-使用一致的变量声明形式"><a href="#1-1-使用一致的变量声明形式" class="headerlink" title="1.1 使用一致的变量声明形式"></a>1.1 使用一致的变量声明形式</h1><p>Go语言有两类变量：</p><p><strong>包级变量（packagevariable）</strong>：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。</p><p><strong>局部变量（localvariable）</strong>：函数或方法体内声明的变量，仅在函数或方法体内可见。</p><h1 id="1）包级变量的声明形式"><a href="#1）包级变量的声明形式" class="headerlink" title="1）包级变量的声明形式"></a>1）包级变量的声明形式</h1><p>常见的go变量声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">13</span><br>n := <span class="hljs-number">17</span><br><span class="hljs-keyword">var</span> (<br>    crlf = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>    colonSpace = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;:&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="1-1）声明并同时显式初始化"><a href="#1-1）声明并同时显式初始化" class="headerlink" title="1.1）声明并同时显式初始化"></a>1.1）声明并同时显式初始化</h3><p>在声明变量的同时进行显式初始化的这类包级变量，表达式如下：</p><p><strong>var variableName &#x3D; InitExpression</strong></p><p>Go编译器会自动根据等号右侧的InitExpression表达式求值的类型确定左侧所声明变量的类型。如果InitExpression采用的是不带有类型信息的常量表达式，比如下面的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = <span class="hljs-number">17</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p>以整型值初始化的变量a，Go编译器会将之设置为默认类型int；而以浮点值初始化的变量f，Go编译器会将之设置为默认类型float64。</p><p>如果不接受默认类型，而是要显式为包级变量a和f指定类型，那么有以下两种声明方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span>   = <span class="hljs-number">17</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float32</span> = <span class="hljs-number">3.14</span><br><span class="hljs-comment">// 第二种,从声明一致性的角度出发，Go语言官方更推荐后者</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-type">int32</span>(<span class="hljs-number">17</span>)<br><span class="hljs-keyword">var</span> f = <span class="hljs-type">float32</span>(<span class="hljs-number">3.14</span>)<br></code></pre></td></tr></table></figure><h3 id="1-2）声明但延迟初始化"><a href="#1-2）声明但延迟初始化" class="headerlink" title="1.2）声明但延迟初始化"></a>1.2）声明但延迟初始化</h3><p>对于声明时并不显式初始化的包级变量，我们使用最基本的声明形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><p>注意：虽然没有显式初始化，但Go语言会让这些变量拥有初始的“零值”。如果是自定义的类型，保证其零值可用是非常必要的。</p><h3 id="13）声明聚类与就近原则"><a href="#13）声明聚类与就近原则" class="headerlink" title="13）声明聚类与就近原则"></a>13）声明聚类与就近原则</h3><p>Go语言提供 var 块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。</p><p>但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中；</p><p>或者将延迟初始化的变量声明放在一个var块，而将声明并显式初始化的变量放在另一个var块中。</p><p>称之为“<strong>声明聚类</strong>”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//$GOROOT/src/net/http/server.go</span><br><span class="hljs-keyword">var</span> (<br>bufioReaderPool   sync.Pool<br>bufioWriter2kPool sync.Pool<br>bufioWriter4kPool sync.Pool<br>)<br><br><span class="hljs-comment">// Errors used by the HTTP server.</span><br><span class="hljs-keyword">var</span> (<br>ErrBodyNotAllowed = errors.New(<span class="hljs-string">&quot;http: request method or response status code does not allow body&quot;</span>)<br><br>ErrHijacked = errors.New(<span class="hljs-string">&quot;http: connection has been hijacked&quot;</span>)<br><br>ErrContentLength = errors.New(<span class="hljs-string">&quot;http: wrote more than the declared Content-Length&quot;</span>)<br><br>ErrWriteAfterFlush = errors.New(<span class="hljs-string">&quot;unused&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>就近原则</strong>：即尽可能在靠近第一次使用变量的位置声明该变量，而不是统一将变量声明放到文件顶部。就近原则实际上是变量的作用域最小化的一种实现手段。</p><h1 id="2）局部变量的声明形式"><a href="#2）局部变量的声明形式" class="headerlink" title="2）局部变量的声明形式"></a>2）局部变量的声明形式</h1><p>与包级变量相比，局部变量多了一种短变量声明形式，这也是局部变量采用最多的一种声明形式。局部变量声明应遵循以下规范：</p><p><strong>2.1）对于延迟初始化的局部变量声明，采用带有var关键字的声明形式</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.2）对于声明且显式初始化的局部变量，建议使用短变量声明形式</strong></p><p>短变量声明形式是局部变量最常用的声明形式，它遍布Go标准库代码。对于接受默认类型的变量，可以使用下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">17</span><br>f := <span class="hljs-number">3.14</span><br>s := <span class="hljs-string">&quot;hello,gopher!&quot;</span><br></code></pre></td></tr></table></figure><p>对于不接受默认类型的变量，依然可以使用短变量声明形式，只是在“:&#x3D;”右侧要进行显式转型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-type">int32</span>(<span class="hljs-number">17</span>)<br>f := <span class="hljs-type">float32</span>(<span class="hljs-number">3.14</span>)<br>s := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello,gopher!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>2.3）尽量在分支控制时应用短变量声明形式</strong></p><p>在编写Go代码时，我们很少单独声明在分支控制语句中使用的变量，而是通过短变量声明形式将其与if、for等融合在一起:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//$GOROOT/src/net/net.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *Buffers)</span></span> WriteTo(w io.Writer) (n <span class="hljs-type">int64</span>,err <span class="hljs-type">error</span>)&#123;<br>   <span class="hljs-keyword">if</span> wv,ok := w.(buffersWriter); ok&#123;<br>       <span class="hljs-keyword">return</span> wv.writeBuffers(v)<br>   &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/106550/1650784778587-1e3c20fd-2cb7-4c2f-99e6-1ec86ba6b96e.png" alt="https://cdn.nlark.com/yuque/0/2022/png/106550/1650784778587-1e3c20fd-2cb7-4c2f-99e6-1ec86ba6b96e.png"></p><h1 id="1-2-使用无类型常量简化代码"><a href="#1-2-使用无类型常量简化代码" class="headerlink" title="1.2 使用无类型常量简化代码"></a>1.2 使用无类型常量简化代码</h1><p>Go语言常量定义的关键字：<strong>const</strong></p><p>Go语言中的const整合了C语言中宏定义常量、const只读变量和枚举常量三种形式，并消除了每种形式的不足，使得Go常量成为类型安全且对编译器优化友好的语法元素。Go中所有与常量有关的声明都通过const来进行。</p><p>1）有类型常量与无类型常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 有类型常量</span><br><span class="hljs-keyword">const</span> VERSION <span class="hljs-type">int</span> = <span class="hljs-number">128</span><br><span class="hljs-comment">// 无类型常量</span><br><span class="hljs-keyword">const</span> RELEASE = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>当把有无类型的常量，赋值给一个变量的时候，无类型的常量会被隐式的转化成对应的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 无类型常量赋值，存在自动类型转换</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int16</span> = RELEASE<br><span class="hljs-keyword">var</span> y <span class="hljs-type">int32</span> = RELEASE<br><span class="hljs-comment">// 有类型常量赋值，编译器报错</span><br><span class="hljs-keyword">var</span> x1 <span class="hljs-type">int16</span> = VERSION<br><span class="hljs-keyword">var</span> y1 <span class="hljs-type">int32</span> = VERSION<br><span class="hljs-comment">// 有类型常量赋值,需要显示转换数据类型</span><br><span class="hljs-keyword">var</span> x2 <span class="hljs-type">int32</span> = <span class="hljs-type">int32</span>(VERSION)<br></code></pre></td></tr></table></figure><p>由此可见，无类型常量使得Go在处理表达式混合数据类型运算时具有较大的灵活性，代码编写也有所简化，我们无须再在求值表达式中做任何显式类型转换了。</p><p>另外，无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为：bool、int、int32(rune)、float64、complex128和string。当常量被赋值给无类型变量、接口变量时，常量的默认类型对于确定无类型变量的类型及接口对应的动态类型是至关重要的。</p><p>注意：所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。</p><h1 id="1-3-使用iota实现枚举常量"><a href="#1-3-使用iota实现枚举常量" class="headerlink" title="1.3 使用iota实现枚举常量"></a>1.3 使用iota实现枚举常量</h1><h1 id="1）隐式重复非空表达式"><a href="#1）隐式重复非空表达式" class="headerlink" title="1）隐式重复非空表达式"></a>1）隐式重复非空表达式</h1><p>Go的const语法提供了“隐式重复前一个非空表达式”的机制，来看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>    Apple,Banana = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Strawberry, rape<br>    Pear, atermelon<br>)<br></code></pre></td></tr></table></figure><p>常量定义的后两行没有显式给予初始赋值，Go编译器将为其隐式使用第一行的表达式，这样上述定义等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>    Apple, Banana = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Strawberry, Grape = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Pear,Watermelon =<span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>)<br></code></pre></td></tr></table></figure><h1 id="2）iota关键字实现枚举"><a href="#2）iota关键字实现枚举" class="headerlink" title="2）iota关键字实现枚举"></a>2）iota关键字实现枚举</h1><p><strong>iota</strong> 是Go语言的一个预定义标识符，它表示的是const声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的 iota 自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Sunday = <span class="hljs-literal">iota</span> <span class="hljs-comment">// iota的值是该行在const块中的偏移量，因此iota的值为0</span><br>Monday <span class="hljs-comment">// const声明块的第二行，由于没有显式的常量初始化表达式，由于在第二行所以值为：1</span><br>Tuesday<br>Wednesday<br>Thursday<br>Friday<br>Saturday<br>)<br></code></pre></td></tr></table></figure><p>当iota同一行出现多次时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Apple, Banana     = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">10</span> <span class="hljs-comment">// 0, 10 (iota=0)</span><br>Strawberry, Grape                   <span class="hljs-comment">// 1, 11 (iota=1)</span><br>Pear, Watermelon                    <span class="hljs-comment">// 2, 12 (iota=2)</span><br>)<br></code></pre></td></tr></table></figure><p>如果要略过iota&#x3D;0，而从iota&#x3D;1开始正式定义枚举常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_      = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>Sunday        <span class="hljs-comment">// 1</span><br>    ...<br>)<br></code></pre></td></tr></table></figure><h1 id="3）定义类型安全的枚举常量"><a href="#3）定义类型安全的枚举常量" class="headerlink" title="3）定义类型安全的枚举常量"></a>3）定义类型安全的枚举常量</h1><p>枚举常量多数是无类型常量，如果要严格考虑类型安全，也可以定义有类型枚举常量。下面是Go标准库中一段定义有类型枚举常量的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>Sunday Weekday = <span class="hljs-literal">iota</span><br>Monday<br>Tuesday<br>Wednesday<br>Thursday<br>Friday<br>Saturday<br>)<br><br><span class="hljs-comment">// 这样，后续要使用Sunday、Saturday这些有类型枚举常量时，必须匹配Weekday类型的变量:</span><br><span class="hljs-keyword">var</span> workday Weekday = Sunday<br></code></pre></td></tr></table></figure><h1 id="1-4-尽量定义零值可用的类型"><a href="#1-4-尽量定义零值可用的类型" class="headerlink" title="1.4 尽量定义零值可用的类型"></a>1.4 尽量定义零值可用的类型</h1><p>在Go语言中，零值不仅在变量初始化阶段避免了变量值不确定可能带来的潜在问题，而且定义零值可用的类型也是Go语言积极倡导的最佳实践之一，Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）：</p><p><strong>所有整型类型：0浮点类型：0.0</strong></p><p><strong>布尔类型：false</strong></p><p><strong>字符串类型：””</strong></p><p><strong>指针、interface、切片（slice）、channel、map、function：nil</strong></p><p>另外，Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p><h1 id="1）零值可用"><a href="#1）零值可用" class="headerlink" title="1）零值可用"></a>1）零值可用</h1><p>零值可用意味着：当通过声明或调用new为变量分配存储空间，或者通过调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> eroSlice []<span class="hljs-type">int</span><br>zeroSlice = <span class="hljs-built_in">append</span>(zeroSlice, <span class="hljs-number">1</span>)<br>zeroSlice = <span class="hljs-built_in">append</span>(zeroSlice, <span class="hljs-number">2</span>)<br>zeroSlice = <span class="hljs-built_in">append</span>(zeroSlice, <span class="hljs-number">3</span>)<br>fmt.Println(zeroSlice) <span class="hljs-comment">//输出：[123]</span><br></code></pre></td></tr></table></figure><p>这里声明了一个[]int类型的切片zeroSlice，但并没有对其进行显式初始化，这样 zeroSlice 这个变量就被Go编译器置为零值 nil。按传统的思维，对于值为nil的变量，我们要先为其赋上合理的值后才能使用。但由于Go中的切片类型具备零值可用的特性，我们可以直接对其进行append操作，而不会出现引用nil的错误。</p><p>在Go标准库和运行时代码中还有很多践行“零值可用”理念的好例子，最典型的莫过于sync.Mutex和bytes.Buffer了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m usync.Mutex<br>mu.Lock()<br>mu.Unlock()<br><br><span class="hljs-keyword">var</span> b bytes.Buffer<br>b.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;EffectiveGo&quot;</span>))<br>fmt.Println(b.String()) <span class="hljs-comment">//输出：EffectiveGo</span><br></code></pre></td></tr></table></figure><h1 id="1-5-使用复合字面值作为初值构造器"><a href="#1-5-使用复合字面值作为初值构造器" class="headerlink" title="1.5 使用复合字面值作为初值构造器"></a>1.5 使用复合字面值作为初值构造器</h1><p>Go语言中的复合类型包括结构体、数组、切片和map。对于复合类型变量，最常见的值构造方式就是对其内部元素进行逐个赋值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">var</span> s myStruct<br>s.name = <span class="hljs-string">&quot;tony&quot;</span><br>s.age = <span class="hljs-number">23</span><br><span class="hljs-comment">// slice</span><br>sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>sl[<span class="hljs-number">0</span>] = <span class="hljs-number">23</span><br>sl[<span class="hljs-number">1</span>] = <span class="hljs-number">24</span><br>...<br>sl[<span class="hljs-number">4</span>] = <span class="hljs-number">27</span><br><span class="hljs-comment">// map</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;gopher&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>但这样的值构造方式让代码显得有些烦琐，尤其是在构造组成较为复杂的复合类型变量的初值时。Go提供的复合字面值（compositeliteral）语法可以作为复合类型变量的初值构造器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := myStruct&#123;<span class="hljs-string">&quot;tony&quot;</span>, <span class="hljs-number">23</span>&#125;<br>a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>&#125;<br>sl := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>&#125;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;gopher&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;!&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>复合字面值组成：<strong>类型{ field : value}</strong>  &#x2F;&#x2F; 类型例如：myStruct、[5]int、[]int和map[int]string；</p><h1 id="1）结构体复合字面"><a href="#1）结构体复合字面" class="headerlink" title="1）结构体复合字面"></a>1）结构体复合字面</h1><p>Go推荐使用field:value的复合字面值形式对struct类型变量进行值构造，这种值构造方式可以降低结构体类型使用者与结构体类型设计者之间的耦合，例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pipe <span class="hljs-keyword">struct</span> &#123;<br>    wrMu sync.Mutex<br>    wrCh <span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span><br>    rdCh <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>    once sync.Once<br>    done <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pipe</span><span class="hljs-params">()</span></span> &#123;<br>    p := &amp;pipe&#123;<br>        wrCh: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">byte</span>),<br>        rdCh: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>),<br>        done: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种field:value形式的复合字面值初值构造器颇为强大。与之前普通复合字面值形式不同，field:value形式字面值中的字段可以以任意次序出现，未显式出现在字面值的结构体中的字段将采用其对应类型的零值。</p><h1 id="2）数组-x2F-切片复合字面"><a href="#2）数组-x2F-切片复合字面" class="headerlink" title="2）数组&#x2F;切片复合字面"></a>2）数组&#x2F;切片复合字面</h1><p>与结构体类型不同，数组&#x2F;切片使用下标（index）作为 field:value 形式中的field，从而实现数组&#x2F;切片初始元素值的高级构造形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> data1 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">10</span>, <span class="hljs-number">1</span>: <span class="hljs-number">5</span>, <span class="hljs-number">2</span>: <span class="hljs-number">0</span>&#125; <span class="hljs-comment">// 通过切片index作为field</span><br><span class="hljs-keyword">var</span> data2 = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>&#125;          <span class="hljs-comment">// 省略index</span><br><br>fmt.Println(data1 == data2) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="3）map复合字面"><a href="#3）map复合字面" class="headerlink" title="3）map复合字面"></a>3）map复合字面</h1><p>由于map类型具有原生的key:value构造形式，所以map使用复合字面值构造自然得多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stateName = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;StateNew&quot;</span>:      <span class="hljs-string">&quot;new&quot;</span>,<br>    <span class="hljs-string">&quot;StateActive&quot;</span>:   <span class="hljs-string">&quot;active&quot;</span>,<br>    <span class="hljs-string">&quot;StateIdle&quot;</span>:     <span class="hljs-string">&quot;idle&quot;</span>,<br>    <span class="hljs-string">&quot;StateHijacked&quot;</span>: <span class="hljs-string">&quot;hijacked&quot;</span>,<br>    <span class="hljs-string">&quot;StateClosed&quot;</span>:   <span class="hljs-string">&quot;closed&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1-6-切片"><a href="#1-6-切片" class="headerlink" title="1.6 切片"></a>1.6 切片</h1><h1 id="1）数组"><a href="#1）数组" class="headerlink" title="1）数组"></a>1）数组</h1><p>Go语言数组是一个固定长度的、容纳同构类型元素的连续序列，因此Go数组类型具有两个属性：元素类型和数组长度。这两个属性都相同的数组类型是等价的。比如以下变量a、b、c对应的数组类型是三个不同的数组类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a[<span class="hljs-number">8</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b[<span class="hljs-number">8</span>]<span class="hljs-type">byte</span><br><span class="hljs-keyword">var</span> c[<span class="hljs-number">9</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h1 id="2）切片"><a href="#2）切片" class="headerlink" title="2）切片"></a>2）切片</h1><p>在Go语言中<strong>传递数组是纯粹的值拷贝</strong>，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗，为了避免此类问题GO语言提供了更加灵活的机制：<strong>切片</strong>。</p><p>切片是数组的“<strong>描述符</strong>”，是数组的某个区间的”<strong>数据引用</strong>“。切片之所以能在函数参数传递时避免较大性能损耗，是因为它是“描述符”的特性，切片这个描述符是固定大小的，无论底层的数组元素类型有多大，切片打开的窗口有多长。下面是切片在Go运行时（runtime）层面的内部表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//$GOROOT/src/runtime/slice.go</span><br><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span>&#123;<br>    array unsafe.Pointer  <span class="hljs-comment">// 指向下层数组某元素的指针，该元素也是切片的起始元素。</span><br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>  <span class="hljs-comment">// 切片的长度，即切片中当前元素的个数</span><br>    <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>  <span class="hljs-comment">// 切片的最大容量 cap&gt;=len</span><br>&#125;<br></code></pre></td></tr></table></figure><p>切片是底层数组的访问窗口，例如：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/106550/1650799852210-96ec0052-13ed-44be-9bf6-c33f1b3becf1.png" alt="https://cdn.nlark.com/yuque/0/2022/png/106550/1650799852210-96ec0052-13ed-44be-9bf6-c33f1b3becf1.png"></p><p>我们可以通过语法：<strong>u[low:high]</strong> 创建对已存在数组进行操作的切片，这被称为数组的切片化（slicing）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">u := [<span class="hljs-number">10</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>&#125;<br>s := u[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>切片s打开了一个操作数组u的窗口，我们通过s看到的第一个元素是u[3]，<strong>通过 s 能看到并操作的数组元素个数为4个。切片的容量值（cap）取决于底层数组的长度</strong>。从切片s的第一个元素s[0]，即u[3]到数组末尾一共有7个存储元素的槽位，因此切片s的cap为7，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/106550/1650800094187-1b3ae18e-b265-49a5-b2b0-3baba57554e6.png" alt="https://cdn.nlark.com/yuque/0/2022/png/106550/1650800094187-1b3ae18e-b265-49a5-b2b0-3baba57554e6.png"></p><p><strong>切片高效原理</strong>：当切片作为函数参数传递给函数时，实际传递的是切片的内部表示，也就是上面的runtime.slice结构体实例，因此无论切片描述的底层数组有多大，切片作为参数传递带来的性能损耗都是很小且恒定的，甚至小到可以忽略不计，这就是函数在参数中多使用切片而不用数组指针的原因之一。而另一个原因就是切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等。</p><h1 id="3）切片：动态扩容"><a href="#3）切片：动态扩容" class="headerlink" title="3）切片：动态扩容"></a>3）切片：动态扩容</h1><p>切片除了能方便进行数据存储还可以通过append函数进行元素赋值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">byte</span> <span class="hljs-comment">//s被赋予零值nil</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>由于初值为零值，s这个描述符并没有绑定对应的底层数组。而经过append操作后，s显然已经绑定了属于它的底层数组。为了方便查看切片是如何动态扩容的，我们打印出每次append操作后切片s的len和cap值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSlice</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span> <span class="hljs-comment">//s被赋予零值nil</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">11</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//1 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">13</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//3 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">14</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//4 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">15</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//5 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>扩容原理图：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/106550/1650801264102-0173bff1-35c9-4018-bb1a-398863e73186.png" alt="https://cdn.nlark.com/yuque/0/2022/png/106550/1650801264102-0173bff1-35c9-4018-bb1a-398863e73186.png"></p><p>当发生数据写入时，append会根据切片的需要，在当前底层数组容量无法满足的情况下，动态分配新的数组，新数组长度会按一定算法扩展。新数组建立后，<strong>append会把旧数组中的数据复制到新数组中，之后新数组便成为切片的底层数组，旧数组后续会被垃圾回收掉</strong>。</p><p>注意：通过语法 <strong>u[low:high]</strong> 形式进行数组切片化而创建的切片，一旦切片cap触碰到数组的上界，再对切片进行append操作，<strong>切片就会和原数组解除绑定，指向新创建的数组</strong>。</p><p>切片扩容算法：</p><p>$GOROOT&#x2F;src&#x2F;runtime&#x2F;slice.go中的growslice函数，大致原理如下：</p><ol><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容（cap）</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap&#x3D;doublecap）</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1&#x2F;4，即（newcap&#x3D;old.cap,for {newcap +&#x3D; newcap&#x2F;4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;&#x3D; cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li></ol><h1 id="4）尽可能使用cap创建切片"><a href="#4）尽可能使用cap创建切片" class="headerlink" title="4）尽可能使用cap创建切片"></a>4）尽可能使用cap创建切片</h1><p>append操作是一件利器，它让切片类型部分满足了“零值可用”的理念。但从append的原理中我们也能看到重新分配底层数组并复制元素的操作代价还是挺大的，尤其是当元素较多的情况下。那么如何减少或避免为过多内存分配和复制付出的代价呢？</p><p>一种有效的方法是：<strong>根据切片的使用场景对切片的容量规模进行预估，并在创建新切片时将预估出的切片容量数据以cap参数的形式传递给内置函数make</strong>：</p><p><strong>s:&#x3D;make([]T,len,cap)</strong></p><h1 id="1-7-map"><a href="#1-7-map" class="headerlink" title="1.7 map"></a>1.7 map</h1><p>map是Go语言提供的一种抽象数据类型，它表示一组无序的键值对（key-value）</p><p>map对value的类型没有限制，但是对key的类型有严格要求：key的类型应该严格定义了作为“&#x3D;&#x3D;”和“!&#x3D;”两个操作符的操作数时的行为，因此函数、map、切片不能作为map的key类型。<strong>map类型不支持“零值可用”，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic</strong>。</p><h1 id="1）map初始化"><a href="#1）map初始化" class="headerlink" title="1）map初始化"></a>1）map初始化</h1><p>（1）使用复合字面值创建map类型变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stateName = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;StateNew&quot;</span>:      <span class="hljs-string">&quot;new&quot;</span>,<br>    <span class="hljs-string">&quot;StateActive&quot;</span>:   <span class="hljs-string">&quot;active&quot;</span>,<br>    <span class="hljs-string">&quot;StateIdle&quot;</span>:     <span class="hljs-string">&quot;idle&quot;</span>,<br>    <span class="hljs-string">&quot;StateHijacked&quot;</span>: <span class="hljs-string">&quot;hijacked&quot;</span>,<br>    <span class="hljs-string">&quot;StateClosed&quot;</span>:   <span class="hljs-string">&quot;closed&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（2）使用make创建map类型变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">icookie s =<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]*Cookie)<br></code></pre></td></tr></table></figure><p><strong>注意：和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的。</strong></p><h1 id="2）map基本操作"><a href="#2）map基本操作" class="headerlink" title="2）map基本操作"></a>2）map基本操作</h1><p>（1）插入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go运行时会负责map内部的内存管理，因此除非是系统内存耗尽，我们不用担心向map中插入数据的数量</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><p>（2）获取数据个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br><span class="hljs-comment">//与Slice一样，map也可以通过内置函数len获取当前已经存储的数据个数</span><br>fmt.Println(<span class="hljs-built_in">len</span>(m))<br></code></pre></td></tr></table></figure><p>（3）查找和数据读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>_, ok := m[<span class="hljs-string">&quot;key&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(<span class="hljs-string">&quot;key exists&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）删除数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-string">&quot;value1&quot;</span><br><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></td></tr></table></figure><p>（5）遍历数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-string">&quot;value1&quot;</span><br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    fmt.Println(k, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。因此千万不要依赖遍历map所得到的元素次序。</p><h1 id="3）map内部实现"><a href="#3）map内部实现" class="headerlink" title="3）map内部实现"></a>3）map内部实现</h1><p>和切片相比，map类型的内部实现要复杂得多。Go运行时使用一张哈希表来实现抽象的map类型。</p><p>&#x2F;&#x2F; TODO</p><p>（1）map初始状态</p><p>（2）map扩容</p><p>（3）map并发</p><h1 id="4）尽可能使用cap创建map"><a href="#4）尽可能使用cap创建map" class="headerlink" title="4）尽可能使用cap创建map"></a>4）尽可能使用cap创建map</h1><p>如果初始创建map时没有创建足够多可以应付map使用场景的bucket，<strong>那么随着插入map元素数量的增多，map会频繁扩容，而这一过程将降低map的访问性能</strong>。因此，如果可能的话，我们最好对map使用规模做出粗略的估算，并使用cap参数对map实例进行初始化。</p><h1 id="1-8-string"><a href="#1-8-string" class="headerlink" title="1.8 string"></a>1.8 string</h1><h1 id="1）string基础"><a href="#1）string基础" class="headerlink" title="1）string基础"></a>1）string基础</h1><p><strong>（1）string类型的数据是不可变的</strong></p><p>一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序的生命周期内便无法更改。下面尝试修改一下string数据，看看能得到怎样的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestString</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;origin string:&quot;</span>, s) <span class="hljs-comment">// origin string: hello</span><br>s1 := []<span class="hljs-type">byte</span>(s)<br>s1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;t&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;slice:%s \n&quot;</span>, s1)   <span class="hljs-comment">// slice:tello</span><br><br>    <span class="hljs-comment">// after slice origin string: hello</span><br>fmt.Println(<span class="hljs-string">&quot;after slice origin string:&quot;</span>, s)<br>&#125;<br></code></pre></td></tr></table></figure><p>对string进行切片化后，Go编译器会为切片变量重新分配底层存储而不是共用string的底层存储，因此对切片的修改并未对原string的数据产生任何影响。</p><p><strong>（2）零值可用</strong></p><p>Gostring类型支持“零值可用”，因此其零值为””，长度为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>fmt.Println(s) <span class="hljs-comment">// s = &quot;&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><strong>（3）支持通过+&#x2F;+&#x3D;操作符进行字符串连接</strong></p><p>对开发者而言，通过+&#x2F;+&#x3D;操作符进行的字符串连接是体验最好的字符串连接操作。</p><p><strong>（4）支持各种比较关系操作符：&#x3D;&#x3D;、!&#x3D;、&gt;&#x3D;、&lt;&#x3D;、&gt;和&lt;</strong></p><p><strong>（5）对非ASCII字符提供原生支持</strong></p><p>Go语言源文件默认采用的Unicode字符集。Unicode字符集是目前市面上最流行的字符集，几乎囊括了所有主流非ASCII字符（包括中文字符）。Go字符串的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF8编码格式存储在内存当中的。</p><p><strong>（6）原生支持多行字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> s1 = <span class="hljs-string">`好雨知时节，当春乃发生。</span><br><span class="hljs-string">随风潜入夜，润物细无声。</span><br><span class="hljs-string">野径云俱黑，江船火独明。</span><br><span class="hljs-string">晓看红湿处，花重锦官城。`</span><br>fmt.Printf(s1)<br></code></pre></td></tr></table></figure><h1 id="2）字符串内部表示"><a href="#2）字符串内部表示" class="headerlink" title="2）字符串内部表示"></a>2）字符串内部表示</h1><p>Gostring类型上述特性的实现与Go运行时对string类型的内部表示是分不开的。Gostring在运行时表示为下面的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//$GOROOT/src/runtime/string.go</span><br><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer<br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/106550/1650809025796-d58a9087-d9bd-4470-8444-ca340565788e.png" alt="https://cdn.nlark.com/yuque/0/2022/png/106550/1650809025796-d58a9087-d9bd-4470-8444-ca340565788e.png"></p><p>我们看到每个字符串类型变量&#x2F;常量对应一个stringStruct实例，经过rawstring实例化后，stringStruct中的str指针指向真正存储字符串数据的底层内存区域，len字段存储的是字符串的长度（这里是5）；rawstring<strong>同时还创建了一个临时slice，该slice的array指针也指向存储字符串数据的底层内存区域</strong>。注意 rawstring调用后，新申请的内存区域还未被写入数据，该slice就是供后续运行时层向其中写入数据（”hello”）用的。写完数据后，该slice就可以被回收掉了（这也是图中将slice结构以虚线框表示的原因）。</p><p>根据string在运行时的表示可以得到这样一个结论：<strong>直接将string类型通过函数&#x2F;方法参数传入也不会有太多的损耗，因为传入的仅仅是一个“描述符”，而不是真正的字符串数据</strong>。</p><h1 id="3）字符串的高效构造"><a href="#3）字符串的高效构造" class="headerlink" title="3）字符串的高效构造"></a>3）字符串的高效构造</h1><p>前面提到过，Go原生支持通过+&#x2F;+&#x3D;操作符来连接多个字符串以构造一个更长的字符串，另Go还提供了其他一些构造字符串的方法，比如：</p><p>使用：<strong>fmt.Sprintf</strong></p><p>使用：<strong>strings.Join</strong></p><p>使用：<strong>strings.Builder</strong></p><p>使用：<strong>bytes.Buffer</strong></p><p>官方鼓励尽量在string的拼接时使用Builder，byte拼接时使用Buffer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestStringOp</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> s1 = []<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;s1&quot;</span>,<br><span class="hljs-string">&quot;s2&quot;</span>,<br><span class="hljs-string">&quot;s3&quot;</span>,<br>&#125;<br><span class="hljs-comment">// Join 操作遍历切片并连接空字符串</span><br><span class="hljs-keyword">var</span> s2 = strings.Join(s1, <span class="hljs-string">&quot; &quot;</span>)<br>fmt.Println(s2) <span class="hljs-comment">// 输出：s1 s2 s3</span><br><br><span class="hljs-comment">// 使用bytes.Buffer操作字符串</span><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello&quot;</span>))<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>buf.WriteString(<span class="hljs-string">&quot;World&quot;</span>)<br>fmt.Println(buf.String())<br><br><span class="hljs-comment">// 使用strings.Builder操作字符串</span><br><span class="hljs-keyword">var</span> builder strings.Builder<br>builder.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello&quot;</span>))<br>builder.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>builder.WriteString(<span class="hljs-string">&quot;World&quot;</span>)<br>fmt.Println(builder.String())<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4）字符串的转换"><a href="#4）字符串的转换" class="headerlink" title="4）字符串的转换"></a>4）字符串的转换</h1><p>string到[]byte的转换，这两个转换也是可逆的，也就是说string和[]rune、[]byte可以双向转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestStrConvert</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>rs := []<span class="hljs-type">rune</span>&#123;<br><span class="hljs-number">0x4E2D</span>,<br><span class="hljs-number">0x56FD</span>,<br><span class="hljs-number">0x6B22</span>,<br><span class="hljs-number">0x8FCE</span>,<br><span class="hljs-number">0x60A8</span>,<br>&#125;<br><br>s := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s) <span class="hljs-comment">// 中国欢迎您</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，Go语言还在标准库中提供了strings和strconv包，可对string类型数据进行更多高级操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Notion+Hexo+Github搭建技术博客</title>
    <link href="/2022/06/21/notion-hexo-github/"/>
    <url>/2022/06/21/notion-hexo-github/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>目前主流的个人博客解决方案大致如下：</p><p>1、WordPress：<a href="https://wordpress.org/">WordPress</a>生态插件丰富非常容易搭建个人博客，上手也比较容易。但是问题在于WordPress需要独立的空间部署，需要使用数据库等，这就意味着我们需要去租赁云空间、系统上线需要经常备份维护等，长年累月下来就懒得打理逐渐荒废了。</p><p>2、Hexo：<a href="https://hexo.io/">Hexo</a>可以快速、简洁且高效的博客框架，功能插件丰富UI界面友好，Hexo编译后会生成静态文件不需要数据库连接等，直接挂到GithubPages即可。但是使用Hexo发布文章需要一个强大的Markdown软件，目前没有一个能和语雀、Notion等丰富度匹配的md编辑器，所以直接使用Hexo相对来说比较麻烦。</p><p>3、语雀：<a href="https://www.yuque.com/kissy">语雀</a> 是蚂蚁金服推出的一款知识库软件，我也用了语雀将近2年时间，语雀的知识库目录和文章目录功能比较强大，非常适合于个人知识库和笔记。但是如果想要搭建博客，则模板比较单一而且不能自定义主题等，而且文档发布过程中不方便与Hexo的<a href="https://hexo.io/zh-cn/docs/front-matter">YAML FrontMatter</a>集成，总的来说语雀在灵活度上有所欠缺对外扩展不方便。另外，如果是语雀重度用户要发布Hexo博客可以参考： <a href="https://github.com/x-cold/yuque-hexo">https://github.com/x-cold/yuque-hexo</a> （他可以通过自动化的方式将语雀的文章发布到hexo等主流的博客系统之上）。</p><p>4、Notion：<a href="https://www.notion.so/">Notion</a> 相对于其他的博客或者在线文档的服务，Notion 是目前自由度最高的，可以任意地调整页面的布局，插入和引用 database、block等，还支持各种组件、模板、在线写作等。但是Notion想要做个人博客在UI和精细程度上还有所欠缺。</p><p>综上所述，有没有一款工具既有Notion的灵活性，又能与Hexo主流博客系统对接？答案是只有自己撸一套，几经折腾打算采用如下解决方案：<code>使用Notion作为基础的知识库管理软件用于编写md文件，Hexo作为博客发布工具，GithubPages作为Hexo的Web应用服务器，GithubActions用于将Notion的Pages同步到GithubPages</code>。</p>          </div><h1 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1.基础环境搭建"></a>1.基础环境搭建</h1><p>在开始搭建之前，需要准备以下几样东西：</p><ul><li>本地安装 node.js</li><li>本地安装 git</li><li>一个 github 账号</li><li>创建一个 github 仓库</li></ul><h2 id="1-1-本地安装node-js"><a href="#1-1-本地安装node-js" class="headerlink" title="1.1 本地安装node.js"></a>1.1 本地安装node.js</h2><p><code>Windows</code>系统可以在<a href="https://nodejs.org/zh-cn/download/">这里</a>下载<code>installer</code> 安装包进行安装。</p><p><code>Mac</code>系统可以在<a href="https://nodejs.org/zh-cn/download/">这里</a>下载<code>pkg</code>安装包，也可以使用<code>homebrew</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装命令</span><br>% brew install node<br><span class="hljs-comment"># 安装验证</span><br>% node -v<br>v16.15.1<br></code></pre></td></tr></table></figure><h2 id="1-2-本地安装git"><a href="#1-2-本地安装git" class="headerlink" title="1.2 本地安装git"></a>1.2 本地安装git</h2><p><code>Windows</code> 系统可以从<a href="https://gitforwindows.org/">这里</a>下载安装包后进行安装。<code>Mac</code>系统可以从<a href="https://sourceforge.net/projects/git-osx-installer/">这里</a>下载安装包进行安装。也可以使用<code>homebrew</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装指令</span><br>brew install git<br><span class="hljs-comment"># 验证安装</span><br>git --version<br><span class="hljs-comment"># 设置自己的用户名和邮箱</span><br>git config --global user.name <span class="hljs-string">&quot;你的用户名&quot;</span> <br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h2 id="1-3-github账号"><a href="#1-3-github账号" class="headerlink" title="1.3 github账号"></a>1.3 github账号</h2><p><strong>1）首先注册账号</strong></p><p><a href="https://github.com/join?source=header-home">点击这里</a>需要注册一个<code>Github</code>账号，创建好账号之后，我们还需要把我们本地的<code>SSH Key</code> 添加到<code>Github</code> 中去，这样我们之后才能有权限将本地代码推送到<code>Github</code> 中，先本地生成一对<code>RSA</code> 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用默认参数，回车键连敲三次</span><br>ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2）将ssh-key添加到github</strong></p><ul><li>Windwos用户在:<code>C://用户//admin//.ssh</code> 目录下，Mac用户在<code>~./ssh</code> 目录下。</li></ul><p>复制<code>id_rsa.pub</code>文件里的信息，然后到<a href="https://github.com/settings/keys">这里</a>添加新的<code>SSHKEY</code>。</p><p><img src="/notion_images/01f62e9bcd47fffbf7f7ce79357433bb.png"></p><h2 id="1-4-启用github-pages"><a href="#1-4-启用github-pages" class="headerlink" title="1.4 启用github-pages"></a>1.4 启用github-pages</h2><p>GithubPages 可以理解为Github提供的免费网页空间，可以用来存放你的静态网页文件，并通过 <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/"><code>https://用户名.github.io</code></a> 或者 <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/"><code>https://用户名.github.io/项目名/</code></a> 的方式来访问。</p><p>开启的方式也非常简单，只需要在<a href="https://github.com/new">这里</a>创建相应的公共仓库并将仓库名称设置为：<code>用户名.github.io</code> 即可。</p><p><img src="/notion_images/4deafefc93b3f3d43c9333b5b7f3b03e.png"></p><p>如果使用了其他分支作为仓库代码，可以在github pages里边修改：</p><p><img src="/notion_images/e5a622e953cea730d0b6a3e03a3984c3.png"></p><p>修改完成之后就可以使用  <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/">https:&#x2F;&#x2F;用户名.github.io</a> 地址进行访问了（创建完成若未正常显示，可以稍等几分钟刷新再试）</p><h1 id="2-部署Hexo"><a href="#2-部署Hexo" class="headerlink" title="2.部署Hexo"></a>2.部署Hexo</h1><p>Hexo是一款静态网站生成工具，可以根据设置的主题样式和配置文件，来生成丰富多彩的网页，通常配置文件设置好之后不需要经常修改，我们只需要负责写好我们的博文，写好之后就能使用命令一键生成网站，而且还可以为所欲为的切换主题。</p><p><strong>1）Hexo安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">% npm install -g hexo-cli<br>% hexo -v<br></code></pre></td></tr></table></figure><p><strong>2）使用Hexo新建本地博客</strong></p><p>选择一个常用的工作空间目录，进入到该目录初始化Hexo项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">% hexo init blog<br>% <span class="hljs-built_in">cd</span> blog<br>% npm install<br></code></pre></td></tr></table></figure><p>新建完成之后，blog目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">% tree -L 1<br>.<br>├── _config.landscape.yml<br>├── _config.yml<br>├── node_modules<br>├── package-lock.json<br>├── package.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><br>└── themes<br></code></pre></td></tr></table></figure><p><code>_config.yml</code> 是配置文件，里面有很多可以配置的数据，这里暂时不多介绍，后面的文章里会进行详细说明。</p><p><code>package.json</code> 是应用程序信息，通常不需要关心。</p><p><code>node_modules</code> 用来存放 <code>node</code> 相关的模块，通常不需要关心。</p><p><code>scaffolds</code> 里面是模版文件，也就是每次新建文章时，都会根据模版文件来创建对应的 <code>md</code> 文件，这一点也会在后续的文章里进行详细介绍。</p><p><code>source</code> 是资源文件夹，用来存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。</p><p><code>theme</code> 是主题文件夹，每个主题的配置都会有些不一样，需要根据具体主题情况来定，后续介绍主题的文章里会有说明。</p><p><strong>3）本地运行Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">% hexo server<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>浏览器访问： <a href="http://localhost:4000/"><code>http://localhost:4000/</code></a></p><p><img src="/notion_images/92c39b1ea2c37f4e0057889891b7be5d.png"></p><h1 id="3-使用github-action自动发布"><a href="#3-使用github-action自动发布" class="headerlink" title="3.使用github-action自动发布"></a>3.使用github-action自动发布</h1><p>Hexo博客部署发布使用的是静态HTML文件，如果想要在互联网发布文章则需要进行deploy操作，为此我们将使用GithubPages作为我们的Web服务。这样一来我们需要维护一个Hexo源码分支用于存放Hexo源文件以及md文件等，使用另外一个分支发布我们的静态资源。每次提交代码并打包发布是一项繁琐的操作，我们可以用使用Actions实现流水线自动发布，Actions可以参考<a href="https://docs.github.com/cn/actions">这里</a>。</p><p>由于Hexo和相应的主题与配置等涉及到一些个性化的参数配置，基于安全因素考虑，我们可以使用两个仓库用于博客代码管理，一个<code>私有仓库</code>存放Blog原生代码和Ation用于触发流水线，另外一个<code>公共仓库</code>用于存放编译后的HTML代码，具体流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">本地Hexo编写md文件 --&gt; git提交至blog仓库（private）--&gt; 触发actions --&gt; 部署至用户名.github.io仓库(public)<br></code></pre></td></tr></table></figure><h2 id="3-1、首先，新建blog仓库"><a href="#3-1、首先，新建blog仓库" class="headerlink" title="3.1、首先，新建blog仓库"></a>3.<strong>1、首先，新建blog仓库</strong></h2><p>在<a href="https://github.com/new">这里</a>新建一个私有仓</p><p><img src="/notion_images/266d4025ed2e3ed474e8be8875620234.png"></p><h2 id="3-2、将本地Hexo代码提交至私有仓库"><a href="#3-2、将本地Hexo代码提交至私有仓库" class="headerlink" title="3.2、将本地Hexo代码提交至私有仓库"></a>3.<strong>2、将本地Hexo代码提交至私有仓库</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">cd</span> blogs<br>% git init<br>% git add .<br>% git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>% git branch -M main<br>% git remote add origin git@github.com:你的私有仓库地址.git<br>% git push -u origin main<br></code></pre></td></tr></table></figure><h2 id="3-3、使用github-action自动提交部署博客"><a href="#3-3、使用github-action自动提交部署博客" class="headerlink" title="3.3、使用github-action自动提交部署博客"></a>3.<strong>3、使用github-action自动提交部署博客</strong></h2><p>1<strong>）生成SSH秘钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">cd</span> ~/.ssh<br>% ssh-keygen -f hexo-deploy-key -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会在<code>~/.ssh</code>路径下生成：秘钥<code>hexo-deploy-key</code> 和公钥<code>hexo-deploy-key.pub</code>，然后分别添加到对应的文件中。</p><p><code>页面文件仓库（public）</code>: 在 Settings &gt; Deploy keys 中添加Deploy Key，内容为hexo-deploy-key.pub 文件内容，同时勾选 Allow write access 选项。</p><p><code>博客源文件库(private)</code>：在Settings &gt; Secrets中添加一个Secret，名称为 DEPLOY_KEY，内容为 hexo-deploy-key 文件内容。后续在 Workflow中通过名称 DEPLOY_KEY 使用这个密钥。</p><p><strong>2）添加Hexo Deploy</strong></p><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。Hexo-Deploy相关知识可以参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">这里</a>。</p><p>为了能够方便使用Hexo Deploy 首先要进行插件安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目路径下执行</span><br>% npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>安装成功后，修改 Hexo 源文件夹下的 _config.yml <code>将repo 地址设置为公共仓库地址</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br>deploy:<br>  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br>  repo: git@github.com:kissycn/你的公共仓库地址.git<br>  branch: [main]<br></code></pre></td></tr></table></figure><p><strong>3）添加action流水线脚本</strong></p><p>为了能够提交代码时执行自动构建，需要在私有仓库页面创建流水线，并在 push 时触发。</p><p>在私有仓库项目页面新建流水线脚本：</p><p><img src="/notion_images/4fe924d83ea60a82c9da258707f9c7e3.png"></p><p>私有仓库<code>/.github/workflows/main.yml</code>文件内容如下（记得修改相应参数：<code>user.email</code>   <code>user.name</code>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-comment"># Controls when the workflow will run</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># Triggers the workflow on push or pull request events but only for the main branch</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">main</span> ]<br><br>  <span class="hljs-comment"># Allows you to run this workflow manually from the Actions tab</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-comment"># This workflow contains a single job called &quot;build&quot;</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-comment"># The type of runner that the job will run on</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-comment"># Steps represent a sequence of tasks that will be executed as part of the job</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br><br>      <span class="hljs-comment"># Runs a set of commands using the runners shell</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Node</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Npm</span> <span class="hljs-string">Install</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install hexo-cli -g</span><br><span class="hljs-string">          npm install</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Key</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">DEPLOY_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.DEPLOY_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh</span><br><span class="hljs-string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.email &quot;你的邮箱&quot;</span><br><span class="hljs-string">          git config --global user.name &quot;你的github用户名&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo generate</span><br><span class="hljs-string">          hexo deploy</span><br></code></pre></td></tr></table></figure><p>点击Commit按钮会触发相应的流水线操作，流水线执行结果可以在：<code>Actions → Workflows → Blog Deploy → build and deploy</code> </p><p><img src="/notion_images/080df2aed454253b3e7536f85e323ae5.png"></p><p>完了可以在：<code>用户名.github.io 仓库（public）</code>下查看自动部署后的文件，并在浏览器访问仓库地址，可以看到Hexo被提交到了仓库。</p><p><strong>3.4）新的变更</strong></p><p>流水线创建成功后，我们向Hexo仓库提交源代码，会自动触发Actions构建操作，这样就能实现博客文章自动发布功能。</p><div class="note note-warning">            <p>如果大家觉着每次提交代码都会触发编译发布比较鸡肋，也可以将发布流水线改成手动。</p>          </div><h1 id="4-同步notion数据到博客"><a href="#4-同步notion数据到博客" class="headerlink" title="4.同步notion数据到博客"></a>4.同步notion数据到博客</h1><p>Notion是一个全能工作空间，Notion 可以帮助你创建几乎你需要的所有东西，包括：</p><ul><li>文档</li><li>数据库</li><li>知识库</li><li>项目管理</li><li>生产力系统</li><li>世界上最美丽的笔记…</li></ul><p>Notion 中文站点：<a href="https://notionchina.co/">https://notionchina.co/</a></p><p>Notion 官放站点：<a href="http://notion.so/">notion.so</a></p><p>Notion 入门视频：<a href="https://www.bilibili.com/video/BV1DB4y1C7Af">https://www.bilibili.com/video/BV1DB4y1C7Af</a></p><p>以上文档和视频非常详细的介绍了Notion注册、使用教程，此不再赘述。</p><h2 id="4-1-使用notion数据库管理博客"><a href="#4-1-使用notion数据库管理博客" class="headerlink" title="4.1 使用notion数据库管理博客"></a>4.1 使用notion数据库管理博客</h2><p>Notion 作为一款非常灵活的博客管理工具，其Database功能具备良好的扩展性，可以通过自定义字段来与Hexo的<a href="https://hexo.io/zh-cn/docs/front-matter">YAML FrontMatter</a>集成，这样就非常方便的通过自动化的方式将Notion的文章发布到我们的Github-Pages上，本次集成参考的技术方案为 <a href="https://lailin.xyz/post/notion-markdown-blog.html">mohuishou的技术博客</a>，具体集成过程如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">用户在Notion编写文章</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">将文档移动到待发布状态</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">手动触发Actions</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">使用NotionAPI同步Pages到Github</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">触发Github自动编译并发布</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">将文章在Notion更新为已发布</span><br></code></pre></td></tr></table></figure><p><strong>1）建立NotionDatabase</strong></p><p><a href="https://www.notion.so/3999b0ae72364a4b99a87f7d9d0a52be">点击这里</a>，复制 mohuishou 同学的NotionTemplate到自己的Notion。</p><p><img src="/notion_images/36229ec5b958d647221390f2c1885135.png"></p><p>上述为Notion的Database，通过看板可以看到Notion的文档分成了几种状态，其流转过程如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">idea</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">放入收集箱</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">编写文章</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">移动到待发布</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">点击执行</span> <span class="hljs-string">github</span> <span class="hljs-string">workflow</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">自动发布</span><br></code></pre></td></tr></table></figure><p><strong>2）Notion Database 为文章添加字段</strong></p><p>通过Notion的Database为每篇文章定义了众多字段，其含义如下：</p><ul><li><strong>status</strong>：为了避免每次都获取所有的文章数据，我们添加一个 status 字段，当 status 为 待发布 的时候我们才去下载对应的文章，文章下载完成之后，我们就把这篇文章的状态修改为 已发布</li><li><strong>tags：</strong>Hexo 博客对应的标签</li><li><strong>categories：</strong>Hexo对应的分类</li><li><strong>urlname：</strong>Hexo文章发布后的url地址</li><li><strong>date：</strong>Hexo文章发布时间</li><li><strong>show-category</strong>：Hexo文章所述分类</li><li><strong>index_img</strong>：Hexo文章的封面图</li><li><strong>excerpt：</strong>Hexo文章节选描述</li></ul><p><img src="/notion_images/5878e2337380c983bcebe2b32617c93c.png"></p><h2 id="4-2-使用Actions同步博客数据到Github"><a href="#4-2-使用Actions同步博客数据到Github" class="headerlink" title="4.2 使用Actions同步博客数据到Github"></a>4.2 使用Actions同步博客数据到Github</h2><p>想要将Notion的Pages同步到Database主要是通过NotionAPI将 <code>Notion Page</code> 转换为<code>Markdown</code>文件，然后就可以直接使用 Hugo、Hexo 等。虽然现在Notion官方开放了API，但是没有API可以直接将Notion 的数据结构之间转换为Markdown，现在虽然有一些第三方库（例如 notion2md ）支持，但是存在着各种各样的问题，要么不支持图片，要么不支持table等格式，总是会欠缺，为此对于Notion Page的同步采用 mohuishou同学的编写的同步代码，<a href="https://github.com/mohuishou/notion-blog-actions">仓库地址点这里</a>。</p><p><strong>1）fork pages的同步代码到自己的仓库</strong></p><p><img src="/notion_images/22d6cce3f2b31bbfd45fc65e93053089.png"></p><p><strong>2）获取Notion 需要用到的参数</strong></p><p>Notion的API调用需要用到几个参数： <code>NOTION_TOKEN、NOTION_TOKEN_V2、space_id、database_id</code></p><p>1、获取<code>NOTION_TOKEN</code></p><p>点击<a href="https://www.notion.so/my-integrations">这里</a>添加一个notion-integration</p><p><img src="/notion_images/a384fd08037e6e73c9552a6e5449948f.png"></p><p>赋予对应的权限</p><p><img src="/notion_images/015f877376eb34a20d23c5bf24013cb5.png"></p><p>点击show就得到了<code>NOTION_TOKEN</code></p><p><img src="/notion_images/110d905f7bded3a8236b6464d7975897.png"></p><p>将Notion Database分享给刚刚创建的integration，在需要使用API的页面中，点击Share并选择Invite ，将机器人邀请进去，让其用于编辑的权限。</p><p>2、获取<code>NOTION_TOKEN_V2</code></p><p>通过网页打开 <a href="https://www.notion.so/">https://www.notion.so/</a> 并登录，打开浏览器的开发者模式：Application&gt;Cookies&gt;token_v2 即可获取</p><p>3、获取<code>space_id</code></p><p>通过网页打开 <a href="https://www.notion.so/">https://www.notion.so/</a> 并登录，打开浏览器的开发者模式：Application&gt;Cookies&gt;notion_user_id 即可获取</p><p>4、获取<code>database_id</code></p><p>获取数据表的 database_id，点击数据表右上方的 … 选择 Copylink ，连接如下方：<a href="https://www.notion.so/9bcf00dce55c42799f3b177dc325aa18">https://www.notion.so/xinhuoip/9bcf00dce55c42799f3b177dc325aa18?v=217bbe82893e4e4aa228a19f3f2dc888</a>   其中：<a href="https://www.notion.so/851d6c61c250495f9337be5527360d68">9bcf00dce55c42799f3b177dc325aa18</a> 即为 <code>database_id</code> </p><p><strong>3）在Github添加secrets</strong></p><p>在上面建立的<code>私有仓库（存放Hexo源码的那个仓库)</code>的仓库里边添加TOKEN的环境变量：</p><p> <code>blog私有仓库—&gt;settings—&gt;secrets—&gt;actions—&gt;New repository secret</code></p><p><img src="/notion_images/cf8c2e380bdae147bbc5aa81087039a5.png"></p><p>4<strong>）编写触发的Actions</strong></p><p>在<code>私有仓库（存放Hexo源码的那个仓库)</code>仓库中添加Actions，blogs&#x2F;.github&#x2F;workflows&#x2F;notion-hexo.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span> [<span class="hljs-string">workflow_dispatch</span>, <span class="hljs-string">watch</span>]<br><br><span class="hljs-attr">name:</span> <span class="hljs-string">notion</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">notion:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;test&quot;</span><br>      <span class="hljs-attr">run :</span> <span class="hljs-string">|</span><br><span class="hljs-string">        echo $&#123;&#123; secrets.NOTION_TOKEN &#125;&#125;</span><br><span class="hljs-string">        echo $&#123;&#123; secrets.NOTION_TOKEN_V2 &#125;&#125;</span><br><span class="hljs-string"></span>        <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">submodules:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">修改为你fork的仓库代码地址/notion-blog-actions/notion@main</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.NOTION_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">token_v2:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.NOTION_TOKEN_V2</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">space_id:</span> <span class="hljs-string">&quot;你的spaceid&quot;</span><br>        <span class="hljs-attr">database_id:</span> <span class="hljs-string">&quot;你的database_id&quot;</span><br>        <span class="hljs-attr">output:</span> <span class="hljs-string">&quot;./tmp/&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;migrate image&quot;</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">修改为你fork的仓库代码地址/notion-blog-actions/migrate@main</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">input:</span> <span class="hljs-string">&quot;./tmp/*.md&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;cp md files&quot;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        cp -f tmp/*.md source/_posts/notion/</span><br><span class="hljs-string">        rm -rf tmp</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git</span> <span class="hljs-string">setting</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        git config --global user.email &quot;你的邮箱&quot;</span><br><span class="hljs-string">        git config --global user.name &quot;你的用户名&quot;</span><br><span class="hljs-string"></span>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">update</span> <span class="hljs-string">blog</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        git add source</span><br><span class="hljs-string">        git commit -m &quot;feat: auto update by notion sync&quot;</span><br><span class="hljs-string">        git push</span><br></code></pre></td></tr></table></figure><p><strong>5）在github-actions页面可完成流水线的手动触发</strong></p><p>如此一来我们就是实现了将Notion的Pages自动发布到GithubPages，大家可以根据自己使用习惯和使用方式做调整。</p><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p><strong><strong>使用 Notion Database 管理静态博客文章：</strong></strong><a href="https://lailin.xyz/post/notion-markdown-blog.html">https://lailin.xyz/post/notion-markdown-blog.html</a></p><p><strong>Notion API 简单上手：</strong><a href="https://ews.ink/tech/dev-notion-api/">https://ews.ink/tech/dev-notion-api/</a></p><p><strong><strong>notion API使用：</strong></strong><a href="https://www.zdl.im/article/notionapi">https://www.zdl.im/article/notionapi</a></p><p><strong>使用Hexo+github pages+travis ci搭建好看的个人博客：</strong> <a href="https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/">https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/</a></p><p><strong>利用 Github Actions 自动化部署 Hexo 博客：</strong><a href="https://dreamhomes.top/posts/202111101556/">https://dreamhomes.top/posts/202111101556/</a></p>]]></content>
    
    
    <categories>
      
      <category>分类1</category>
      
      <category>分类2</category>
      
      <category>分类3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker镜像命令</title>
    <link href="/2022/06/21/docker-file/"/>
    <url>/2022/06/21/docker-file/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>Dockerfile 最佳实践：</p><ol><li>使用小基础镜像(例：alpine)</li><li>RUN 指令中最好把所有 shell 命令都放在一起执行，减少 Docker 层</li><li>分阶段构建</li><li>最好声明 Docker 镜像签名</li><li>使用.dockerignore 排除不需要加入 Docker 镜像目录或者文件</li></ol>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"># stage <span class="hljs-number">1</span><br>FROM node:<span class="hljs-number">13.1</span><span class="hljs-number">.0</span>-alpine as builder<br><br>LABEL version=<span class="hljs-string">&quot;node 13.1.0&quot;</span><br><br># 修改alpine源为阿里源，安装tzdata包并修改为北京时间<br>RUN sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories \<br>    &amp;&amp; apk --update add --no-cache tzdata \<br>    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br># 声明环境变量<br>ENV NODE_ENV dev<br><br># 声明使用node用户<br>USER node<br><br># 首次只加入<span class="hljs-keyword">package</span>.json文件，<span class="hljs-keyword">package</span>.json一般不变，这样就可以充分利用Docker Cache，节约安装node包时间<br>COPY --chown=node:node <span class="hljs-keyword">package</span>.json /app &amp;&amp; npm ci<br><br># 声明镜像默认位置<br>WORKDIR /app<br><br># 加入node代码<br>ADD --chown=node:node . /app<br><br># build代码<br>RUN npm run build \<br>    &amp;&amp; mv dist public<br><br># stage <span class="hljs-number">2</span><br># 加入nginx镜像<br>FROM nginx:alpine<br><br># 拷贝上阶段build静态文件<br>COPY --from=builder /app/public /app/public<br><br># 拷贝nginx配置文件<br>COPY nginx.conf /etc/nginx/conf.d/<span class="hljs-keyword">default</span>.conf<br><br># 声明容器端口<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动命令<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure><p>Docker 通过读取<code>Dockerfile</code>来自动构建 Docker 镜像。<code>Dockerfile</code>是一个文本文件用来描述用于组装构建 Docker 镜像的命令，通过<code>docker build . </code>命令完成对 Dockerfile 的构建执行操作从而生成约定产物，形成镜像制品。</p><h1 id="1-Dockerfile-构建"><a href="#1-Dockerfile-构建" class="headerlink" title="1.Dockerfile 构建"></a>1.Dockerfile 构建</h1><h2 id="1-1-构建机制"><a href="#1-1-构建机制" class="headerlink" title="1.1 构建机制"></a>1.1 构建机制</h2><p>docker 构建一个镜像需要：<code>Dockerfile文件</code>、<code>构建所需的上下文</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br></code></pre></td></tr></table></figure><p>这条命令中，docker-cli 会:</p><ol><li>把当前目录及子目录当做上下文传递给 docker 服务</li><li>从当前目录(不包括子目录)中找到 Dockerfile</li><li>检查 Dockerfile 的语法</li><li>依次执行 Dockerfile 中的指令，根据指令生成中间过度镜像(存储在本地，为之后的指令或构建作缓存)</li></ol><p>注意：为了加快构建速度，减少传递给 docker 服务的文件数量，最好将 Dockerfile 放在单独的空目录中。如果目录中含有大量文件，可以使用<code>.dockerignore</code>来忽略构建时用不到的文件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"># comment<br>*/temp*<br>*<span class="hljs-comment">/*/temp*</span><br><span class="hljs-comment">temp?</span><br></code></pre></td></tr></table></figure><h2 id="1-2-镜像缓存机制"><a href="#1-2-镜像缓存机制" class="headerlink" title="1.2 镜像缓存机制"></a>1.2 镜像缓存机制</h2><p>当在构建或者下载镜像时候，当镜像层已经存在的时候则直接使用缓存， 不需要进行重新构建镜像，如果我们希望在构建镜像时不使用缓存，可以在 docker build 命令中加上<code>–no-cache</code>参数。如果我们改变 Dockerfile 指令的执行顺序，或者修改或添加指令，都会使缓存失效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build --no-cache=true ... # --no-cache：不使用缓存，每条指令都重新生成镜像<br></code></pre></td></tr></table></figure><p>Dockerfile 在执行的时候，当有执行过相同的代码并且顺序也一致的情况下，就会使用缓存镜像层进行构建新的镜像。Dockerfile 中每一个指令都会创建一个镜像层，上层是依赖于下层的。</p><div class="note note-warning">            <p>缓存失效：简单来说就是如果第 n 层有改动，则 n 层以后的缓存都会失效，大多数情况下判断有无改动的方法是判断这层的指令和缓存中的构建指令是否一致，但是对于 COPY 和 ADD 命令会计算镜像内的文件和构建目录文件的校验和然后做比较来判断本层是否有改动。</p>          </div><h2 id="1-3-格式要求"><a href="#1-3-格式要求" class="headerlink" title="1.3 格式要求"></a>1.3 格式要求</h2><p>虽然 Dockerfile 并不区分大小写，但还是约定指令使用大写。<br>Dockerfile 的第一条可执行指令必须是 FROM。<br>以#开头的是注释，行内的#都被当做参数，并且不支持续行。</p><h1 id="2-Dockerfile-指令"><a href="#2-Dockerfile-指令" class="headerlink" title="2.Dockerfile 指令"></a>2.Dockerfile 指令</h1><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建，常用的指令如下：</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><strong>用途：构建的镜像继承自某个 base image</strong>。FROM 指令必须是 Dockerfile 的第一个指令，可以使用多次来构建多个镜像，以最后一个镜像的 ID 为输出值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]<br>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]<br>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>platform：</strong>用于标识 Docker 镜像平台架构，例如：<code>linux/amd64</code>、<code>linux/arm64</code>或<code>windows/amd64</code></li><li><strong>tag：</strong>镜像标签，默认为<code>latest</code>。如果无法找到该 tag 值，构建器将返回错误。</li><li><strong>digest：</strong>可寻址标识符，镜像的二进制 ID，主要用于验证所下载镜像的<code>完整性</code>和<code>防篡改性</code>。</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p><strong>用途：</strong>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">RUN &lt;command&gt; # shell 格式<br>RUN [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br></code></pre></td></tr></table></figure><p><strong>使用原则：</strong></p><ul><li>尽量减少一个 Dockerfile 中的 RUN 命令的个数。<strong>RUN 命令在构建时会创建一个新层，如非特殊的需要，建议一个 Dockerfile 在需要使用 RUN 命令的时候尽可能的只用一个 RUN 命令，将多条 RUN 命令进行合并可以有效降低构建的镜像的层数</strong>。</li><li>使用&amp;&amp;连接多条命令，例如：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN apt-get update &amp;&amp; apt-get install -y \<br>package-bar\<br>package-baz \<br>package-foo<br></code></pre></td></tr></table></figure><ul><li>避免复杂的逻辑实现</li></ul><p><strong>关于缓存失效：</strong></p><div class="note note-warning">            <p> 在通常情况下，构建镜像后，所有的层都在 Docker 缓存中，假设后来又修改了其中的 apt-get install 命令，在添加一个包时， Docker 发现修改后的 RUN apt-get update 命令和之前的完全一样。<br>这时，不会执行 RUN apt-get update 命令，而是使用之前的缓存镜像。因为 RUN apt-get update 命令没有执行，后面的 apt-get install 命令安装的可能是过期的软件版本或提示没有可用源。<br>使用 RUN apt-get update &amp;&amp; apt-get install -y 命令可以确保 Dockerfiles 配置文件每次安装的都是包的最新版本，而且这个过程不需要进一步编码或额外干预 ，这项技术叫作缓存破坏( Cache Busting ）。</p>          </div><h3 id="MAINTAINER-deprecated"><a href="#MAINTAINER-deprecated" class="headerlink" title="MAINTAINER (deprecated)"></a>MAINTAINER (deprecated)</h3><p>已废弃，使用 LABEL 命令代替。</p><h3 id="ADD-amp-amp-COPY"><a href="#ADD-amp-amp-COPY" class="headerlink" title="ADD &amp;&amp; COPY"></a>ADD &amp;&amp; COPY</h3><p><strong>用途：</strong>ADD 和 COPY 命令都是在构建镜像时， <strong>将 src 路径复制新文件、目录或远程文件 URL，并将它们添加到图像的文件系统中 dest</strong>，但一般优先使用 COPY 命令，因为 ADD 命令比 COPY 命令更加透明。ADD 相较于 COPY 除了支持从本地复制文件到镜像，ADD 指令还支持通过 URL 从远程服务器读取资源并复制到镜像中。</p><div class="note note-success">            <p>事实上当要从远程获取资源的时候推荐使用 RUN 命令：<code>RUN wget</code>或<code>RUN curl</code>，而 ADD 指令更擅长读取本地 tar 文件并解压缩 </p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]<br><br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>**chown&#x3D;user:group **当执行 ADD、COPY 指令时源文件的各种元数据都会保留，比如读、写、执行权限、文件变更时间等，可以通过 <code>--chown=&lt;user&gt;:&lt;group&gt; </code>选项来改变文件的所属用户及所属组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD/COPY --chown=<span class="hljs-number">55</span>:mygroup files* /somedir/<br>ADD/COPY --chown=bin files* /somedir/<br>ADD/COPY --chown=<span class="hljs-number">1</span> files* /somedir/<br>ADD/COPY --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* /somedir/<br></code></pre></td></tr></table></figure><ul><li><strong>src：</strong>拷贝源文件路径，src 可以使用通配符，将使用 Go 的 <a href="https://pkg.go.dev/path/filepath#Match">filepath.Match</a> 规则匹配完成。例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD hom* /mydir/<br>ADD hom?.txt /mydir/<br></code></pre></td></tr></table></figure><ul><li><strong>dest：</strong>拷贝到镜像的目标路径，可以是容器内的绝对路径，也可以是工作目录相对路径（工作目录可以用 WORKDIR 指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li></ul><h3 id="CMD-amp-amp-ENTRYPOINT"><a href="#CMD-amp-amp-ENTRYPOINT" class="headerlink" title="CMD &amp;&amp; ENTRYPOINT"></a>CMD &amp;&amp; ENTRYPOINT</h3><p><strong>用途：</strong>CMD 命令和 ENTRYPOINT 命令部可以用于设置容器启动时要执行的命令， Dockerfile 置文件中 CMD 或 ENTRYPOINT 必须至少有其一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">CMD [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br>CMD command param1 param2  # shell格式<br>CMD [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]  # exec参数，用来为ENTRYPOINT 提供参数<br><br>ENTRYPOINT [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br>ENTRYPOINT command param1 param2 # shell格式<br>## 例如：<br>CMD java -jar demo.jar<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;demo.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>CMD 和 ENTRYPOINT 区别：</strong></p><ul><li>CMD 设置的命令能够被 docker run 命令后面的命令所覆盖，而 ENTRYPOINT 则不会。</li></ul><div class="note note-success">            <p>与 RUN 命令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD、ENTRYPOINT 在容器运行的时候执行，在构建时不进行任何操作。</p>          </div><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p><strong>用途：</strong>镜像打标签</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>如果 base image 中也有标签，则继承，如果是同名标签，则覆盖。</li><li>为了减少图层数量，尽量将标签写在一个 LABEL 指令中去，如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">LABEL multi.label1=<span class="hljs-string">&quot;value1&quot;</span> \<br>      multi.label2=<span class="hljs-string">&quot;value2&quot;</span> \<br>      other=<span class="hljs-string">&quot;value3&quot;</span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><strong>用途：</strong>为构建的镜像设置监听端口，使容器在运行时监听。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>EXPOSE 指令并不会让容器监听 Host 的端口，如果需要，需要在 docker run 时使用-p 参数来发布容器端口到 Host 的某个端口上。</p>          </div><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><strong>用途：</strong>在构建的镜像中设置环境变量，在后续的 Dockerfile 指令中可以直接使用，也可以固化在镜像里，在容器运行时仍然有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ENV &lt;key&gt; &lt;value&gt;<br>ENV &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>ENV key value：把第一个空格之后的所有值都当做<key>的值，无法在一行内设定多个环境变量。</li><li>ENV key&#x3D;value …：可以设置多个环境变量，如果<value>中存在空格，需要转义或用引号”括起来。</li></ul><div class="note note-success">            <p>可以在容器运行时指定环境变量，替换镜像中的已有变量，docker run –env key&#x3D;value<br>推荐使用在一行中写多个环境变量，减少图层</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ENV myName=<span class="hljs-string">&quot;John Doe&quot;</span> \<br>    myDog=Rex\ The\ Dog \<br>    myCat=fluffy<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><strong>用途：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">VOLUME [<span class="hljs-string">&quot;/data&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><strong>用途：</strong>为接下来的 Dockerfile 指令指定当前工作目录，可多次使用，如果使用的是相对路径，则相对的是上一个工作目录，类似 shell 中的 cd 命令。<br>影响的指令有：<code>RUN、CMD、ENTRYPOINT、COPY和ADD。</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">WORKDIR /path/to/workdir<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>建议使用 WORKDIR 命令来代替类似于 RUN cd … &amp;&amp; do -something 等的命令，因为后者难以阅读维护</p>          </div><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><strong>用途： <strong>设置镜像构建时的环境变量，使用效果 ENV 一样。所不同的是，</strong>ARG 所设置环境变量生命周期仅在镜像构建期间</strong>，在将来容器运行时是不会存在这些环境变量的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ARG &lt;name&gt;[=&lt;<span class="hljs-keyword">default</span> value&gt;]<br></code></pre></td></tr></table></figure><p><strong>使用方法：</strong><br>当 Dockerfile 指定 ARG 参数时可通过<code>docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code>传入参数值进行覆盖。<br>docker 内置了一批构建参数，可以不用在 Dockerfile 中声明：<code>HTTP_PROXY、http_proxy、HTTPS_PROXY、https_proxy、FTP_PROXY、ftp_proxy、NO_PROXY、no_proxy</code></p><h3 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h3><p><strong>用途：</strong>创建一个可以从<strong>本地主机</strong>或<strong>其它容器挂载</strong>的挂载点，用来保持数据不被销毁。Volume 可以在容器之间以及容器和主机之间共享和重用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 命令会将&quot;/data&quot;目录挂载到容器 ，开发人员可以在宿主机上直接操作该目录，</span><br><span class="hljs-comment"># 任何在该镜像&quot;/data&quot;目录中的文件都将被复制到 Volume中。</span><br>docker run -it --name container-test -h CONTAINER -v <span class="hljs-regexp">/data nginx /</span>bin/bash<br><span class="hljs-comment"># 可以找到容器与宿主机的挂载关系</span><br>docker inspect -f &#123;&#123;.Volumes&#125;&#125; container-test<br><span class="hljs-comment"># 在宿主机的目录下创建一个文件，然后进入容器的/data目录下会相应看到创建的文件</span><br>sudo touch <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>vfs<span class="hljs-regexp">/dir/</span>cde1671***<span class="hljs-number">37</span>a9/test-file<br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>和 Linux 不同，在 mac 上用 docker 会在 mac 上启动一个虚拟机运行 docker，因此 volume 创建的 directory 并不在你的 machine 上，而是在虚拟机中。</p>          </div><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><strong>用途：</strong>向镜像中添加一个触发器，当以该镜像为 base image 再次构建新的镜像时，会触发执行其中的指令。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ONBUILD</span><span class="hljs-meta"> [INSTRUCTION]</span><br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 在下一次以此镜像为base image的构建中，执行ADD . /app/src，将项目代目添加到新镜像中去</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="language-bash"> . /app/src</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>ONBUILD 只会继承给子节点的镜像，不会再继承给孙子节点。<br>ONBUILD ONBUILD 或者 ONBUILD FROM 或者 ONBUILD MAINTAINER 是不允许的。</p>          </div><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><strong>用途：</strong>增加自定义的心跳检测功能，多次使用只有最后一次有效。格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [OPTION] CMD &lt;<span class="hljs-built_in">command</span>&gt;  <span class="hljs-comment"># 通过在容器内运行command来检查心跳</span></span><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> NONE                    <span class="hljs-comment"># 取消从base image继承来的心跳检测</span></span><br></code></pre></td></tr></table></figure><p><strong>可选的 OPTION：</strong><br><code>--interval=DURATION：</code>检测间隔，默认 30 秒；<br><code>--timeout=DURATION：</code>命令超时时间，默认 30 秒；<br><code>--retries=N：</code>连续 N 次失败后标记为不健康，默认 3 次；<br><command>可以是 shell 脚本，也可以是 exec 格式的 json 数组。<br>docker 以<command>的退出状态码来区分容器是否健康，这一点同 shell 一致：</p><ul><li>0：命令返回成功，容器健康</li><li>1：命令返回失败，容器不健康</li><li>2：保留状态码，不要使用&#96;</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 每5分钟检测本地网页是否可访问，超时设为3秒：</span><br>HEALTHCHECK --interval=<span class="hljs-number">5</span>m --timeout=<span class="hljs-number">3</span>s \<br>    CMD curl -f http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用途：指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。<strong>容器不推荐使用 root 权限。</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">&lt;user</span>&gt;[:<span class="hljs-tag">&lt;group&gt;</span>]<br><span class="hljs-comment"># 声明使用node用户</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">node</span><br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/qianlei90/Blog/issues/35">https://github.com/qianlei90/Blog/issues/35</a><br><a href="https://segmentfault.com/a/1190000018222648">https://segmentfault.com/a/1190000018222648</a><br><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">https://docs.docker.com/engine/reference/builder/#dockerignore-file</a><br><a href="https://mp.weixin.qq.com/s/vjD-JDw_2bYWa2InUfWHow">https://mp.weixin.qq.com/s/vjD-JDw_2bYWa2InUfWHow</a><br><a href="https://mp.weixin.qq.com/s/ojZvxQTssqERueGahFGCbQ">https://mp.weixin.qq.com/s/ojZvxQTssqERueGahFGCbQ</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dockerfile</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-New-Post</title>
    <link href="/2022/06/15/undefined/"/>
    <url>/2022/06/15/undefined/</url>
    
    <content type="html"><![CDATA[<p>sdf</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h5 id="五级"><a href="#五级" class="headerlink" title="五级"></a>五级</h5>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
