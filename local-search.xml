<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker网络</title>
    <link href="/2022/07/04/docker-network/"/>
    <url>/2022/07/04/docker-network/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h5 id="五级"><a href="#五级" class="headerlink" title="五级"></a>五级</h5>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker核心技术原理</title>
    <link href="/2022/07/01/docker-principle/"/>
    <url>/2022/07/01/docker-principle/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h5 id="五级"><a href="#五级" class="headerlink" title="五级"></a>五级</h5>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerCLI容器指令</title>
    <link href="/2022/06/24/docker-cli-command/"/>
    <url>/2022/06/24/docker-cli-command/</url>
    
    <content type="html"><![CDATA[<p>Docker 镜像是由 <code>Dockerfile</code>和一些<code>必要的依赖项</code>组成的，Docker 容器是运行态的 Docker 镜像。要使用 Docker 命令，首先需要知道<code>在处理镜像还是容器</code>。一旦你知道你所处理的是镜像还是容器之后，你才可以找到正确的命令。</p><p>Docker 镜像是由<code>Dockerfile</code>描述生成的，对于 Docker 镜像的构建、运行、状态查看、停止、销毁则是由<code>Docker CLI</code>相关指令完成的。Docker CLI 指令可以分为如下几类：<code>镜像指令</code>、<code>容器生命周期指令</code>、<code>容器操作指令</code>、<code>容器仓库指令</code>、<code>容器rootfs指令</code>。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FrxvF9Hg4bGQWbEzRydmuhxBNYmV.png"></p><h1 id="1-镜像指令"><a href="#1-镜像指令" class="headerlink" title="1.镜像指令"></a>1.镜像指令</h1><h2 id="images-显示本地镜像"><a href="#images-显示本地镜像" class="headerlink" title="images 显示本地镜像"></a>images 显示本地镜像</h2><p><strong>用途：</strong>用于显示本地镜像列表包括：镜像名称、镜像所属仓库、镜像 tag、镜像大小等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a : 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br>--digests : 显示镜像的摘要信息；<br>-f : 显示满足条件的镜像；<br>--format  : 指定返回值的模板文件；<br>--no-trunc : 显示完整的镜像信息；<br>-q : 只显示镜像 ID。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">展示镜像列表</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                               TAG       IMAGE ID       CREATED         SIZE<br>nginx                                    latest    cd4e03b35a8e   3 days ago      134MB<br>k8s.gcr.io/kube-apiserver                v1.24.0   b62a103951f4   7 weeks ago     126MB<br>k8s.gcr.io/kube-controller-manager       v1.24.0   59fad34d4fe0   7 weeks ago     116MB<br>k8s.gcr.io/kube-proxy                    v1.24.0   66e1443684b0   7 weeks ago     106MB<br>k8s.gcr.io/kube-scheduler                v1.24.0   b81513b3bfb4   7 weeks ago     50MB<br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据name或者tag进行筛选展示</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"> docker images k8s.gcr.io/etcd</span><br>REPOSITORY        TAG       IMAGE ID       CREATED        SIZE<br>k8s.gcr.io/etcd   3.5.3-0   a9a710bb96df   2 months ago   178MB<br><span class="hljs-meta prompt_"># </span><span class="language-bash">过滤出tag为空的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images --filter <span class="hljs-string">&quot;dangling=true&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除tag为空的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi $(docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span> -q)</span><br></code></pre></td></tr></table></figure><h2 id="rmi-删除本地镜像"><a href="#rmi-删除本地镜像" class="headerlink" title="rmi 删除本地镜像"></a>rmi 删除本地镜像</h2><p><strong>用途：</strong>删除本地一个或者多个镜像。如果镜像带了标签的，那么只会删除 img:tag 镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-f : 强制删除；<br>--no-prune : 不移除该镜像的过程镜像，默认移除；<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi fd484f19954f</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi test1:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker rmi <span class="hljs-built_in">test</span>:latest</span><br></code></pre></td></tr></table></figure><h2 id="tag-镜像打标签"><a href="#tag-镜像打标签" class="headerlink" title="tag 镜像打标签"></a>tag 镜像打标签</h2><p><strong>用途：</strong>为镜像打上标签，让其有归属的仓库或者标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag 0e5574283393 fedora/httpd:version1.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag httpd fedora/httpd:version1.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag httpd:<span class="hljs-built_in">test</span> fedora/httpd:version1.0.test</span><br><br></code></pre></td></tr></table></figure><h2 id="build-构建镜像"><a href="#build-构建镜像" class="headerlink" title="build 构建镜像"></a>build 构建镜像</h2><p><strong>用途：</strong>从<code>Dockerfile</code>和<code>上下文</code>构建 Docker 映像，构建的上下文是位于指定 PATH 或 URL。该 URL 参数可以引用三种资源：<code>Git 存储库</code>、<code>预打包的 tarball 上下文</code>和<code>纯文本文件</code>。<br><strong>用途：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build [OPTIONS] PATH | URL | -</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">--add-host :添加一个自定义的host-ip映射，(host:ip)<br>--build-arg=[] :设置镜像创建时的变量；<br>--cpu-shares :设置 cpu 使用权重；<br>--cpu-period :限制 CPU CFS 周期；<br>--cpu-quota :限制 CPU CFS 配额；<br>--cpuset-cpus :指定使用的 CPU id；<br>--cpuset-mems :指定使用的内存 id；<br>--disable-content-trust :忽略校验，默认开启；<br>--file，-f :指定要使用的 Dockerfile 路径；<br>--force-rm :设置镜像过程中删除中间容器；<br>--isolation :使用容器隔离技术；<br>--label=[] : 置镜像使用的元数据；<br>-m : 设置内存最大值；<br>--memory-swap :设置 Swap 的最大值为内存 + swap，&quot;-1&quot; 表示不限 swap；<br>--no-cache :创建镜像的过程不使用缓存；<br>--pull :尝试去更新镜像的新版本；<br>--quiet, -q :安静模式，成功后只输出镜像 ID；<br>--rm :设置镜像成功后删除中间容器；<br>--shm-size :设置 /dev/shm 的大小，默认值是 64M；<br>--ulimit :Ulimit 配置。<br>--tag, -t :镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>--network :默认 default。在构建期间设置 RUN 指令的网络模式<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用Dockerfile</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从Git仓库构建</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build github.com/creack/docker-firefox</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从远程文件构建</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -f ctx/Dockerfile http://server/ctx.tar.gz</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时设定tag元数据</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t vieux/apache:2.0 .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时设置变量信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build --build-arg HTTP_PROXY=http://10.20.30.2:1234 --build-arg FTP_PROXY=http://40.50.60.5:4567 .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> HTTP_PROXY=http://10.20.30.2:1234</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build --build-arg HTTP_PROXY .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建时设置host信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build --add-host=docker:10.180.0.1 .</span><br></code></pre></td></tr></table></figure><h2 id="history-镜像构建历史"><a href="#history-镜像构建历史" class="headerlink" title="history 镜像构建历史"></a>history 镜像构建历史</h2><p><strong>用途：</strong>查看指定镜像的创建历史。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">history</span> [OPTIONS] IMAGE</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-H : 以可读的格式打印镜像大小和日期，默认为 true<br>--no-trunc : 显示完整的提交记录<br>-q : 仅列出提交记录 ID<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">history</span> busybox</span><br>IMAGE          CREATED       CREATED BY                                      SIZE      COMMENT<br>3c19bafed223   2 weeks ago   /bin/sh -c #(nop)  CMD [&quot;sh&quot;]                   0B<br>&lt;missing&gt;      2 weeks ago   /bin/sh -c #(nop) ADD file:d0bcfa7c7f5145e0b…   1.41MB<br></code></pre></td></tr></table></figure><h2 id="save-镜像归档"><a href="#save-镜像归档" class="headerlink" title="save 镜像归档"></a>save 镜像归档</h2><p><strong>用途：</strong>将指定<code>镜像</code>保存成 tar 归档文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-o : 输出到的文件。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将镜像busybox:latest 归档存放到：~/Downloads/并以busybox-latest.tar命名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">save -o ~/Downloads/busybox-latest.tar busybox:latest</span><br></code></pre></td></tr></table></figure><h2 id="export-镜像归档"><a href="#export-镜像归档" class="headerlink" title="export 镜像归档"></a>export 镜像归档</h2><p><strong>用途：</strong>将<code>container的文件系统</code>进行打包并归档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> [OPTIONS] CONTAINER</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-o : 将输入内容写到目标文件<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE            COMMAND   CREATED          STATUS         PORTS     NAMES<br>0f8ba3648e84   busybox:latest   &quot;sh&quot;      10 seconds ago   Up 9 seconds             zen_shirley<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> -o ~/Downloads/busybox-6-26.tar 0f8ba3648e84</span><br></code></pre></td></tr></table></figure><h2 id="load-加载镜像"><a href="#load-加载镜像" class="headerlink" title="load 加载镜像"></a>load 加载镜像</h2><p><strong>用途：</strong>从 tar 中导入 docker 镜像文件，该文件一般就是使用<code>docker save</code>命令导出的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load [OPTIONS]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--input , -i : 指定导入的文件，代替 STDIN。<br>--quiet , -q : 精简输出信息。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load --input fedora.tar</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker load &lt; busybox.tar.gz</span><br></code></pre></td></tr></table></figure><h2 id="import-导入镜像"><a href="#import-导入镜像" class="headerlink" title="import 导入镜像"></a>import 导入镜像</h2><p><strong>用途：</strong>从 tar 归档文件中创建镜像，该文件一般就是使用<code>docker export</code>命令导出的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker import busybox-6-26.tar busybox:v6.27</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>busybox      v6.27     22f3c125f894   2 seconds ago   1.41MB<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>save&#x2F;export 、load&#x2F;import 区别：</strong><br>docker save 保存的是镜像（image），docker export 保存的是容器（container）；<br>docker load 用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像；<br>docker load 不能对载入的镜像重命名，而 docker import 可以为镜像指定新名称。</p>          </div><h1 id="2-容器生命周期指令"><a href="#2-容器生命周期指令" class="headerlink" title="2.容器生命周期指令"></a>2.容器生命周期指令</h1><h2 id="run-从镜像运行一个容器"><a href="#run-从镜像运行一个容器" class="headerlink" title="run - 从镜像运行一个容器"></a>run - 从镜像运行一个容器</h2><p>Docker 容器是 Docker 镜像的运行形态，<code>Docker容器是一个资源受限、视图隔离的进程</code>。当运行<code>docker run</code>命令时，Docker 会启动一个进程，并为这个进程分配其独占的文件系统、网络资源和以此进程为根进程的进程组。<br>在容器启动时，镜像可能已经定义了要运行的二进制文件（通过 Dockerfile）、暴露的网络端口等，但是用户可以通过 docker run 命令重新定义。</p><div class="note note-info">            <p>docker run 可以控制一个容器运行时的行为，它可以覆盖 docker build 在构建镜像时的一些默认配置，这也是为什么 run 命令相比于其它命令有如此多的参数的原因。<br>docker run [OPTIONS]可以让用户完全控制容器的生命周期，并允许用户覆盖执行 docker build 时所设定的参数，甚至也可以修改本身由 Docker 所控制的内核级参数。</p>          </div><p><strong>命令格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数汇总：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>-a stdin : 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>-d : 后台运行容器，并返回容器 ID；<br>-i : 以交互模式运行容器，通常与 -t 同时使用；<br>-P : 随机端口映射，容器内部端口随机映射到主机的端口<br>-p : 指定端口映射，格式为：主机 (宿主) 端口：容器端口<br>-t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>--name=&quot;nginx-lb&quot;: 为容器指定一个名称；<br>--dns 8.8.8.8 : 指定容器使用的 DNS 服务器，默认和宿主一致；<br>--dns-search example.com: 指定容器 DNS 搜索域名，默认和宿主一致；<br>-h &quot;mars&quot;  : 指定容器的 hostname；<br>-e username=&quot;ritchie&quot;: 设置环境变量；<br>--env-file=[] : 从指定文件读入环境变量；<br>--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定 CPU 运行；<br>-m  : 设置容器使用内存最大值；<br>--net=&quot;bridge&quot; : 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>--link=[] : 添加链接到另一个容器；<br>--expose=[]  : 开放一个端口或一组端口；<br>--volume  : -v 绑定一个卷<br></code></pre></td></tr></table></figure><p><strong>COMMAND 参数：</strong><br>这个命令中的<code>COMMAND</code>部分是可选的。因为这个 IMAGE 在<code>build</code>时，开发人员可能已经设定了默认执行的命令。作为操作人员，你可以使用上面命令中新的 command 来覆盖旧的 command。<br>如果镜像中设定了<code>ENTRYPOINT</code>，那么命令中的<code>CMD</code>也可以作为参数追加到<code>ENTRYPOINT</code>中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">--entrypoint=&quot;&quot;: Overwrite the default entrypoint set by the image<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 例如：</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -it --entrypoint /bin/bash example/redis</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -it --entrypoint /bin/bash example/redis -c <span class="hljs-built_in">ls</span> -l</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -it --entrypoint /usr/bin/redis-cli example/redis --<span class="hljs-built_in">help</span></span><br></code></pre></td></tr></table></figure><p><code>docker run [OPTIONS]</code> OPTIONS 参数比较多总起来说可以分为两类：</p><ol><li>设置运行方式：<ul><li>决定容器的运行方式，前台执行还是后台执行；</li><li>设置运行唯一标志；</li><li>设置网络参数；</li><li>设置容器的 CPU 和内存资源限额参数；</li><li>设置权限和 LXC 参数；</li></ul></li><li>设置镜像的默认资源，也就是说用户可以使用该命令来覆盖在镜像构建时的一些默认配置。</li></ol><h3 id="设置容器运行方式"><a href="#设置容器运行方式" class="headerlink" title="设置容器运行方式"></a>设置容器运行方式</h3><p><strong>Detached vs foreground：</strong>当我们启动一个容器时，首先需要确定这个容器是运行在前台还是运行在后台。</p><ul><li><strong>Detached (-d)</strong></li></ul><p>如果在<code>docker run</code>后面追加<code>-d=true 或者 -d</code>，那么容器将会运行在后台模式。此时所有 I&#x2F;O 数据只能通过网络资源或者共享卷组来进行交互。因为容器不再监听你执行 docker run 的这个终端命令行窗口。但你可以通过执行 docker attach 来重新附着到该容器的回话中。需要注意的是，容器运行在后台模式下，是不能使用–rm 选项的。</p><ul><li><strong>Foregroud</strong></li></ul><p>在前台模式下（不指定-d 参数即可），Docker 会在容器中启动进程，同时将当前的命令行窗口附着到容器的标准输入、标准输出和标准错误中。也就是说容器中所有的输出都可以在当前窗口中看到。甚至它都可以虚拟出一个 TTY 窗口，来执行信号中断。这一切都是可以配置的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a=[]          　: Attach to `STDIN`, `STDOUT` and/or `STDERR`<br>-t=false         : Allocate a pseudo-tty<br>--sig-proxy=true : Proxify all received signal to the process (non-TTY mode only)<br>-i=false         : Keep STDIN open even if not attached<br></code></pre></td></tr></table></figure><h3 id="设置容器运行标识"><a href="#设置容器运行标识" class="headerlink" title="设置容器运行标识"></a>设置容器运行标识</h3><ul><li><strong>Name（–name）</strong></li></ul><p>可以通过三种方式为容器命名:</p><ol><li>使用 UUID 长命名（”f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”）</li><li>使用 UUID 短命令（”f78375b1c487”）</li><li>使用 Name(“evil_ptolemy”)<br>这个 UUID 标示是由 Docker deamon 生成的。如果你在执行 docker run 时没有指定–name，那么 deamon 会自动生成一个随机字符串 UUID。<strong>但是对于一个容器来说有个 name 会非常方便，当你需要连接其它容器时或者类似需要区分其它容器时，使用容器名称可以简化操作。</strong>无论容器运行在前台或者后台，这个名字都是有用的。</li></ol><ul><li><strong>PID equivalent</strong></li></ul><p>如果在使用 Docker 时有自动化的需求，你可以将 containerID 输出到指定的文件中（PIDfile），类似于某些应用程序将自身 ID 输出到文件中，方便后续脚本操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--cidfile=&quot;&quot;: Write the container ID to the file<br></code></pre></td></tr></table></figure><ul><li><strong>Image[:tag]</strong></li></ul><p>当一个镜像的名称不足以分辨这个镜像所代表的含义时，你可以通过 tag 将版本信息添加到 run 命令中，以执行特定版本的镜像。例如:<code> docker run ubuntu:14.04</code></p><ul><li><strong>IPC Settings</strong></li></ul><p>默认情况下，所有容器都开启了 IPC 命名空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--ipc=&quot;&quot;  : Set the IPC mode for the container,<br>          &#x27;container:&lt;name|id&gt;&#x27;: reuses another container&#x27;s IPC namespace<br>          &#x27;host&#x27;: use the host&#x27;s IPC namespace inside the container<br></code></pre></td></tr></table></figure><p><strong>IPC（POSIX&#x2F;SysV IPC）命名空间提供了相互隔离的命名共享内存、信号灯变量和消息队列。</strong></p><div class="note note-info">            <p>共享内存可以提高进程数据的交互速度。共享内存一般用在数据库和高性能应用（C&#x2F;OpenMPI、C++&#x2F;using boost libraries）上或者金融服务上。如果需要容器中部署上述类型的应用，那么就应该在多个容器直接使用共享内存了。</p>          </div><h3 id="设置容器运行网络"><a href="#设置容器运行网络" class="headerlink" title="设置容器运行网络"></a>设置容器运行网络</h3><p>默认情况下，所有的容器都开启了网络接口，同时可以接受任何外部的数据请求。<br><strong>网络设置参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">--dns=[]           : Set custom dns servers for the container<br>--network=&quot;bridge&quot; : Connect a container to a network<br>&#x27;bridge&#x27;: create a network stack on the default Docker bridge<br>&#x27;none&#x27;: no networking<br>&#x27;container:&lt;name|id&gt;&#x27;: reuse another container&#x27;s network stack<br>&#x27;host&#x27;: use the Docker host network stack<br>&#x27;&lt;network-name&gt;|&lt;network-id&gt;&#x27;: connect to a user-defined network<br>--network-alias=[] : Add network-scoped alias for the container<br>--add-host=&quot;&quot;      : Add a line to /etc/hosts (host:IP)<br>--mac-address=&quot;&quot;   : Sets the container&#x27;s Ethernet device&#x27;s MAC address<br>--ip=&quot;&quot;            : Sets the container&#x27;s Ethernet device&#x27;s IPv4 address<br>--ip6=&quot;&quot;           : Sets the container&#x27;s Ethernet device&#x27;s IPv6 address<br>--link-local-ip=[] : Sets one or more container&#x27;s Ethernet device&#x27;s link local IPv4/IPv6 addresses<br></code></pre></td></tr></table></figure><p>你可以通过<code>docker run --net none</code>来关闭网络接口，此时将关闭所有网络数据的输入输出，你只能通过 STDIN、STDOUT 或者 files 来完成 I&#x2F;O 操作。<br><strong>–dns：</strong>默认情况下，容器使用主机的 DNS 设置，你也可以通过–dns 来覆盖容器内的 DNS 设置。<br><strong>–mac-address：</strong>同时 Docker 为容器默认生成一个 MAC 地址，你可以通过<code>--mac-address 12:34:56:78:9a:bc</code>来设置你自己的 MAC 地址。<br><strong>–add-host：</strong><code>/etc/hosts</code>文件中会包含容器的 hostname 信息，我们也可以使用<code>--add-host</code>这个参数来动态添加<code>/etc/hosts</code>中的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --add-host db-static:86.75.30.9 ubuntu <span class="hljs-built_in">cat</span> /etc/hosts</span><br>127.0.0.1       localhost<br>::1             localhost ip6-localhost ip6-loopback<br>86.75.30.9      db-static<br></code></pre></td></tr></table></figure><p><strong>–mac-address：</strong>设置容器的网卡 mac 地址。<br><strong>–ip：</strong>设置容器网卡的 IPv4 地址。<br><strong>–ip6：</strong>设置容器网卡的 Pv6 地址。</p><p><strong>Docker 支持的网络模式有：</strong></p><table><thead><tr><th><strong>网络模式</strong></th><th><strong>简介</strong></th></tr></thead><tbody><tr><td><strong>none</strong></td><td>关闭容器内的网络连接</td></tr><tr><td><strong>bridge（default）</strong></td><td>通过 veth 接口来连接容器（连接到 docker0 的虚拟网桥）</td></tr><tr><td><strong>host</strong></td><td>使用宿主机的 IP 和端口。注意：这种方式将允许容器访问 host 中类似 D-BUS 之类的系统服务，所以认为是不安全的。</td></tr><tr><td><strong>container</strong></td><td>使用另外一个制定的容器的网络堆栈信息</td></tr></tbody></table><p>将网络模式设置为<code>none</code>时，这个容器将不允许访问任何外部 router。这个容器内部只会有一个 loopback 接口，而且不存在任何可以访问外部网络的 router。<br><strong>Bridge 模式</strong><br>Docke r 默认会将容器设置为 bridge 模式。此时在主机上面将会存在一个<code>docker0</code>的网络接口，同时会针对容器创建一对 veth 接口。其中一个 veth 接口是在主机充当网卡桥接作用，另外一个 veth 接口存在于容器的命名空间中，并且指向容器的 loopback。Docker 会自动给这个容器分配一个 IP，并且将容器内的数据通过桥接转发到外部。<br><strong>Host 模式</strong><br>当网络模式设置为 host 时，这个容器将完全共享 host 的网络堆栈。host 所有的网络接口将完全对容器开放。容器的主机名也会存在于主机的 hostname 中。这时，容器所有对外暴露的端口和对其它容器的连接，将完全失效。<br><strong>Container 模式</strong><br>当网络模式设置为 Container 时，这个容器将完全复用另外一个容器的网络堆栈。同时使用时这个容器的名称必须要符合下面的格式：<code>--net container:&lt;name|id&gt;</code><br>例如：当前有一个绑定了本地地址 localhost 的 Redis 容器。如果另外一个容器需要复用这个网络堆栈，则需要如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run -d --name redis example/redis --<span class="hljs-built_in">bind</span> 127.0.0.1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># use the redis container&#x27;s network stack to access localhost</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo docker run --<span class="hljs-built_in">rm</span> -ti --net container:redis example/redis-cli -h 127.0.0.1</span><br></code></pre></td></tr></table></figure><h3 id="设置容器运行资源限额"><a href="#设置容器运行资源限额" class="headerlink" title="设置容器运行资源限额"></a>设置容器运行资源限额</h3><ul><li><strong>内存限制：</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-m,--memory :内存限制，格式是数字加单位，单位可以为 b,k,m,g,最小为 4M<br>--memory-swap :内存+交换分区大小总限制。单位可以为 b,k,m,g,最小为 4M<br>--memory-reservation :内存的软性限制。单位可以为 b,k,m,g,最小为 4M<br>--oom-kill-disable :是否阻止 OOM killer 杀死容器，默认没设置<br>--oom-score-adj :容器被 OOM killer 杀死的优先级，范围是[-1000, 1000]，默认为 0<br>--memory-swappiness :用于设置容器的虚拟内存控制行为。值为 0~100 之间的整数<br>--kernel-memory :内核内存限制<br></code></pre></td></tr></table></figure><p><strong>–memory-reservation：</strong>Memory reservation 用于节制容器内存使用。给<code>--memory-reservation</code>设置一个比<code>-m</code>小的值后，虽然容器最多可以使用<code>-m</code>使用的内存大小，<strong>但在宿主机内存资源紧张时，在系统的下次内存回收时，系统会回收容器的部分内存页，强迫容器的内存占用回到–memory-reservation 设置的值大小</strong>。</p><div class="note note-info">            <p>Memory reservation 是一种软性机制，它不保证任何时刻容器使用的内存不会超过<code>--memory-reservation</code>限定的值，它只是确保容器不会长时间占用超过<code>--memory-reservation</code>限制的内存大小。<br>超过一段时间后，会被宿主机系统杀死（如果没有设置<code>--00m-kill-disable=true</code>的话）。</p>          </div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">若容器使用了&gt;200M and &lt;500M内存时，下次系统的内存回收会尝试将容器的内存锁紧到200M以下。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it -m 500M --memory-reservation 200M ubuntu:16.04 /bin/bash</span><br></code></pre></td></tr></table></figure><p>用户内存限制就是对容器能使用的内存和交换分区的大小作出限制。使用时要遵循两条直观的规则：<code>-m，--memory</code>选项的参数最小为 4 M。<code>--memory-swap</code>不是交换分区，而是内存加交换分区的总大小，所以<code>--memory-swap</code>必须比<code>-m,--memory</code>大。</p><div class="note note-success">            <p><strong>不设置-m,–memory 和–memory-swap</strong><br>此时容器默认可以用完宿舍机的所有内存和 swap 分区。不过注意，如果容器占用宿主机的所有内存和 swap 分区超过一段时间后，会被宿主机系统杀死（如果没有设置<code>--00m-kill-disable=true</code>的话）。</p>          </div><div class="note note-success">            <p><strong>设置-m,–memory，不设置–memory-swap</strong><br>给-m 或–memory 设置一个不小于 4M 的值，假设为 a，不设置–memory-swap。这种情况下，容器能使用的内存大小为 a，能使用的交换分区大小也为 a。<strong>因为 Docker 默认容器交换分区的大小和内存相同</strong>。<br>比如：$ docker run -m 1G ubuntu:16.04，该容器能使用的内存大小为 1G，能使用的 swap 分区大小也为 1G。容器内的进程能申请到的总内存大小为 2G。</p>          </div><ul><li><strong>CPU 限制：</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">--cpuset-cpus=&quot;&quot;  :允许使用的 CPU 核心集，值可以为 0-3,0,1<br>-c,--cpu-shares=0 :CPU 共享权值（相对权重）<br>cpu-period=0     :限制 CPU CFS 的周期，范围从 100ms~1s，即[1000, 1000000]<br>--cpu-quota=0     :限制 CPU CFS 配额，必须不小于1ms，即 &gt;= 1000<br>--cpuset-mems=&quot;&quot;  :允许在上执行的内存节点（MEMs），只对 NUMA 系统有效<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">表示容器中的进程可以在 cpu 1 和 cpu 3 上执行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpuset-cpus=<span class="hljs-string">&quot;1,3&quot;</span> ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示容器中的进程只能使用内存节点 1 和 3 上的内存</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpuset-mems=<span class="hljs-string">&quot;1,3&quot;</span> ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示容器中的进程只能使用内存节点 0、1、2 上的内存</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpuset-mems=<span class="hljs-string">&quot;0-2&quot;</span> ubuntu:14.04 /bin/bash</span><br></code></pre></td></tr></table></figure><p><strong>CPU 资源的相对限制</strong><br>默认情况下，所有的容器得到同等比例的 CPU 周期。在有多个容器竞争 CPU 时我们可以设置每个容器能使用的 CPU 时间比例。这个比例叫作共享权值，通过<code>-c</code>或<code>--cpu-shares</code>设置。Docker 默认每个容器的权值为 1024。不设置或将其设置为 0，都将使用这个默认值。系统会根据每个容器的共享权值和所有容器共享权值和比例来给容器分配 CPU 时间。</p><p>例如：有三个正在运行的容器，这三个容器中的任务都是 CPU 密集型的。第一个容器的 cpu 共享权值是 1024，其它两个容器的 cpu 共享权值是 512。第一个容器将得到 50% 的 CPU 时间，而其它两个容器就只能各得到 25% 的 CPU 时间了。如果再添加第四个 cpu 共享值为 1024 的容器，每个容器得到的 CPU 时间将重新计算。第一个容器的 CPU 时间变为 33%，其它容器分得的 CPU 时间分别为 16.5%、16.5%、33%。</p><div class="note note-warning">            <p>必须注意的是，这个比例只有在 CPU 密集型的任务执行时才有用。在四核的系统上，假设有四个单进程的容器，它们都能各自使用一个核的 100% CPU 时间，不管它们的 cpu 共享权值是多少。<br>在多核系统上，CPU 时间权值是在所有 CPU 核上计算的。即使某个容器的 CPU 时间限制少于 100%，它也能使用各个 CPU 核的 100% 时间。</p>          </div><p>例如，假设有一个不止三核的系统。用-c&#x3D;512 的选项启动容器{C0}，并且该容器只有一个进程，用-c&#x3D;1024 的启动选项为启动容器 C2，并且该容器有两个进程。CPU 权值的分布可能是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpu-shares=512 ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --cpu-shares=1024 ubuntu:14.04 /bin/bash</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/cpu/docker/&lt;容器的完整长ID&gt;/cpu.shares</span><br>PID    container    CPU CPU share<br>100    &#123;C0&#125;     0   100% of CPU0<br>101    &#123;C1&#125;     1   100% of CPU1<br>102    &#123;C1&#125;     2   100% of CPU2<br></code></pre></td></tr></table></figure><h3 id="设置容器运行存储介质"><a href="#设置容器运行存储介质" class="headerlink" title="设置容器运行存储介质"></a>设置容器运行存储介质</h3><p>Docker 中的数据可以存储在类似于虚拟机磁盘的介质中，在 Docker 中称为数据卷（Data Volume）。<br>数据卷可以将本地的磁盘数据和 docker 容器链接起来，使用容器的应用加载本地的数据，这样就很方便我们的开发。<br>而且可以保持数据持久化，当将容器删除时，数据不会丢失。<br><strong>文件系统挂载：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">-v, --volume=[host-src:]container-dest[:&lt;options&gt;]: 将宿主机src目录挂载到容器的dest.<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"># 在宿主机上创建一个临时目录/<span class="hljs-keyword">var</span>/lib/docker/volumes/[VOLUME_ID]/_data，<br># 然后把它挂载到容器的/test目录上<br>$ docker run -v /test<br><br># Docker 就直接把宿主机的/home目录挂载到容器的/test目录上<br>$ docker run -v /home:/test<br></code></pre></td></tr></table></figure><h2 id="start-x2F-stop-x2F-restart"><a href="#start-x2F-stop-x2F-restart" class="headerlink" title="start&#x2F;stop&#x2F;restart"></a>start&#x2F;stop&#x2F;restart</h2><p><strong>用途：</strong>启动一个已经停止的容器&#x2F;停止一个正在运行的容器&#x2F;重启一个停止或正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><code>docker start</code>支持容器<code>checkpoint</code>机制，但是该特性目前还是实验阶段，<a href="https://docs.docker.com/engine/reference/commandline/checkpoint/">详细点我可参考</a>。<br><strong>OPTIONS 参数：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"># docker stop 和restart 都支持该命令<br>--time , -t: docker默认会允许容器中的应用程序有Seconds秒的时间用以终止运行<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在 docker stop 命令执行的时候，会先向容器中 PID 为 1 的进程发送系统信号 SIGTERM，然后等待容器中的应用程序终止执行，如果等待时间达到设定的超时时间（默认的 10 秒），会继续发送 SIGKILL 的系统信号强行 kill 掉进程。在容器中的应用程序，可以选择忽略和不处理 SIGTERM 信号，不过一旦达到超时时间，程序就会被系统强行 kill 掉，因为 SIGKILL 信号是直接发往系统内核的，应用程序没有机会去处理它。</p>          </div><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name nginx-test -p 8080:80 -d nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                  NAMES<br>a16aad38955a   nginx     &quot;/docker-entrypoint.…&quot;   33 seconds ago   Up 26 seconds   0.0.0.0:8080-&gt;80/tcp   nginx-test<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -I http://localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.0<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop a16aad38955a</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart a16aad38955a</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker restart nginx-test</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">容器超时时间为20秒</span><br>docker stop --time=20 nginx-test<br></code></pre></td></tr></table></figure><h2 id="kill-立即停止容器中的主要进程"><a href="#kill-立即停止容器中的主要进程" class="headerlink" title="kill - 立即停止容器中的主要进程"></a>kill - 立即停止容器中的主要进程</h2><p><strong>用途：</strong>杀掉一个或多个正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">--signal , -s:向需要被杀死的容器发送一个信号<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> --signal=SIGHUP my_container</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> --signal=HUP my_container</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">kill</span> --signal=1 my_container</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>　 docker stop，支持“优雅退出”。先发送 SIGTERM 信号，在一段时间之后（10s）再发送 SIGKILL 信号。Docker 内部的应用程序可以接收 SIGTERM 信号，然后做一些“退出前工作”，比如保存状态、处理当前请求等。<br>　 docker kill，发送 SIGKILL 信号，应用程序直接退出，效果类似于 kill -9。</p>          </div><h2 id="rm-删除容器"><a href="#rm-删除容器" class="headerlink" title="rm - 删除容器"></a>rm - 删除容器</h2><p><strong>用途：</strong>删除一个或多个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--force , -f :通过 SIGKILL 信号强制删除一个运行中的容器。<br>--link , -l  :移除容器间的网络连接，而非容器本身。<br>--volumes , -v :删除与容器关联的卷。<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">强制删除正在运行的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> --force nginx-test</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">被强制删除的容器重新启动就会报错</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start nginx-test</span><br>Error response from daemon: No such container: nginx-test<br>Error: failed to start containers: nginx-test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有已经停止的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">rm</span> $(docker ps --filter status=exited -q)</span><br></code></pre></td></tr></table></figure><h2 id="pause-x2F-unpause"><a href="#pause-x2F-unpause" class="headerlink" title="pause&#x2F;unpause"></a>pause&#x2F;unpause</h2><p><strong>用途：</strong>暂停&#x2F;取消暂定 一个或多个容器中的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pause CONTAINER [CONTAINER...]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker unpause CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">暂停后对外停止提供服务</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pause nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                   PORTS                  NAMES<br>284f70efc7fa   nginx     &quot;/docker-entrypoint.…&quot;   17 seconds ago   Up 16 seconds (Paused)   0.0.0.0:8080-&gt;80/tcp   nginx-test<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消暂停后服务正常访问</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker unpause nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -I http://localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.0<br><br></code></pre></td></tr></table></figure><h2 id="create-从镜像中创建一个容器"><a href="#create-从镜像中创建一个容器" class="headerlink" title="create - 从镜像中创建一个容器"></a>create - 从镜像中创建一个容器</h2><p><strong>用途：</strong>创建一个新的容器但不启动它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong><br>语法参数同<code>docker run</code>一致<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create --name nginx-temp -p 8080:80  nginx</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有容器，可以看到刚创建的容器为：Created状态</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a</span><br>CONTAINER ID   IMAGE  COMMAND                  CREATED         STATUS                        PORTS     NAMES<br>b353a6e76755   nginx  &quot;/docker-entrypoint.…&quot;   2 minutes ago   Created                                 nginx-temp<br></code></pre></td></tr></table></figure><h2 id="exec-在容器中执行指令"><a href="#exec-在容器中执行指令" class="headerlink" title="exec 在容器中执行指令"></a>exec 在容器中执行指令</h2><p><strong>用途：</strong>在一个正在运行的容器中执行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">--detach , -d  : 分离模式即在后台运行命令<br>--env , -e : 设置环境变量，传递进去<br>--env-file : 从文件中读取环境变量<br>--interactive  : -i 保持STDIN打开<br>--tty , -t : 分配一个伪终端（pseudo-TTY）<br>--user , -u : 进入容器后使用的用户(format: &lt;name|uid&gt;[:&lt;group|gid&gt;])<br>--workdir , -w : 进入到容器后的工作目录<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器，打开bash伪终端</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it --name bash-dmeo bash</span><br>bash-5.1#<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开一个正在运行的容器的伪终端</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name nginx-demo -d nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it nginx-demo bash</span><br>root@0c0d174a92c3:/#<br></code></pre></td></tr></table></figure><h1 id="3-容器操作指令"><a href="#3-容器操作指令" class="headerlink" title="3. 容器操作指令"></a>3. 容器操作指令</h1><h2 id="ps-列出容器"><a href="#ps-列出容器" class="headerlink" title="ps 列出容器"></a>ps 列出容器</h2><p><strong>用途：</strong>列出容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps [OPTIONS]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">--all , -a :列表所以容器（默认只展示正在运行的容器）<br>--filter , -f :根据Filter的过滤条件列出容器，例如：--filter &quot;label=color&quot;<br>--format :使用Go template返回信息<br>--last , -n-1 :展示最近创建的容器 (includes all states)<br>--no-trunc :不断输出<br>--quiet , -q :只显示容器ID<br>--size , -s :显示总的文件大小<br></code></pre></td></tr></table></figure><p><strong>–filter：</strong>filter 支持非常丰富的过滤条件，例如：可根据 name、id、network、status 等条件进行过滤，详情参考<a href="https://docs.docker.com/engine/reference/commandline/ps/#filtering">这里</a>。<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES<br>0c0d174a92c3   nginx     &quot;/docker-entrypoint.…&quot;   8 minutes ago   Up 8 minutes   80/tcp    nginx-demo<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -a</span><br>CONTAINER ID   IMAGE                COMMAND                  CREATED          STATUS                           PORTS     NAMES<br>0c0d174a92c3   nginx                &quot;/docker-entrypoint.…&quot;   8 minutes ago    Up 8 minutes                     80/tcp    nginx-demo<br>92508477a258   nginx                &quot;/docker-entrypoint.…&quot;   9 minutes ago    Exited (0) 9 minutes ago                   nginx-test<br>9b33c7ee242e   bash                 &quot;docker-entrypoint.s…&quot;   10 minutes ago   Exited (0) 9 minutes ago                   bash-dmeo<br>032e637b9351   bash                 &quot;docker-entrypoint.s…&quot;   10 minutes ago   Exited (0) 10 minutes ago                  nginx-dmeo<br>cf754da59266   registery/httpd:v1   &quot;/sbin/httpd -D FORE…&quot;   13 days ago      Exited (255) About an hour ago             funny_greider<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -q</span><br>0c0d174a92c3<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps -s</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES        SIZE<br>0c0d174a92c3   nginx     &quot;/docker-entrypoint.…&quot;   8 minutes ago   Up 8 minutes   80/tcp    nginx-demo   1.17kB (virtual 142MB)<br></code></pre></td></tr></table></figure><h2 id="inspect-查看容器元数据"><a href="#inspect-查看容器元数据" class="headerlink" title="inspect - 查看容器元数据"></a>inspect - 查看容器元数据</h2><p><strong>用途：</strong>获取 Dock 对象的元数据信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--format , -f:根据Go template返回指定格式信息<br>--size , -s  :返回容器的总文件大小<br>--type:返回JSON格式数据<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">返回镜像信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect nginx</span><br>&#123;<br> ...<br>&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回容器信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker inspect nginx-demo</span><br>&#123;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="top-查看容器进程"><a href="#top-查看容器进程" class="headerlink" title="top 查看容器进程"></a>top 查看容器进程</h2><p><strong>用途：</strong>查看容器中正在运行的进程，支持 ps 命令参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker top CONTAINER [ps OPTIONS]<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker top nginx-demo</span><br>UID    PID   PPID  C  STIME  TTY   TIME      CMD<br>root   4367  4342  0  02:37  ?     00:00:00  nginx: master process nginx -g daemon off;<br></code></pre></td></tr></table></figure><h2 id="attach-连接正在运行的容器"><a href="#attach-连接正在运行的容器" class="headerlink" title="attach 连接正在运行的容器"></a>attach 连接正在运行的容器</h2><p><strong>用途：</strong>attach 到正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker attach [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -d --name topdemo ubuntu /usr/bin/top -b</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker attach topdemo</span><br>top - 03:15:20 up  1:45,  0 users,  load average: 0.00, 0.00, 0.00<br>Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie<br><span class="hljs-meta prompt_">%</span><span class="language-bash">Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 <span class="hljs-built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br>MiB Mem :   7860.3 total,   6693.0 free,    264.3 used,    903.0 buff/cache<br>MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   7007.9 avail Mem<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">C$</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Ctrl+C 后容器停止</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>docker exec 和 attach 区别：<br>docker exec 进入当前容器后开启一个新的终端，可以在里面操作(常用)，而且可以通过 exit 退出容器，不影响容器运行。<br>docker attach 进入容器正在执行某个命令的终端，不能在里面操作，而且会在输入 exit 后终止进程。</p>          </div><h2 id="events-获取服务器事件"><a href="#events-获取服务器事件" class="headerlink" title="events 获取服务器事件"></a>events 获取服务器事件</h2><p><strong>用途：</strong>从 server 获取实时事件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events [OPTIONS]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">--filter , -f :按照规则过滤事件<br>--since :从指定的时间戳后显示所有事件(e.g. 2013-01-02T13:23:37Z)<br>--until  :从指定的时间戳前显示所有事件(e.g. 2013-01-02T13:23:37Z)<br>--format :使用 Go template格式化输出<br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示 --since=2013-01-02T13:23:37Z 之后的事件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --since=2013-01-02T13:23:37Z</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --since=1357104217</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示 --since=2013-01-02T13:23:37Z 之前的事件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --until=2013-01-02T13:23:37Z</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events --until=1357104217</span><br></code></pre></td></tr></table></figure><p><strong>Evnent 事件说明：</strong><br><code>docker event</code> 支持包括：容器、镜像、Volumes、网络等众多事件监听，详细参考<a href="https://docs.docker.com/engine/reference/commandline/events/#description">这里</a>。<br>时间戳转换工具可以参考<a href="https://tool.lu/timestamp/">这里</a>。<br><strong>示例：</strong><br>启动两个终端，一个终端用于监听 server 事件，一个终端用于操作容器。<br>终端一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker events</span><br>2022-06-27T11:23:00.611613795+08:00 image pull alpine:latest (name=alpine)<br>2022-06-27T11:23:00.655624589+08:00 container create db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test)<br>2022-06-27T11:23:14.126563376+08:00 network connect 165661d4b916af0ca8ca3726a1b3b093be145b436a37dbd2c88993eca7d9f8ec (container=db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8, name=bridge, type=bridge)<br>2022-06-27T11:23:14.368875149+08:00 container start db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test)<br>2022-06-27T11:23:22.589226178+08:00 container kill db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test, signal=15)<br>2022-06-27T11:23:22.616389983+08:00 container die db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (exitCode=143, image=alpine:latest, name=test)<br>2022-06-27T11:23:22.661571663+08:00 network disconnect 165661d4b916af0ca8ca3726a1b3b093be145b436a37dbd2c88993eca7d9f8ec (container=db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8, name=bridge, type=bridge)<br>2022-06-27T11:23:22.672498349+08:00 container stop db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8 (image=alpine:latest, name=test)<br><br><br></code></pre></td></tr></table></figure><p>终端二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker create --name <span class="hljs-built_in">test</span> alpine:latest top</span><br>Unable to find image &#x27;alpine:latest&#x27; locally<br>latest: Pulling from library/alpine<br>2408cc74d12b: Pull complete<br>Digest: sha256:686d8c9dfa6f3ccfc8230bc3178d23f84eeaf7e457f36f271ab1acc53015037c<br>Status: Downloaded newer image for alpine:latest<br>db0226a361aec28d81bd7e7e8b0e6ccb331d727162966f3e7bbf75ec7c55f3c8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker start <span class="hljs-built_in">test</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><h2 id="logs-查看容器日志"><a href="#logs-查看容器日志" class="headerlink" title="logs 查看容器日志"></a>logs 查看容器日志</h2><p><strong>用途：</strong>展示容器日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs [OPTIONS] CONTAINER</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 参数：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">--follow , -f:实时跟踪展示日志<br>--since :从指定的时间戳后显示所日志(e.g. 2013-01-02T13:23:37Z)<br>--until  :从指定的时间戳前显示所日志(e.g. 2013-01-02T13:23:37Z)<br>--tail , -n :展示最后Num条日志<br>--timestamps , -t :是否展示timestamps<br></code></pre></td></tr></table></figure><p>时间戳转换工具可以参考<a href="https://tool.lu/timestamp/">这里</a>。<br><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs --<span class="hljs-built_in">tail</span>=10 nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs --<span class="hljs-built_in">tail</span>=10 -t nginx-test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx-test --since=1656297419</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker logs -f nginx-test --until=1656297419</span><br></code></pre></td></tr></table></figure><h2 id="wait-等待容器退出"><a href="#wait-等待容器退出" class="headerlink" title="wait 等待容器退出"></a>wait 等待容器退出</h2><p><strong>用途：</strong>阻塞运行直到容器停止，然后打印出它的退出代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">wait</span> CONTAINER [CONTAINER...]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong>需要两个终端，一个用于阻塞等待，一个用于退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">终端一</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">wait</span> nginx-test</span><br>0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">终端二</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker stop nginx-test</span><br>nginx-test<br></code></pre></td></tr></table></figure><h2 id="port-查看容器的端口映射"><a href="#port-查看容器的端口映射" class="headerlink" title="port 查看容器的端口映射"></a>port 查看容器的端口映射</h2><p><strong>用途：</strong>列出指定的容器的端口映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker port CONTAINER [PRIVATE_PORT[/PROTO]]</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run --name portdemo -p 8080:80 -d nginx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -I http://localhost:8080</span><br>  HTTP/1.1 200 OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker port portdemo</span><br>80/tcp -&gt; 0.0.0.0:8080<br></code></pre></td></tr></table></figure><h2 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h2><h1 id="4-容器仓库指令"><a href="#4-容器仓库指令" class="headerlink" title="4. 容器仓库指令"></a>4. 容器仓库指令</h1><h2 id="login-登录仓库"><a href="#login-登录仓库" class="headerlink" title="login 登录仓库"></a>login 登录仓库</h2><p><strong>用途：</strong>登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库：<a href="https://www.docker.com/"> Docker Hub</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login [OPTIONS] [SERVER]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--username , -u:登录名<br>--password , -p:登录密码<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">登录本地仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login localhost:8080</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">登录Docker Hub</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker login</span><br></code></pre></td></tr></table></figure><h2 id="logout-退出登录"><a href="#logout-退出登录" class="headerlink" title="logout 退出登录"></a>logout 退出登录</h2><p><strong>用途：</strong>用于仓库退出登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">logout</span> [SERVER]</span><br></code></pre></td></tr></table></figure><h2 id="pull-拉取镜像"><a href="#pull-拉取镜像" class="headerlink" title="pull 拉取镜像"></a>pull 拉取镜像</h2><p><strong>用途：</strong>从镜像仓库中拉取或者更新指定镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--all-tags , -a:下载所以tagged的镜像<br>--disable-content-trust:跳过镜像包验证（默认值：true）<br>--platform:设置拉取镜像的平台<br>--quiet , -q:简化输出<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull mysql</span><br>Using default tag: latest<br></code></pre></td></tr></table></figure><h2 id="push-推送镜像"><a href="#push-推送镜像" class="headerlink" title="push 推送镜像"></a>push 推送镜像</h2><p><strong>用途：</strong>将本地的镜像上传到镜像仓库（需先登陆到镜像仓库）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push [OPTIONS] NAME[:TAG]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">--all-tags , -a:推送所有tagged 镜像<br>--disable-content-trust:跳过镜像签名（默认值：true）<br>--quiet , -q:简化信息输出<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">要推送到对应的仓库上下文路径一定要跟DockerHub的信息对齐，否则将会推送失败</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag nginx:latest kissycn/nginx:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker push kissycn/nginx:latest</span><br></code></pre></td></tr></table></figure><h2 id="search-搜索镜像"><a href="#search-搜索镜像" class="headerlink" title="search 搜索镜像"></a>search 搜索镜像</h2><p><strong>用途：</strong>搜索镜像仓库的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search [OPTIONS] TERM</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--filter , -f:按照过滤条件进行过滤<br>--format:按照Go template进行格式化输出<br>--limit25:搜索显示条数（默认值：25）<br>--no-trunc:显示完整的描述信息<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search busybox</span><br>...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索stars数量为3以上</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --filter=stars=3 --no-trunc busybox</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索官网镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --filter is-official=<span class="hljs-literal">true</span> --filter stars=3 busybox</span><br></code></pre></td></tr></table></figure><p><strong>格式化示例：</strong><br>格式化输出支持：<code>.Name</code>、<code>.Description</code>、<code>.StarCount</code>、<code>.IsOfficial</code>、<code>.IsAutomated</code>这些字段，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker search --format <span class="hljs-string">&quot;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.StarCount&#125;&#125;: &#123;&#123;.IsOfficial&#125;&#125;&quot;</span> nginx</span><br>nginx: 16999: [OK]<br>linuxserver/nginx: 169:<br></code></pre></td></tr></table></figure><h1 id="5-容器-rootfs-指令"><a href="#5-容器-rootfs-指令" class="headerlink" title="5. 容器 rootfs 指令"></a>5. 容器 rootfs 指令</h1><h2 id="commit-新建镜像"><a href="#commit-新建镜像" class="headerlink" title="commit 新建镜像"></a>commit 新建镜像</h2><p><strong>用途：</strong>在一个镜像基础上通过 commits 信息创建一个新镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">--author , -a :作者 (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)<br>--change , -c :使用Dockerfile创建镜像<br>--message , -m :Commit message<br>--pause , -p : 在commit过程中暂停镜像(Default:true)<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS         PORTS     NAMES<br>0c0d174a92c3   nginx     &quot;/docker-entrypoint.…&quot;   5 hours ago   Up 2 seconds   80/tcp    nginx-demo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过coommit在nginx-demo基础上新建一个镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker commit nginx-demo -m <span class="hljs-string">&quot;first commit&quot;</span> nginx-demo-commit:v1.0.0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY          TAG       IMAGE ID       CREATED         SIZE<br>nginx-demo-commit   v1.0.0    09ca91406eb0   4 seconds ago   142MB<br></code></pre></td></tr></table></figure><h2 id="cp-容器与主机间数据拷贝"><a href="#cp-容器与主机间数据拷贝" class="headerlink" title="cp 容器与主机间数据拷贝"></a>cp 容器与主机间数据拷贝</h2><p><strong>用途：</strong>用于容器与主机之间的数据拷贝</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">--archive , -a :允许拷贝将文件的uid/gid等信息<br>--follow-link , -L :Always follow symbol link in SRC_PATH<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从宿主机拷贝文件到容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> ./some_file CONTAINER:/work</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝完成后可以在容器里边查看</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it CONTAINER bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从容器拷贝数据到宿主机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">cp</span> CONTAINER:/var/logs/ /tmp/app_logs</span><br></code></pre></td></tr></table></figure><h2 id="diff-比较容器版本差异"><a href="#diff-比较容器版本差异" class="headerlink" title="diff 比较容器版本差异"></a>diff 比较容器版本差异</h2><p><strong>用途：</strong>用于比较一个 Docker 容器不同版本提交的文件差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> docker diff CONTAINER</span><br></code></pre></td></tr></table></figure><p><strong>OPTIONS 说明：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">AA file or directory was added<br>DA file or directory was deleted<br>CA file or directory was changed<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker diff nginx-demo</span><br>C /etc<br>C /etc/nginx<br>C /etc/nginx/conf.d<br>C /etc/nginx/conf.d/default.conf<br>C /run<br>A /run/nginx.pid<br>C /tmp<br>A /tmp/raft.pdf<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a><br><a href="https://www.infoq.cn/article/s3qkg9lvbxplmaiqjame">https://www.infoq.cn/article/s3qkg9lvbxplmaiqjame</a><br><a href="https://cloud.tencent.com/developer/article/1426760">https://cloud.tencent.com/developer/article/1426760</a><br><a href="https://dockone.io/article/152">https://dockone.io/article/152</a><br><a href="https://mp.weixin.qq.com/s/lkUaWIRznOmHGVrbXVwlaQ">https://mp.weixin.qq.com/s/lkUaWIRznOmHGVrbXVwlaQ</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DockerCLI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Notion+Hexo+Github搭建技术博客</title>
    <link href="/2022/06/21/notion-hexo-github/"/>
    <url>/2022/06/21/notion-hexo-github/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>目前主流的个人博客解决方案大致如下：</p><p>1、WordPress：<a href="https://wordpress.org/">WordPress</a>生态插件丰富非常容易搭建个人博客，上手也比较容易。但是问题在于WordPress需要独立的空间部署，需要使用数据库等，这就意味着我们需要去租赁云空间、系统上线需要经常备份维护等，长年累月下来就懒得打理逐渐荒废了。</p><p>2、Hexo：<a href="https://hexo.io/">Hexo</a>可以快速、简洁且高效的博客框架，功能插件丰富UI界面友好，Hexo编译后会生成静态文件不需要数据库连接等，直接挂到GithubPages即可。但是使用Hexo发布文章需要一个强大的Markdown软件，目前没有一个能和语雀、Notion等丰富度匹配的md编辑器，所以直接使用Hexo相对来说比较麻烦。</p><p>3、语雀：<a href="https://www.yuque.com/kissy">语雀</a> 是蚂蚁金服推出的一款知识库软件，我也用了语雀将近2年时间，语雀的知识库目录和文章目录功能比较强大，非常适合于个人知识库和笔记。但是如果想要搭建博客，则模板比较单一而且不能自定义主题等，而且文档发布过程中不方便与Hexo的<a href="https://hexo.io/zh-cn/docs/front-matter">YAML FrontMatter</a>集成，总的来说语雀在灵活度上有所欠缺对外扩展不方便。另外，如果是语雀重度用户要发布Hexo博客可以参考： <a href="https://github.com/x-cold/yuque-hexo">https://github.com/x-cold/yuque-hexo</a> （他可以通过自动化的方式将语雀的文章发布到hexo等主流的博客系统之上）。</p><p>4、Notion：<a href="https://www.notion.so/">Notion</a> 相对于其他的博客或者在线文档的服务，Notion 是目前自由度最高的，可以任意地调整页面的布局，插入和引用 database、block等，还支持各种组件、模板、在线写作等。但是Notion想要做个人博客在UI和精细程度上还有所欠缺。</p><p>综上所述，有没有一款工具既有Notion的灵活性，又能与Hexo主流博客系统对接？答案是只有自己撸一套，几经折腾打算采用如下解决方案：<code>使用Notion作为基础的知识库管理软件用于编写md文件，Hexo作为博客发布工具，GithubPages作为Hexo的Web应用服务器，GithubActions用于将Notion的Pages同步到GithubPages</code>。</p>          </div><h1 id="1-基础环境搭建"><a href="#1-基础环境搭建" class="headerlink" title="1.基础环境搭建"></a>1.基础环境搭建</h1><p>在开始搭建之前，需要准备以下几样东西：</p><ul><li>本地安装 node.js</li><li>本地安装 git</li><li>一个 github 账号</li><li>创建一个 github 仓库</li></ul><h2 id="1-1-本地安装node-js"><a href="#1-1-本地安装node-js" class="headerlink" title="1.1 本地安装node.js"></a>1.1 本地安装node.js</h2><p><code>Windows</code>系统可以在<a href="https://nodejs.org/zh-cn/download/">这里</a>下载<code>installer</code> 安装包进行安装。</p><p><code>Mac</code>系统可以在<a href="https://nodejs.org/zh-cn/download/">这里</a>下载<code>pkg</code>安装包，也可以使用<code>homebrew</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装命令</span><br>% brew install node<br><span class="hljs-comment"># 安装验证</span><br>% node -v<br>v16.15.1<br></code></pre></td></tr></table></figure><h2 id="1-2-本地安装git"><a href="#1-2-本地安装git" class="headerlink" title="1.2 本地安装git"></a>1.2 本地安装git</h2><p><code>Windows</code> 系统可以从<a href="https://gitforwindows.org/">这里</a>下载安装包后进行安装。<code>Mac</code>系统可以从<a href="https://sourceforge.net/projects/git-osx-installer/">这里</a>下载安装包进行安装。也可以使用<code>homebrew</code>进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装指令</span><br>brew install git<br><span class="hljs-comment"># 验证安装</span><br>git --version<br><span class="hljs-comment"># 设置自己的用户名和邮箱</span><br>git config --global user.name <span class="hljs-string">&quot;你的用户名&quot;</span> <br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h2 id="1-3-github账号"><a href="#1-3-github账号" class="headerlink" title="1.3 github账号"></a>1.3 github账号</h2><p><strong>1）首先注册账号</strong></p><p><a href="https://github.com/join?source=header-home">点击这里</a>需要注册一个<code>Github</code>账号，创建好账号之后，我们还需要把我们本地的<code>SSH Key</code> 添加到<code>Github</code> 中去，这样我们之后才能有权限将本地代码推送到<code>Github</code> 中，先本地生成一对<code>RSA</code> 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用默认参数，回车键连敲三次</span><br>ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2）将ssh-key添加到github</strong></p><ul><li>Windwos用户在:<code>C://用户//admin//.ssh</code> 目录下，Mac用户在<code>~./ssh</code> 目录下。</li></ul><p>复制<code>id_rsa.pub</code>文件里的信息，然后到<a href="https://github.com/settings/keys">这里</a>添加新的<code>SSHKEY</code>。</p><p><img src="/notion_images/01f62e9bcd47fffbf7f7ce79357433bb.png"></p><h2 id="1-4-启用github-pages"><a href="#1-4-启用github-pages" class="headerlink" title="1.4 启用github-pages"></a>1.4 启用github-pages</h2><p>GithubPages 可以理解为Github提供的免费网页空间，可以用来存放你的静态网页文件，并通过 <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/"><code>https://用户名.github.io</code></a> 或者 <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/"><code>https://用户名.github.io/项目名/</code></a> 的方式来访问。</p><p>开启的方式也非常简单，只需要在<a href="https://github.com/new">这里</a>创建相应的公共仓库并将仓库名称设置为：<code>用户名.github.io</code> 即可。</p><p><img src="/notion_images/4deafefc93b3f3d43c9333b5b7f3b03e.png"></p><p>如果使用了其他分支作为仓库代码，可以在github pages里边修改：</p><p><img src="/notion_images/e5a622e953cea730d0b6a3e03a3984c3.png"></p><p>修改完成之后就可以使用  <a href="https://用户名.github.io/%E9%A1%B9%E7%9B%AE%E5%90%8D/">https:&#x2F;&#x2F;用户名.github.io</a> 地址进行访问了（创建完成若未正常显示，可以稍等几分钟刷新再试）</p><h1 id="2-部署Hexo"><a href="#2-部署Hexo" class="headerlink" title="2.部署Hexo"></a>2.部署Hexo</h1><p>Hexo是一款静态网站生成工具，可以根据设置的主题样式和配置文件，来生成丰富多彩的网页，通常配置文件设置好之后不需要经常修改，我们只需要负责写好我们的博文，写好之后就能使用命令一键生成网站，而且还可以为所欲为的切换主题。</p><p><strong>1）Hexo安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">% npm install -g hexo-cli<br>% hexo -v<br></code></pre></td></tr></table></figure><p><strong>2）使用Hexo新建本地博客</strong></p><p>选择一个常用的工作空间目录，进入到该目录初始化Hexo项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">% hexo init blog<br>% <span class="hljs-built_in">cd</span> blog<br>% npm install<br></code></pre></td></tr></table></figure><p>新建完成之后，blog目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">% tree -L 1<br>.<br>├── _config.landscape.yml<br>├── _config.yml<br>├── node_modules<br>├── package-lock.json<br>├── package.json<br>├── scaffolds<br>├── <span class="hljs-built_in">source</span><br>└── themes<br></code></pre></td></tr></table></figure><p><code>_config.yml</code> 是配置文件，里面有很多可以配置的数据，这里暂时不多介绍，后面的文章里会进行详细说明。</p><p><code>package.json</code> 是应用程序信息，通常不需要关心。</p><p><code>node_modules</code> 用来存放 <code>node</code> 相关的模块，通常不需要关心。</p><p><code>scaffolds</code> 里面是模版文件，也就是每次新建文章时，都会根据模版文件来创建对应的 <code>md</code> 文件，这一点也会在后续的文章里进行详细介绍。</p><p><code>source</code> 是资源文件夹，用来存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。</p><p><code>theme</code> 是主题文件夹，每个主题的配置都会有些不一样，需要根据具体主题情况来定，后续介绍主题的文章里会有说明。</p><p><strong>3）本地运行Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">% hexo server<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>浏览器访问： <a href="http://localhost:4000/"><code>http://localhost:4000/</code></a></p><p><img src="/notion_images/92c39b1ea2c37f4e0057889891b7be5d.png"></p><h1 id="3-使用github-action自动发布"><a href="#3-使用github-action自动发布" class="headerlink" title="3.使用github-action自动发布"></a>3.使用github-action自动发布</h1><p>Hexo博客部署发布使用的是静态HTML文件，如果想要在互联网发布文章则需要进行deploy操作，为此我们将使用GithubPages作为我们的Web服务。这样一来我们需要维护一个Hexo源码分支用于存放Hexo源文件以及md文件等，使用另外一个分支发布我们的静态资源。每次提交代码并打包发布是一项繁琐的操作，我们可以用使用Actions实现流水线自动发布，Actions可以参考<a href="https://docs.github.com/cn/actions">这里</a>。</p><p>由于Hexo和相应的主题与配置等涉及到一些个性化的参数配置，基于安全因素考虑，我们可以使用两个仓库用于博客代码管理，一个<code>私有仓库</code>存放Blog原生代码和Ation用于触发流水线，另外一个<code>公共仓库</code>用于存放编译后的HTML代码，具体流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">本地Hexo编写md文件 --&gt; git提交至blog仓库（private）--&gt; 触发actions --&gt; 部署至用户名.github.io仓库(public)<br></code></pre></td></tr></table></figure><h2 id="3-1、首先，新建blog仓库"><a href="#3-1、首先，新建blog仓库" class="headerlink" title="3.1、首先，新建blog仓库"></a>3.<strong>1、首先，新建blog仓库</strong></h2><p>在<a href="https://github.com/new">这里</a>新建一个私有仓</p><p><img src="/notion_images/266d4025ed2e3ed474e8be8875620234.png"></p><h2 id="3-2、将本地Hexo代码提交至私有仓库"><a href="#3-2、将本地Hexo代码提交至私有仓库" class="headerlink" title="3.2、将本地Hexo代码提交至私有仓库"></a>3.<strong>2、将本地Hexo代码提交至私有仓库</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">cd</span> blogs<br>% git init<br>% git add .<br>% git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>% git branch -M main<br>% git remote add origin git@github.com:你的私有仓库地址.git<br>% git push -u origin main<br></code></pre></td></tr></table></figure><h2 id="3-3、使用github-action自动提交部署博客"><a href="#3-3、使用github-action自动提交部署博客" class="headerlink" title="3.3、使用github-action自动提交部署博客"></a>3.<strong>3、使用github-action自动提交部署博客</strong></h2><p>1<strong>）生成SSH秘钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">% <span class="hljs-built_in">cd</span> ~/.ssh<br>% ssh-keygen -f hexo-deploy-key -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会在<code>~/.ssh</code>路径下生成：秘钥<code>hexo-deploy-key</code> 和公钥<code>hexo-deploy-key.pub</code>，然后分别添加到对应的文件中。</p><p><code>页面文件仓库（public）</code>: 在 Settings &gt; Deploy keys 中添加Deploy Key，内容为hexo-deploy-key.pub 文件内容，同时勾选 Allow write access 选项。</p><p><code>博客源文件库(private)</code>：在Settings &gt; Secrets中添加一个Secret，名称为 DEPLOY_KEY，内容为 hexo-deploy-key 文件内容。后续在 Workflow中通过名称 DEPLOY_KEY 使用这个密钥。</p><p><strong>2）添加Hexo Deploy</strong></p><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。Hexo-Deploy相关知识可以参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">这里</a>。</p><p>为了能够方便使用Hexo Deploy 首先要进行插件安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目路径下执行</span><br>% npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>安装成功后，修改 Hexo 源文件夹下的 _config.yml <code>将repo 地址设置为公共仓库地址</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br>deploy:<br>  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br>  repo: git@github.com:kissycn/你的公共仓库地址.git<br>  branch: [main]<br></code></pre></td></tr></table></figure><p><strong>3）添加action流水线脚本</strong></p><p>为了能够提交代码时执行自动构建，需要在私有仓库页面创建流水线，并在 push 时触发。</p><p>在私有仓库项目页面新建流水线脚本：</p><p><img src="/notion_images/4fe924d83ea60a82c9da258707f9c7e3.png"></p><p>私有仓库<code>/.github/workflows/main.yml</code>文件内容如下（记得修改相应参数：<code>user.email</code>   <code>user.name</code>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Blog</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-comment"># Controls when the workflow will run</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># Triggers the workflow on push or pull request events but only for the main branch</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">main</span> ]<br><br>  <span class="hljs-comment"># Allows you to run this workflow manually from the Actions tab</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-comment"># This workflow contains a single job called &quot;build&quot;</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-comment"># The type of runner that the job will run on</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-comment"># Steps represent a sequence of tasks that will be executed as part of the job</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br><br>      <span class="hljs-comment"># Runs a set of commands using the runners shell</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Node</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Npm</span> <span class="hljs-string">Install</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install hexo-cli -g</span><br><span class="hljs-string">          npm install</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">Key</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">DEPLOY_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.DEPLOY_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh</span><br><span class="hljs-string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.email &quot;你的邮箱&quot;</span><br><span class="hljs-string">          git config --global user.name &quot;你的github用户名&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo generate</span><br><span class="hljs-string">          hexo deploy</span><br></code></pre></td></tr></table></figure><p>点击Commit按钮会触发相应的流水线操作，流水线执行结果可以在：<code>Actions → Workflows → Blog Deploy → build and deploy</code> </p><p><img src="/notion_images/080df2aed454253b3e7536f85e323ae5.png"></p><p>完了可以在：<code>用户名.github.io 仓库（public）</code>下查看自动部署后的文件，并在浏览器访问仓库地址，可以看到Hexo被提交到了仓库。</p><p><strong>3.4）新的变更</strong></p><p>流水线创建成功后，我们向Hexo仓库提交源代码，会自动触发Actions构建操作，这样就能实现博客文章自动发布功能。</p><div class="note note-warning">            <p>如果大家觉着每次提交代码都会触发编译发布比较鸡肋，也可以将发布流水线改成手动。</p>          </div><h1 id="4-同步notion数据到博客"><a href="#4-同步notion数据到博客" class="headerlink" title="4.同步notion数据到博客"></a>4.同步notion数据到博客</h1><p>Notion是一个全能工作空间，Notion 可以帮助你创建几乎你需要的所有东西，包括：</p><ul><li>文档</li><li>数据库</li><li>知识库</li><li>项目管理</li><li>生产力系统</li><li>世界上最美丽的笔记…</li></ul><p>Notion 中文站点：<a href="https://notionchina.co/">https://notionchina.co/</a></p><p>Notion 官放站点：<a href="http://notion.so/">notion.so</a></p><p>Notion 入门视频：<a href="https://www.bilibili.com/video/BV1DB4y1C7Af">https://www.bilibili.com/video/BV1DB4y1C7Af</a></p><p>以上文档和视频非常详细的介绍了Notion注册、使用教程，此不再赘述。</p><h2 id="4-1-使用notion数据库管理博客"><a href="#4-1-使用notion数据库管理博客" class="headerlink" title="4.1 使用notion数据库管理博客"></a>4.1 使用notion数据库管理博客</h2><p>Notion 作为一款非常灵活的博客管理工具，其Database功能具备良好的扩展性，可以通过自定义字段来与Hexo的<a href="https://hexo.io/zh-cn/docs/front-matter">YAML FrontMatter</a>集成，这样就非常方便的通过自动化的方式将Notion的文章发布到我们的Github-Pages上，本次集成参考的技术方案为 <a href="https://lailin.xyz/post/notion-markdown-blog.html">mohuishou的技术博客</a>，具体集成过程如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">用户在Notion编写文章</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">将文档移动到待发布状态</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">手动触发Actions</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">使用NotionAPI同步Pages到Github</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">触发Github自动编译并发布</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">将文章在Notion更新为已发布</span><br></code></pre></td></tr></table></figure><p><strong>1）建立NotionDatabase</strong></p><p><a href="https://www.notion.so/3999b0ae72364a4b99a87f7d9d0a52be">点击这里</a>，复制 mohuishou 同学的NotionTemplate到自己的Notion。</p><p><img src="/notion_images/36229ec5b958d647221390f2c1885135.png"></p><p>上述为Notion的Database，通过看板可以看到Notion的文档分成了几种状态，其流转过程如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">idea</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">放入收集箱</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">编写文章</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">移动到待发布</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">点击执行</span> <span class="hljs-string">github</span> <span class="hljs-string">workflow</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">自动发布</span><br></code></pre></td></tr></table></figure><p><strong>2）Notion Database 为文章添加字段</strong></p><p>通过Notion的Database为每篇文章定义了众多字段，其含义如下：</p><ul><li><strong>status</strong>：为了避免每次都获取所有的文章数据，我们添加一个 status 字段，当 status 为 待发布 的时候我们才去下载对应的文章，文章下载完成之后，我们就把这篇文章的状态修改为 已发布</li><li><strong>tags：</strong>Hexo 博客对应的标签</li><li><strong>categories：</strong>Hexo对应的分类</li><li><strong>urlname：</strong>Hexo文章发布后的url地址</li><li><strong>date：</strong>Hexo文章发布时间</li><li><strong>show-category</strong>：Hexo文章所述分类</li><li><strong>index_img</strong>：Hexo文章的封面图</li><li><strong>excerpt：</strong>Hexo文章节选描述</li></ul><p><img src="/notion_images/5878e2337380c983bcebe2b32617c93c.png"></p><h2 id="4-2-使用Actions同步博客数据到Github"><a href="#4-2-使用Actions同步博客数据到Github" class="headerlink" title="4.2 使用Actions同步博客数据到Github"></a>4.2 使用Actions同步博客数据到Github</h2><p>想要将Notion的Pages同步到Database主要是通过NotionAPI将 <code>Notion Page</code> 转换为<code>Markdown</code>文件，然后就可以直接使用 Hugo、Hexo 等。虽然现在Notion官方开放了API，但是没有API可以直接将Notion 的数据结构之间转换为Markdown，现在虽然有一些第三方库（例如 notion2md ）支持，但是存在着各种各样的问题，要么不支持图片，要么不支持table等格式，总是会欠缺，为此对于Notion Page的同步采用 mohuishou同学的编写的同步代码，<a href="https://github.com/mohuishou/notion-blog-actions">仓库地址点这里</a>。</p><p><strong>1）fork pages的同步代码到自己的仓库</strong></p><p><img src="/notion_images/22d6cce3f2b31bbfd45fc65e93053089.png"></p><p><strong>2）获取Notion 需要用到的参数</strong></p><p>Notion的API调用需要用到几个参数： <code>NOTION_TOKEN、NOTION_TOKEN_V2、space_id、database_id</code></p><p>1、获取<code>NOTION_TOKEN</code></p><p>点击<a href="https://www.notion.so/my-integrations">这里</a>添加一个notion-integration</p><p><img src="/notion_images/a384fd08037e6e73c9552a6e5449948f.png"></p><p>赋予对应的权限</p><p><img src="/notion_images/015f877376eb34a20d23c5bf24013cb5.png"></p><p>点击show就得到了<code>NOTION_TOKEN</code></p><p><img src="/notion_images/110d905f7bded3a8236b6464d7975897.png"></p><p>将Notion Database分享给刚刚创建的integration，在需要使用API的页面中，点击Share并选择Invite ，将机器人邀请进去，让其用于编辑的权限。</p><p>2、获取<code>NOTION_TOKEN_V2</code></p><p>通过网页打开 <a href="https://www.notion.so/">https://www.notion.so/</a> 并登录，打开浏览器的开发者模式：Application&gt;Cookies&gt;token_v2 即可获取</p><p>3、获取<code>space_id</code></p><p>通过网页打开 <a href="https://www.notion.so/">https://www.notion.so/</a> 并登录，打开浏览器的开发者模式：Application&gt;Cookies&gt;notion_user_id 即可获取</p><p>4、获取<code>database_id</code></p><p>获取数据表的 database_id，点击数据表右上方的 … 选择 Copylink ，连接如下方：<a href="https://www.notion.so/9bcf00dce55c42799f3b177dc325aa18">https://www.notion.so/xinhuoip/9bcf00dce55c42799f3b177dc325aa18?v=217bbe82893e4e4aa228a19f3f2dc888</a>   其中：<a href="https://www.notion.so/851d6c61c250495f9337be5527360d68">9bcf00dce55c42799f3b177dc325aa18</a> 即为 <code>database_id</code> </p><p><strong>3）在Github添加secrets</strong></p><p>在上面建立的<code>私有仓库（存放Hexo源码的那个仓库)</code>的仓库里边添加TOKEN的环境变量：</p><p> <code>blog私有仓库—&gt;settings—&gt;secrets—&gt;actions—&gt;New repository secret</code></p><p><img src="/notion_images/cf8c2e380bdae147bbc5aa81087039a5.png"></p><p>4<strong>）编写触发的Actions</strong></p><p>在<code>私有仓库（存放Hexo源码的那个仓库)</code>仓库中添加Actions，blogs&#x2F;.github&#x2F;workflows&#x2F;notion-hexo.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span> [<span class="hljs-string">workflow_dispatch</span>, <span class="hljs-string">watch</span>]<br><br><span class="hljs-attr">name:</span> <span class="hljs-string">notion</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">notion:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;test&quot;</span><br>      <span class="hljs-attr">run :</span> <span class="hljs-string">|</span><br><span class="hljs-string">        echo $&#123;&#123; secrets.NOTION_TOKEN &#125;&#125;</span><br><span class="hljs-string">        echo $&#123;&#123; secrets.NOTION_TOKEN_V2 &#125;&#125;</span><br><span class="hljs-string"></span>        <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">submodules:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">修改为你fork的仓库代码地址/notion-blog-actions/notion@main</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.NOTION_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">token_v2:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.NOTION_TOKEN_V2</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">space_id:</span> <span class="hljs-string">&quot;你的spaceid&quot;</span><br>        <span class="hljs-attr">database_id:</span> <span class="hljs-string">&quot;你的database_id&quot;</span><br>        <span class="hljs-attr">output:</span> <span class="hljs-string">&quot;./tmp/&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;migrate image&quot;</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">修改为你fork的仓库代码地址/notion-blog-actions/migrate@main</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">input:</span> <span class="hljs-string">&quot;./tmp/*.md&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;cp md files&quot;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        cp -f tmp/*.md source/_posts/notion/</span><br><span class="hljs-string">        rm -rf tmp</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">git</span> <span class="hljs-string">setting</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        git config --global user.email &quot;你的邮箱&quot;</span><br><span class="hljs-string">        git config --global user.name &quot;你的用户名&quot;</span><br><span class="hljs-string"></span>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">update</span> <span class="hljs-string">blog</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        git add source</span><br><span class="hljs-string">        git commit -m &quot;feat: auto update by notion sync&quot;</span><br><span class="hljs-string">        git push</span><br></code></pre></td></tr></table></figure><p><strong>5）在github-actions页面可完成流水线的手动触发</strong></p><p>如此一来我们就是实现了将Notion的Pages自动发布到GithubPages，大家可以根据自己使用习惯和使用方式做调整。</p><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p><strong><strong>使用 Notion Database 管理静态博客文章：</strong></strong><a href="https://lailin.xyz/post/notion-markdown-blog.html">https://lailin.xyz/post/notion-markdown-blog.html</a></p><p><strong>Notion API 简单上手：</strong><a href="https://ews.ink/tech/dev-notion-api/">https://ews.ink/tech/dev-notion-api/</a></p><p><strong><strong>notion API使用：</strong></strong><a href="https://www.zdl.im/article/notionapi">https://www.zdl.im/article/notionapi</a></p><p><strong>使用Hexo+github pages+travis ci搭建好看的个人博客：</strong> <a href="https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/">https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/</a></p><p><strong>利用 Github Actions 自动化部署 Hexo 博客：</strong><a href="https://dreamhomes.top/posts/202111101556/">https://dreamhomes.top/posts/202111101556/</a></p>]]></content>
    
    
    <categories>
      
      <category>分类1</category>
      
      <category>分类2</category>
      
      <category>分类3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile镜像指令</title>
    <link href="/2022/06/21/docker-file/"/>
    <url>/2022/06/21/docker-file/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>Dockerfile 最佳实践：</p><ol><li>使用小基础镜像(例：alpine)</li><li>RUN 指令中最好把所有 shell 命令都放在一起执行，减少 Docker 层</li><li>分阶段构建</li><li>最好声明 Docker 镜像签名</li><li>使用.dockerignore 排除不需要加入 Docker 镜像目录或者文件</li></ol>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"># stage <span class="hljs-number">1</span><br>FROM node:<span class="hljs-number">13.1</span><span class="hljs-number">.0</span>-alpine as builder<br><br>LABEL version=<span class="hljs-string">&quot;node 13.1.0&quot;</span><br><br># 修改alpine源为阿里源，安装tzdata包并修改为北京时间<br>RUN sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories \<br>    &amp;&amp; apk --update add --no-cache tzdata \<br>    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br># 声明环境变量<br>ENV NODE_ENV dev<br><br># 声明使用node用户<br>USER node<br><br># 首次只加入<span class="hljs-keyword">package</span>.json文件，<span class="hljs-keyword">package</span>.json一般不变，这样就可以充分利用Docker Cache，节约安装node包时间<br>COPY --chown=node:node <span class="hljs-keyword">package</span>.json /app &amp;&amp; npm ci<br><br># 声明镜像默认位置<br>WORKDIR /app<br><br># 加入node代码<br>ADD --chown=node:node . /app<br><br># build代码<br>RUN npm run build \<br>    &amp;&amp; mv dist public<br><br># stage <span class="hljs-number">2</span><br># 加入nginx镜像<br>FROM nginx:alpine<br><br># 拷贝上阶段build静态文件<br>COPY --from=builder /app/public /app/public<br><br># 拷贝nginx配置文件<br>COPY nginx.conf /etc/nginx/conf.d/<span class="hljs-keyword">default</span>.conf<br><br># 声明容器端口<br>EXPOSE <span class="hljs-number">8080</span><br><br># 启动命令<br>CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure><p>Docker 通过读取<code>Dockerfile</code>来自动构建 Docker 镜像。<code>Dockerfile</code>是一个文本文件用来描述用于组装构建 Docker 镜像的命令，通过<code>docker build . </code>命令完成对 Dockerfile 的构建执行操作从而生成约定产物，形成镜像制品。</p><h1 id="1-Dockerfile-构建"><a href="#1-Dockerfile-构建" class="headerlink" title="1.Dockerfile 构建"></a>1.Dockerfile 构建</h1><h2 id="1-1-构建机制"><a href="#1-1-构建机制" class="headerlink" title="1.1 构建机制"></a>1.1 构建机制</h2><p>docker 构建一个镜像需要：<code>Dockerfile文件</code>、<code>构建所需的上下文</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br></code></pre></td></tr></table></figure><p>这条命令中，docker-cli 会:</p><ol><li>把当前目录及子目录当做上下文传递给 docker 服务</li><li>从当前目录(不包括子目录)中找到 Dockerfile</li><li>检查 Dockerfile 的语法</li><li>依次执行 Dockerfile 中的指令，根据指令生成中间过度镜像(存储在本地，为之后的指令或构建作缓存)</li></ol><p>注意：为了加快构建速度，减少传递给 docker 服务的文件数量，最好将 Dockerfile 放在单独的空目录中。如果目录中含有大量文件，可以使用<code>.dockerignore</code>来忽略构建时用不到的文件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"># comment<br>*/temp*<br>*<span class="hljs-comment">/*/temp*</span><br><span class="hljs-comment">temp?</span><br></code></pre></td></tr></table></figure><h2 id="1-2-镜像缓存机制"><a href="#1-2-镜像缓存机制" class="headerlink" title="1.2 镜像缓存机制"></a>1.2 镜像缓存机制</h2><p>当在构建或者下载镜像时候，当镜像层已经存在的时候则直接使用缓存， 不需要进行重新构建镜像，如果我们希望在构建镜像时不使用缓存，可以在 docker build 命令中加上<code>–no-cache</code>参数。如果我们改变 Dockerfile 指令的执行顺序，或者修改或添加指令，都会使缓存失效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build --no-cache=true ... # --no-cache：不使用缓存，每条指令都重新生成镜像<br></code></pre></td></tr></table></figure><p>Dockerfile 在执行的时候，当有执行过相同的代码并且顺序也一致的情况下，就会使用缓存镜像层进行构建新的镜像。Dockerfile 中每一个指令都会创建一个镜像层，上层是依赖于下层的。</p><div class="note note-warning">            <p>缓存失效：简单来说就是如果第 n 层有改动，则 n 层以后的缓存都会失效，大多数情况下判断有无改动的方法是判断这层的指令和缓存中的构建指令是否一致，但是对于 COPY 和 ADD 命令会计算镜像内的文件和构建目录文件的校验和然后做比较来判断本层是否有改动。</p>          </div><h2 id="1-3-格式要求"><a href="#1-3-格式要求" class="headerlink" title="1.3 格式要求"></a>1.3 格式要求</h2><p>虽然 Dockerfile 并不区分大小写，但还是约定指令使用大写。<br>Dockerfile 的第一条可执行指令必须是 FROM。<br>以#开头的是注释，行内的#都被当做参数，并且不支持续行。</p><h1 id="2-Dockerfile-指令"><a href="#2-Dockerfile-指令" class="headerlink" title="2.Dockerfile 指令"></a>2.Dockerfile 指令</h1><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建，常用的指令如下：</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><strong>用途：构建的镜像继承自某个 base image</strong>。FROM 指令必须是 Dockerfile 的第一个指令，可以使用多次来构建多个镜像，以最后一个镜像的 ID 为输出值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]<br>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]<br>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>platform：</strong>用于标识 Docker 镜像平台架构，例如：<code>linux/amd64</code>、<code>linux/arm64</code>或<code>windows/amd64</code></li><li><strong>tag：</strong>镜像标签，默认为<code>latest</code>。如果无法找到该 tag 值，构建器将返回错误。</li><li><strong>digest：</strong>可寻址标识符，镜像的二进制 ID，主要用于验证所下载镜像的<code>完整性</code>和<code>防篡改性</code>。</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p><strong>用途：</strong>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">RUN &lt;command&gt; # shell 格式<br>RUN [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br></code></pre></td></tr></table></figure><p><strong>使用原则：</strong></p><ul><li>尽量减少一个 Dockerfile 中的 RUN 命令的个数。<strong>RUN 命令在构建时会创建一个新层，如非特殊的需要，建议一个 Dockerfile 在需要使用 RUN 命令的时候尽可能的只用一个 RUN 命令，将多条 RUN 命令进行合并可以有效降低构建的镜像的层数</strong>。</li><li>使用&amp;&amp;连接多条命令，例如：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUN apt-get update &amp;&amp; apt-get install -y \<br>package-bar\<br>package-baz \<br>package-foo<br></code></pre></td></tr></table></figure><ul><li>避免复杂的逻辑实现</li></ul><p><strong>关于缓存失效：</strong></p><div class="note note-warning">            <p> 在通常情况下，构建镜像后，所有的层都在 Docker 缓存中，假设后来又修改了其中的 apt-get install 命令，在添加一个包时， Docker 发现修改后的 RUN apt-get update 命令和之前的完全一样。<br>这时，不会执行 RUN apt-get update 命令，而是使用之前的缓存镜像。因为 RUN apt-get update 命令没有执行，后面的 apt-get install 命令安装的可能是过期的软件版本或提示没有可用源。<br>使用 RUN apt-get update &amp;&amp; apt-get install -y 命令可以确保 Dockerfiles 配置文件每次安装的都是包的最新版本，而且这个过程不需要进一步编码或额外干预 ，这项技术叫作缓存破坏( Cache Busting ）。</p>          </div><h3 id="MAINTAINER-deprecated"><a href="#MAINTAINER-deprecated" class="headerlink" title="MAINTAINER (deprecated)"></a>MAINTAINER (deprecated)</h3><p>已废弃，使用 LABEL 命令代替。</p><h3 id="ADD-amp-amp-COPY"><a href="#ADD-amp-amp-COPY" class="headerlink" title="ADD &amp;&amp; COPY"></a>ADD &amp;&amp; COPY</h3><p><strong>用途：</strong>ADD 和 COPY 命令都是在构建镜像时， <strong>将 src 路径复制新文件、目录或远程文件 URL，并将它们添加到图像的文件系统中 dest</strong>，但一般优先使用 COPY 命令，因为 ADD 命令比 COPY 命令更加透明。ADD 相较于 COPY 除了支持从本地复制文件到镜像，ADD 指令还支持通过 URL 从远程服务器读取资源并复制到镜像中。</p><div class="note note-success">            <p>事实上当要从远程获取资源的时候推荐使用 RUN 命令：<code>RUN wget</code>或<code>RUN curl</code>，而 ADD 指令更擅长读取本地 tar 文件并解压缩 </p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]<br><br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>chown&#x3D;user:group：</strong>当执行 ADD、COPY 指令时源文件的各种元数据都会保留，比如读、写、执行权限、文件变更时间等，可以通过 <code>--chown=&lt;user&gt;:&lt;group&gt; </code>选项来改变文件的所属用户及所属组。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD/COPY --chown=<span class="hljs-number">55</span>:mygroup files* /somedir/<br>ADD/COPY --chown=bin files* /somedir/<br>ADD/COPY --chown=<span class="hljs-number">1</span> files* /somedir/<br>ADD/COPY --chown=<span class="hljs-number">10</span>:<span class="hljs-number">11</span> files* /somedir/<br></code></pre></td></tr></table></figure><ul><li><strong>src：</strong>拷贝源文件路径，src 可以使用通配符，将使用 Go 的 <a href="https://pkg.go.dev/path/filepath#Match">filepath.Match</a> 规则匹配完成。例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ADD hom* /mydir/<br>ADD hom?.txt /mydir/<br></code></pre></td></tr></table></figure><ul><li><strong>dest：</strong>拷贝到镜像的目标路径，可以是容器内的绝对路径，也可以是工作目录相对路径（工作目录可以用 WORKDIR 指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</li></ul><h3 id="CMD-amp-amp-ENTRYPOINT"><a href="#CMD-amp-amp-ENTRYPOINT" class="headerlink" title="CMD &amp;&amp; ENTRYPOINT"></a>CMD &amp;&amp; ENTRYPOINT</h3><p><strong>用途：</strong>CMD 命令和 ENTRYPOINT 命令部可以用于设置容器启动时要执行的命令， Dockerfile 置文件中 CMD 或 ENTRYPOINT 必须至少有其一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">CMD [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br>CMD command param1 param2  # shell格式<br>CMD [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]  # exec参数，用来为ENTRYPOINT 提供参数<br><br>ENTRYPOINT [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  # exec格式<br>ENTRYPOINT command param1 param2 # shell格式<br>## 例如：<br>CMD java -jar demo.jar<br>CMD [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;demo.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>ENTRYPOINT</code>应该被当做 docker 的可执行程序，<code>CMD</code>应该被当做<code>ENTRYPOINT</code>的默认参数。<br><code>docker run &lt;image&gt; &lt;arg1&gt; &lt;arg2&gt; ...</code>会把之后的参数传递给<code>ENTRYPOINT</code>，覆盖 CMD 指定的参数。可以用<code>docker run --entrypoint</code>来重置默认的 ENTRYPOINT，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTRYPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/opt/iam/bin/iam-apiserver&quot;</span>]</span><br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;/etc/iam/iam-apiserver.yaml&quot;</span>]</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>与 RUN 命令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD、ENTRYPOINT 在容器运行的时候执行，在构建时不进行任何操作。</p>          </div><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p><strong>用途：</strong>镜像打标签</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>如果 base image 中也有标签，则继承，如果是同名标签，则覆盖。</li><li>为了减少图层数量，尽量将标签写在一个 LABEL 指令中去，如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">LABEL multi.label1=<span class="hljs-string">&quot;value1&quot;</span> \<br>      multi.label2=<span class="hljs-string">&quot;value2&quot;</span> \<br>      other=<span class="hljs-string">&quot;value3&quot;</span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><strong>用途：</strong>为构建的镜像设置监听端口，使容器在运行时监听。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>EXPOSE 指令并不会让容器监听 Host 的端口，如果需要，需要在 docker run 时使用-p 参数来发布容器端口到 Host 的某个端口上。</p>          </div><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><strong>用途：</strong>在构建的镜像中设置环境变量，在后续的 Dockerfile 指令中可以直接使用，也可以固化在镜像里，在容器运行时仍然有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ENV &lt;key&gt; &lt;value&gt;<br>ENV &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>ENV key value：把第一个空格之后的所有值都当做<key>的值，无法在一行内设定多个环境变量。</li><li>ENV key&#x3D;value …：可以设置多个环境变量，如果<value>中存在空格，需要转义或用引号”括起来。</li></ul><div class="note note-success">            <p>可以在容器运行时指定环境变量，替换镜像中的已有变量，docker run –env key&#x3D;value<br>推荐使用在一行中写多个环境变量，减少图层</p>          </div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ENV myName=<span class="hljs-string">&quot;John Doe&quot;</span> \<br>    myDog=Rex\ The\ Dog \<br>    myCat=fluffy<br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><strong>用途：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">VOLUME [<span class="hljs-string">&quot;/data&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><strong>用途：</strong>为接下来的 Dockerfile 指令指定当前工作目录，可多次使用，如果使用的是相对路径，则相对的是上一个工作目录，类似 shell 中的 cd 命令。<br>影响的指令有：<code>RUN、CMD、ENTRYPOINT、COPY和ADD。</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">WORKDIR /path/to/workdir<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>建议使用 WORKDIR 命令来代替类似于 RUN cd … &amp;&amp; do -something 等的命令，因为后者难以阅读维护</p>          </div><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><strong>用途： <strong>设置镜像构建时的环境变量，使用效果 ENV 一样。所不同的是，</strong>ARG 所设置环境变量生命周期仅在镜像构建期间</strong>，在将来容器运行时是不会存在这些环境变量的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ARG &lt;name&gt;[=&lt;<span class="hljs-keyword">default</span> value&gt;]<br></code></pre></td></tr></table></figure><p><strong>使用方法：</strong><br>当 Dockerfile 指定 ARG 参数时可通过<code>docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code>传入参数值进行覆盖。<br>docker 内置了一批构建参数，可以不用在 Dockerfile 中声明：<code>HTTP_PROXY、http_proxy、HTTPS_PROXY、https_proxy、FTP_PROXY、ftp_proxy、NO_PROXY、no_proxy</code></p><h3 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h3><p><strong>用途：</strong>创建一个可以从<strong>本地主机</strong>或<strong>其它容器挂载</strong>的挂载点，用来保持数据不被销毁。Volume 可以在容器之间以及容器和主机之间共享和重用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">VOLUME <span class="hljs-selector-attr">[<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 命令会将&quot;/data&quot;目录挂载到容器 ，开发人员可以在宿主机上直接操作该目录，</span><br><span class="hljs-comment"># 任何在该镜像&quot;/data&quot;目录中的文件都将被复制到 Volume中。</span><br>docker run -it --name container-test -h CONTAINER -v <span class="hljs-regexp">/data nginx /</span>bin/bash<br><span class="hljs-comment"># 可以找到容器与宿主机的挂载关系</span><br>docker inspect -f &#123;&#123;.Volumes&#125;&#125; container-test<br><span class="hljs-comment"># 在宿主机的目录下创建一个文件，然后进入容器的/data目录下会相应看到创建的文件</span><br>sudo touch <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>vfs<span class="hljs-regexp">/dir/</span>cde1671***<span class="hljs-number">37</span>a9/test-file<br><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>和 Linux 不同，在 mac 上用 docker 会在 mac 上启动一个虚拟机运行 docker，因此 volume 创建的 directory 并不在你的 machine 上，而是在虚拟机中。</p>          </div><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><strong>用途：</strong>向镜像中添加一个触发器，当以该镜像为 base image 再次构建新的镜像时，会触发执行其中的指令。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ONBUILD</span><span class="hljs-meta"> [INSTRUCTION]</span><br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 在下一次以此镜像为base image的构建中，执行ADD . /app/src，将项目代目添加到新镜像中去</span><br><span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="language-bash"> . /app/src</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>ONBUILD 只会继承给子节点的镜像，不会再继承给孙子节点。<br>ONBUILD ONBUILD 或者 ONBUILD FROM 或者 ONBUILD MAINTAINER 是不允许的。</p>          </div><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><strong>用途：</strong>增加自定义的心跳检测功能，多次使用只有最后一次有效。格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [OPTION] CMD &lt;<span class="hljs-built_in">command</span>&gt;  <span class="hljs-comment"># 通过在容器内运行command来检查心跳</span></span><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> NONE                    <span class="hljs-comment"># 取消从base image继承来的心跳检测</span></span><br></code></pre></td></tr></table></figure><p><strong>可选的 OPTION：</strong><br><code>--interval=DURATION：</code>检测间隔，默认 30 秒；<br><code>--timeout=DURATION：</code>命令超时时间，默认 30 秒；<br><code>--retries=N：</code>连续 N 次失败后标记为不健康，默认 3 次；<br><command>可以是 shell 脚本，也可以是 exec 格式的 json 数组。<br>docker 以<command>的退出状态码来区分容器是否健康，这一点同 shell 一致：</p><ul><li>0：命令返回成功，容器健康</li><li>1：命令返回失败，容器不健康</li><li>2：保留状态码，不要使用&#96;</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 每5分钟检测本地网页是否可访问，超时设为3秒：</span><br>HEALTHCHECK --interval=<span class="hljs-number">5</span>m --timeout=<span class="hljs-number">3</span>s \<br>    CMD curl -f http:<span class="hljs-regexp">//</span>localhost/ || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用途：指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。<strong>容器不推荐使用 root 权限。</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">USER</span> <span class="hljs-title">&lt;user</span>&gt;[:<span class="hljs-tag">&lt;group&gt;</span>]<br><span class="hljs-comment"># 声明使用node用户</span><br><span class="hljs-keyword">USER</span> <span class="hljs-title">node</span><br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/qianlei90/Blog/issues/35">https://github.com/qianlei90/Blog/issues/35</a><br><a href="https://segmentfault.com/a/1190000018222648">https://segmentfault.com/a/1190000018222648</a><br><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">https://docs.docker.com/engine/reference/builder/#dockerignore-file</a><br><a href="https://mp.weixin.qq.com/s/vjD-JDw_2bYWa2InUfWHow">https://mp.weixin.qq.com/s/vjD-JDw_2bYWa2InUfWHow</a><br><a href="https://mp.weixin.qq.com/s/ojZvxQTssqERueGahFGCbQ">https://mp.weixin.qq.com/s/ojZvxQTssqERueGahFGCbQ</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门基础</title>
    <link href="/2022/06/20/docker-startup/"/>
    <url>/2022/06/20/docker-startup/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>一个“容器”，实际上是一个由 <code>Linux Namespace</code>、<code>Linux Cgroups </code>和 <code>rootfs</code>三种技术构建出来的进程的隔离环境。一个正在运行的 Linux 容器，其实可以被“一分为二”地看待：</p><ul><li>一组联合挂载在 <code>/var/lib/docker/aufs/mnt</code> 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</li><li>一个由<code>Namespace+Cgroups</code>构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</li></ul><div class="note note-success">            <p>关于容器背景的几个知识点：</p><ul><li>容器技术的兴起源于 PaaS 技术的普及；</li><li>Docker 公司发布的 Docker 项目具有里程碑式的意义，Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。</li><li>容器本身没有价值，有价值的是“容器编排”。</li></ul>          </div><h1 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2. Docker 安装"></a>2. Docker 安装</h1><p>Docker 安装非常方便，支持 Ubuntu、RHEL、CentOS、Debian 等 Linux 发行版，同时也可以在 OSX 、Microsoft Windows 等非 Linux 平台下安装使用。<br>各平台安装情况参见官网：<a href="https://docs.docker.com/desktop/mac/install/">Mac</a>、<a href="https://docs.docker.com/desktop/windows/install/">Windows</a>、<a href="https://docs.docker.com/desktop/linux/install/">Linux</a><br>本文以 Centos7.x 安装任意版本为例。<br><strong>步骤一、卸载原有平台</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum remove docker\</span><br><span class="language-bash">           docker-client\</span><br><span class="language-bash">           docker-client-latest\</span><br><span class="language-bash">           docker-common\</span><br><span class="language-bash">           docker-latest\</span><br><span class="language-bash">           docker-latest-logrotate\</span><br><span class="language-bash">           docker-logrotate\</span><br><span class="language-bash">           docker-engine</span><br></code></pre></td></tr></table></figure><p><strong>步骤二、安装 Docker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装yum源工具包</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum -y install yum-utils</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加Docker源</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum-config-manager\</span><br><span class="language-bash"> --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></code></pre></td></tr></table></figure><p>大多数情况下，可以直接安装最新版本的 Docker ，因为最新版本的 Docker 有着更好的稳定性和安全性。但是有时候需要与其他生态软件进行兼容或者其他原有需要按照制定版本 Docker 时就需要进行选择性安装了，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">直接安装最新版本</span><br>yum install docker-ce docker-ce-cli containerd.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">展示各个版本Docker</span><br>yum list docker-ce --showduplicates | sort -r<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装制定版本Docker</span><br>yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io<br></code></pre></td></tr></table></figure><p><strong>步骤三、启动并运行测试容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl start docker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看运行状态</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl status docker</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行测试容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br>docker run hello-world<br>Unable to find image &#x27;hello-world:latest&#x27; locally<br>latest: Pulling from library/hello-world<br>2db29710123e: Pull complete<br>Digest: sha256:13e367d31ae85359f42d637adf6da428f76d75dc9afeb3c21faea0d976f5c651<br>Status: Downloaded newer image for hello-world:latest<br><br>Hello from Docker!<br>...<br></code></pre></td></tr></table></figure><h1 id="3-Docker-组件"><a href="#3-Docker-组件" class="headerlink" title="3. Docker 组件"></a>3. Docker 组件</h1><h2 id="3-1-Docker-五大组件"><a href="#3-1-Docker-五大组件" class="headerlink" title="3.1 Docker 五大组件"></a>3.1 Docker 五大组件</h2><p>如下所示，Docker 一共包含了：<code>DockerClient</code>、<code>Deamon</code>、<code>Images</code>、<code>Containers</code>、<code>Registry</code>等五大组件。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FqLhkrp10MdxxXrVSrOcYtdkYmBm.png"></p><h3 id="3-1-1-DockerClient"><a href="#3-1-1-DockerClient" class="headerlink" title="3.1.1 DockerClient"></a>3.1.1 DockerClient</h3><p><code>docker client</code> 是 docker 架构中用户用来和<code>docker daemon</code>建立通信的客户端，用户使用的可执行文件为 docker，通过 docker 命令行工具可以发起众多管理 container 的请求。</p><p>docker client 可以通过一下三种方式和 docker daemon 建立通信：<br><code>tcp://host:port</code>、<code>unix:path_to_socket</code>、<code>fd://socketfd</code> docker client 可以通过设置命令行 flag 参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。</p><p>docker client 发送容器管理请求后，由 docker daemon 接受并处理请求，当 docker client 接收到返回的请求相应并简单处理后，docker client 一次完整的生命周期就结束了，当需要继续发送容器管理请求时，用户必须再次通过 docker 可以执行文件创建 docker client。</p><h3 id="3-1-2-Docker-Deamon"><a href="#3-1-2-Docker-Deamon" class="headerlink" title="3.1.2 Docker Deamon"></a>3.1.2 Docker Deamon</h3><p>Docker Daemon（守护进程）作为 Docker 架构中的主体部分，常处于后台的系统进程中用于提供 Docker Server 功能，接收并处理 Docker Client 的请求。</p><p>Docker Daemon 是 Docker 架构中运行在后台的守护进程，大致可以分为<code>Docker Server</code>、<code>Docker Engine</code>、<code>Job</code>。Docker Daemon 可以认为是通过 Docker Server 模块接受 Docker Client 的请求，并在 Engine 中处理请求，然后根据请求类型，创建出指定的 Job 并运行。<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FveTbUQwETU-2THuur9IPJ-i41qe.png"><br>● Docker Server<br>相当于 C&#x2F;S 架构的服务器端，既可以是本地的，也可以是远程的作用是接收并分发 Docker Client 发起的请求。在其内部实现是由 Server 接受来自 Client 的请求，并创建一个 Goroutine 处理请求。</p><ul><li><strong>Docker Engine</strong></li></ul><p>Docker 架构中的运行引擎，同时是 Docker 运行的核心模块。它扮演 Docker Container 的角色，并且通过执行 Job 的方式来操纵和管理这些容器，每项工作都是以一个 Job 的形式存在的。</p><ul><li><strong>Job</strong></li></ul><p>一个 Job 可以被认为是 Docker 架构中 Engine 内部最基本的工作执行单元 ，Docker 做的每项工作都可以抽象为一个 Job 。例如，在容器内部运行一个进程是一个 Job ，创建一个新的容器是 Job，Docke Server 的运行过程也是一个 Job。</p><h3 id="3-1-3-Images"><a href="#3-1-3-Images" class="headerlink" title="3.1.3 Images"></a>3.1.3 Images</h3><p>简单地理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。</p><div class="note note-success">            <p>一般而言， Linux 分为两个部分：Linux 内核（Linux Kernel）与用户空间，而真正的 Linux 操作系统，是指 Linux 内核，我们常用的 Ubuntu、CentOS 等操作系统其实是不同厂商在 Linux 内核基础上添加自己的软件与工具集（tools）形成的发布版本（Linux Distribution）。</p><p>因此，我们也可以把镜像看成是上面所说的用户空间，当 Docker 通过镜像创建一个容器时，就是将镜像定义好的用户空间作为独立隔离的进程运行在宿主机的 Linux 内核之上。</p>          </div><p>这里要强调一下镜像的两个特征：</p><ul><li><strong>镜像是分层（Layer）的：</strong>即一个镜像可以多个中间层组成，多个镜像可以共享同一中间层，我们也可以通过在镜像添加多一层来生成一个新的镜像。</li><li><strong>镜像是只读的（read-only）：</strong>镜像在构建完成之后，便不可以再修改，而上面我们所说的添加一层构建新的镜像，这中间实际是通过创建一个临时的容器，在容器上增加或删除文件，从而形成新的镜像，因为容器是可以动态改变的。</li></ul><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FrWYT83vgb0zaKf0LUBZdbpfydPE.png"></p><h3 id="3-1-4-Containers"><a href="#3-1-4-Containers" class="headerlink" title="3.1.4 Containers"></a>3.1.4 Containers</h3><p>容器与镜像的关系，就如同面向编程中对象与类之间的关系。</p><p>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立于宿主机的隔离进程，并且有属于容器自己的网络和命名空间。</p><p>我们前面介绍过，<strong>镜像由多个中间层（layer）组成，生成的镜像是只读的，但容器却是可读可写的，这是因为容器是在镜像上面添一层读写层（writer&#x2F;read layer）来实现的</strong>，如下图所示：<br><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FtBUiM6gDYUaT4dsEf0lWgdCtbSg.png"></p><h3 id="3-1-5-Registry"><a href="#3-1-5-Registry" class="headerlink" title="3.1.5 Registry"></a>3.1.5 Registry</h3><p>仓库（Repository）是集中存储镜像的地方，这里有个概念要区分一下，那就是仓库与仓库服务器(Registry)是两回事，像我们上面说的 Docker Hub，就是 Docker 官方提供的一个仓库服务器，不过其实有时候我们不太需要太过区分这两个概念。</p><ul><li><strong>公共仓库</strong></li></ul><p>公共仓库一般是指 Docker Hub，前面我们已经多次介绍如何从 Docker Hub 获取镜像，除了获取镜像外，我们也可以将自己构建的镜像存放到 Docker Hub，这样，别人也可以使用我们构建的镜像。</p><ul><li><strong>私有仓库</strong></li></ul><p>虽然 Docker 官方提供了公共的镜像仓库，但是从安全和效率等方面考虑，部署我们私有环境内的 Registry 也是非常必要的。</p><p><a href="https://github.com/goharbor/harbor">Harbor</a>是由 VMware 公司开源的企业级的 Docker Registry 管理项目，相比 docker 官方拥有更丰富的权限权利和完善的架构设计，适用大规模 docker 集群部署提供仓库服务。<br>它主要提供 Dcoker Registry 管理界面 UI，可基于角色访问控制,镜像复制， AD&#x2F;LDAP 集成，日志审核等功能，完全的支持中文。</p><h2 id="3-2-Docker"><a href="#3-2-Docker" class="headerlink" title="3.2 Docker"></a>3.2 Docker</h2><p><img src="https://hexo-blogs.oss-cn-hangzhou.aliyuncs.com/blog/image/yuque/cn/FkAvpjBkuMyj4_cjwT5Jkg9wxio1.png"><br>除了 Docker Engine 外，还有 <code>Network Container</code>、 <code>Image</code>、<code>Data Volumes</code>、<code>Container</code>、 <code>Image</code>，下面重点介绍 Network、Data Volumes</p><ul><li><strong>Network：</strong>不仅可以很方便地维护和管理 Docker 网络，还可以很方便地在容器之间通过 IP 址和端口进行交互。</li><li><strong>Data Volumes：</strong>可以视为容器中的一种特殊的文件路径，用于保存与容器实例生命周期无关的共享数据，它可以存放在一个或多个容器内特定的目录下，提供独立于容器的持久化存储。</li></ul><p>Data Volumes 是经过特殊设计的目录，可以绕过 UnionFS ( Union File System，联合文件系统 ），为一个或多个容器提供访问，从而实现容器间的数据共享，它有如下几个特性：</p><ol><li>在容器创建时初始化</li><li>作为文件系统的一部分，但是不受 UnionFS 的管理</li><li>便于持久化存储数据和共享数据。</li><li>Data Volumes 的数据是持久化的，删除容器不影响 Data Volumes 的数据。</li><li>对 Data Volumes 的操作会立刻生效</li></ol><h1 id="4-Docker-容器技术原理"><a href="#4-Docker-容器技术原理" class="headerlink" title="4. Docker 容器技术原理"></a>4. Docker 容器技术原理</h1><h2 id="4-1-chroot"><a href="#4-1-chroot" class="headerlink" title="4.1 chroot"></a>4.1 chroot</h2><p>提起容器就不得不说<code>chroot</code>，因为<code>chroot</code>是最早的容器雏形。<code>chroot</code>意味着切换根目录，有了<code>chroot</code>就意味着我们可以把任何目录更改为当前进程的根目录，这与容器非常相似。</p><div class="note note-info">            <p><code>chroot</code>是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由<code>chroot</code>设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p>          </div><p>简单来说就是，<strong>chroot 就是可以改变某进程的根目录，使这个程序不能访问目录之外的其他目录。</strong><br>chroot 示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">步骤一：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前命令常见一个rootfs目录</span><br>mkdir -p /home/rootfs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为了方便演示，使用现成的 busybox 镜像来创建一个系统</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令用于创建一个busybox的容器，并将之导出到当前目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样做的目的时为了得到一个可运行的操作系统目录文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">export</span> $(docker create busybox) -o busybox.tar</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf busybox.tar</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>bin  busybox.tar  dev  etc  home  proc  root  sys  tmp  usr  var<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">步骤二：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 rootfs 目录下初始化了一些目录，下面让我们通过一条命令来见证 <span class="hljs-built_in">chroot</span> 的神奇之处。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用以下命令，可以启动一个 sh 进程，并且把 /home/centos/rootfs 作为 sh 进程的根目录。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chroot</span> /home/rootfs /bin/sh</span><br>/ #<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时，我们的命令行窗口已经处于上述命令启动的 sh 进程中。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前sh命令行窗口下，我们使用<span class="hljs-built_in">ls</span>命令查看一下当前进程，看是否真的与主机上的其他目录隔离开了</span><br>/ # /bin/ls /<br>bin  busybox.tar  dev  etc  home  proc  root  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p>这里可以看到：<code>当前进程的根目录</code>已经变成了主机上的<code>/home/rootfs</code> 目录。这样就实现了当前进程与主机的隔离。到此为止，一个目录隔离的容器就完成了。<br>到目前为止使用了 chroot 完成了对资源目录的隔离，但是还不能完整的称之为时一个容器，因为他的进程网络等信息还未隔离，要实现一个完整的容器还需要依靠 Linux 的其他三项技术： <strong>Namespace</strong>、<strong>Cgroups</strong> 和<strong>UnionFS</strong></p><h2 id="4-2-Namespace"><a href="#4-2-Namespace" class="headerlink" title="4.2 Namespace"></a>4.2 Namespace</h2><p>Namespace 是 Linux 内核的一项功能，该功能对内核资源进行隔离，使得容器中的进程都可以在单独的命名空间中运行，并且只可以访问当前容器命名空间的资源。Namespace 可以隔离进程 ID、主机名、用户 ID、文件名网络访问和进程间通信等相关资源。Docker 主要用到以下五种命名空间：</p><ul><li><strong>pid namespace</strong>：用于隔离进程 ID。</li><li><strong>net namespace</strong>：隔离网络接口，在虚拟的<code>net namespace</code>内用户可以拥有自己独立的<code>IP</code>、<code>路由</code> 、<code>端口</code>等。</li><li><strong>mnt namespace</strong>：文件系统挂载点隔离。</li><li><strong>ipc namespace</strong>：信号量, 消息队列和共享内存的隔离。</li><li><strong>uts namespace</strong>：主机名和域名的隔离。</li></ul><h2 id="4-3-Cgroups"><a href="#4-3-Cgroups" class="headerlink" title="4.3 Cgroups"></a>4.3 Cgroups</h2><p>Cgroups 是一种 Linux 内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘 I&#x2F;O、网络等）。在容器的实现中，Cgroups 通常用来限制容器的 CPU 和内存等资源的使用。</p><h2 id="4-4-联合文件系统"><a href="#4-4-联合文件系统" class="headerlink" title="4.4 联合文件系统"></a>4.4 联合文件系统</h2><p>联合文件系统，又叫 UnionFS，是一种通过创建文件层进程操作的文件系统，因此，联合文件系统非常<br>轻快。Docker 使用联合文件系统为容器提供构建层，使得容器可以实现写时复制以及镜像的分层构建<br>和存储。常用的联合文件系统有：<strong>AUFS</strong>、<strong>Overlay</strong> 和 <strong>Devicemapper</strong> 等。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://dockone.io/article/9249">http://dockone.io/article/9249</a><br><a href="https://i4t.com/4248.html">https://i4t.com/4248.html</a></p>]]></content>
    
    
    <categories>
      
      <category>云原生</category>
      
      <category>Docker容器技术</category>
      
      <category>Docker基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-New-Post</title>
    <link href="/2022/06/15/undefined/"/>
    <url>/2022/06/15/undefined/</url>
    
    <content type="html"><![CDATA[<p>sdf</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h5 id="五级"><a href="#五级" class="headerlink" title="五级"></a>五级</h5>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
